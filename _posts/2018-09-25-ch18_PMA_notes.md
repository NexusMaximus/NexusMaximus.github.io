---
layout: post
title: "PMA Ch.18 Notes: Packers and Unpacking"
date: 2025-09-25 14:31:00 -0600
categories: notes
---


## Chapter summary questions
1. In two sentences or less, provide an overview of what this chapter is about.
2. What are the three most important takeaways from this chapter?
3. What problems does this chapter address? In other words, why should we care about this chapter?

## Overview of how packing works
Packers generally follow the same pattern: they transform an executable to create a new executable that stores the transformed executable as data and contains an unpacking stub that is called by the OS. In order for the maliciously packed executable to run, there *must* be some part of the executable that is unpacked, as the OS requires this to be able to run the program. This is what the unpacking stub is. 

To maintain the functionality of the original program, a packing program needs to store the program's import information. The information can be stored in any format, and there are several common strategies which will be discussed later. 

Packers can pack the entire executable, including all data and the resource section, or they can pack only the code and data sections. 

## The Unpacking Stub
The purpose of the unpacking stub is typically to load the packed packed program, unpack it, resolve imports of the original executable, and transfer execution to the original entry point. It need not unpack the entire executable. Understanding how the stub works is almost always crucial to understanding the malware. 

## Resolving imports
Because the Windows loader cannot read import information that is packed, the unpacking stub must resolve the imports. There are a few approaches that can be taken to do this.
* Most common: have the unpacking stub import ``LoadLibrary`` and ``GetProcAddress`` functions. After the unpacking stub unpacks the original executable, it reads the original import information, uses ``LoadLibrary`` to load those libraries, and uses ``GetProcAddress`` to get the address for functions in each library. 
* Another approach: Keep the imports table intact.
* A third approach: keep one import function from each DLL in the original import table. In this case, ``LoadLibrary`` will not be needed, but the stub will still need to resolve the other functions. 
* The final discussed approach is to remove all imports including ``LoadLibrary`` and ``GetProcAddress``. Then, the packer must find all functions needed from other libraries without using those functions, or it must find ``LoadLibrary`` and ``GetProcAddress`` and then use them to load other libraries. This is the stealthiest method, but also the most difficult to implement. 



## Recognizing packed programs
There are often giveaways that are indicative of a packed program.
* Program has few imports, and those imports are often just ``LoadLibrary`` and ``GetProcAddress``
* When the program is opened in IDA, only a small amount of code is recognized by the automatic analysis.
* When the program is opened in OllyDbg, there is a warning that the program is packed.
  * How does OllyDbg identify this? Do we even care in 64-bit land?
* The program shows section names that indicate a particular packer
  * What are section names typically for executables?
* the program has abnormal section sizes, such as a ``.text`` section that has a raw size of 0 but a virtual size of nonzero. 

### Entropy Calculation
*Entropy Calculation* is a technique where packed executables can be detected based on the randomness of the executable. Encrypted or otherwise packed programs usually have high entropy. 


## Unpacking executables
Three options:
1. Automated static unpacking.
2. Automated dynamic unpacking.
3. Manual dynamic unpacking.

Manual static unpacking is completely infeasible. 


### Automated static unpacking
This is generally the best and fastest method, when it works, because it unpacks a program but does not run the unpacked program. Programs that perform automated static unpacking generally only work for one type of packer. 

### Automated dynamic unpacking
These run the packed program and allow the unpacking stub to unpack the original executable code. Once the unpacking stub finishes, it writes the unpacked program to disk, and the unpacker reconstructs the import table. 

The unpacking program must determine where the unpacking stub ends and where the original executable begins, which is difficult. 

As of the time of this book's writing, "there are no good publicly available automated dynamic unpackers." 

### Automated static unpacking
There are two common approaches to manually unpacking a program.

1. Discover the packing algorithm and write a program to run it in reverse. This is generally less efficient, but may be useful if dealing with many different executables that are packed in the same manner.

2. Run the packed program up to the point where the unpacking stub finishes and does the work for you, and then dump the process out of memory and manually fix up the PE header so that the program is complete. 


## Manually finding the OEP of a packed program

A *tail jump* is the jump a packed program makes between wrapping up the unpacking stub's code and beginning the unpacked executable's code.

In order to

* jumps that are very far away (think hundreds to thousands of bytes) are typically signs of being a tail jump.
* 

Idea: Determine the feasibility of writing a program or a plugin of sorts that looks for the tail jump to help manual unpacking, by statically analyzing all the transfer of execution instructions and looking for signs that could help cross them off the list of potential tail jump instructions. There's only a finite number of them and a good chunk of them will be used in unpacking. 


NEEDS:
  * testing: a few packers, maybe a custom one
  * A debugger for 64 bit programs (?). Thinking x64dbg is the current standard
  * malware. if 32 bit works, then this'll be developed as an ollydbg plugin and i'll use my textbook as my
  intro to ollydbg 


## Terminology


## Page-to-page notes
* here
  * here

## Tools discussed in this section
here

## Questions encountered (and answers, if found)
here





