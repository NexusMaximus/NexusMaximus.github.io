<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-11-14T15:14:55-07:00</updated><id>http://localhost:4000/</id><title type="html">Kyle the (Aspiring) Reverser</title><subtitle>A home for a slew of miscellaneous technical (or not) blogs I write in the process of completing my Masters thesis.</subtitle><entry><title type="html">Paper review: Binary-Code Obfuscations in Prevalent Packer Tools</title><link href="http://localhost:4000/notes/2018/11/10/binary-code_obfs_paper_review.html" rel="alternate" type="text/html" title="Paper review: Binary-Code Obfuscations in Prevalent Packer Tools" /><published>2018-11-10T10:31:00-07:00</published><updated>2018-11-10T10:31:00-07:00</updated><id>http://localhost:4000/notes/2018/11/10/binary-code_obfs_paper_review</id><content type="html" xml:base="http://localhost:4000/notes/2018/11/10/binary-code_obfs_paper_review.html">&lt;h2 id=&quot;abstract&quot;&gt;Abstract&lt;/h2&gt;

&lt;p&gt;Security analysts’ understanding of malware samples depends on the ability to build high-level analysis products from the raw bytes of program binaries. As such, the first step to analyzing defensive malware samples is understanding what obfuscations are present in these binaries, and how the obfuscations hinder analysis. This paper provides details on those techniques.&lt;/p&gt;

&lt;p&gt;Section 2 is all about the methodology and tools used to perform the study. Section 3 is a taxonomy of the obfuscation techniques, along with current approaches to dealing with the techniques. Section 4 provides a summary table of the obfuscation techniques that shows their relative prevalence in real-world malware.&lt;/p&gt;

&lt;h2 id=&quot;section-2-methodology&quot;&gt;Section 2: Methodology&lt;/h2&gt;

&lt;p&gt;– to be written, maybe –&lt;/p&gt;

&lt;h2 id=&quot;section-3-obfuscation-techniques&quot;&gt;Section 3: Obfuscation techniques&lt;/h2&gt;

&lt;h3 id=&quot;binary-code-extraction&quot;&gt;Binary code extraction&lt;/h3&gt;
&lt;p&gt;This is the ultimate goal of analysis– to extract the code from a sample so it can be analyzed. On unpacked/nondefensive binaries, this is trivial, as we simply need to read from the executable portions of the binary file. It gets more challenging with programs that create code or self-modify at runtime.&lt;/p&gt;

&lt;p&gt;In practice, most malware authors create an unpacked executable and then pack it with a packer tool to create a packed version. Most packers can be thought of as elaborations on UPX’s packing scheme.&lt;/p&gt;

&lt;h4 id=&quot;how-upx-works&quot;&gt;How UPX works&lt;/h4&gt;

&lt;p&gt;UPX (or almost any other packing tool) sets the executable’s entry point to the entry point of the bootstrap code that unpacks the payload and then transfers control to the payload’s OEP. When the bootstrap code unrolls packed code and data, it places them at the same memory addresses that they occupied in the original binary, so that position-dependant instructions do not move and data accesses find the data in their expected locations.&lt;/p&gt;

&lt;p&gt;UPX also packs the PE’s Import Table and Import Address Table data structures. These tables list functions to import from other shared libraries. They are packed because just knowing these functions can reveal significant information about the payload code (and also because the tables are highly amenable to compression).&lt;/p&gt;

&lt;h4 id=&quot;building-on-this-technique&quot;&gt;Building on this technique&lt;/h4&gt;

&lt;p&gt;The most common elaboration of this basic recipe is one in which portions of the packer’s bootstrap code itself are also packed. Most packers use a small unpacking loop to decompress a more sophisticated decompression or decryption algorithm that unpacks the actual payload. For example, ASProtect unpacks 99% of its unpacking code, in addition to the program payload itself.&lt;/p&gt;

&lt;h4 id=&quot;the-x-ray-technique-perriot-and-ferrie-2004&quot;&gt;The X-Ray technique [Perriot and Ferrie 2004]&lt;/h4&gt;

&lt;p&gt;This technique statically analyzes the program binary with the aim of seeing through the compression and encryption transformation with which the payload code is packed. It leverages statistical properties of packed code to recognize compression algorithms and uses &lt;em&gt;known cipher-text attacks&lt;/em&gt; to crack weak encryption schemes. Weakness: ineffective against strong encryption and multiple layers of compression or encryption. Further work has been done to improve the technique, but it hasn’t yet been shown to work on a broad collection of samples (as of when this paper was written, in 2013).&lt;/p&gt;

&lt;h4 id=&quot;identifying-written-then-executed-code&quot;&gt;Identifying written-then-executed code&lt;/h4&gt;

&lt;p&gt;This technique is used by a host of dynamic analysis tools. They detect and capture unpacked code bytes by tracing the program’s execution at a fine granularity and logging memory writes to identify written-then-executed code. Some leverage the Qemu whole-system emulator and the Xen virtual machine monitor respectively, which allows them to observe execution of monitored malware without being easily detected. [2007ish time frame– Renovo and EtherUnpack]&lt;/p&gt;

&lt;p&gt;There exist unpacker tools that run packed programs either for a certain timeout period, or until they exhibit behavior that could indicate that they are done unpacking. The primary limitations of fine-grained monitoring techniques are that they only identify code bytes that are actually executed and they incur orders of magnitude slowdowns in execution time (those conditional breakpoints tho). This technique is good for antivirus products, but the coarse memory-page granularity means they cannot identify the actual code bytes on unpacked code pages and they cannot identify or capture overwritten code bytes.&lt;/p&gt;

&lt;h4 id=&quot;code-overwriting&quot;&gt;Code Overwriting&lt;/h4&gt;

&lt;p&gt;Self-modifying programs move beyond unpacking by overwriting existing code with new code at runtime. Code overwriting often occurs in small amounts, affecting just a single instruction or even just a single instruction operand. For example, ASPack modifies the push operand of a &lt;code class=&quot;highlighter-rouge&quot;&gt;push 0, ret&lt;/code&gt; instruction sequence at runtime to plug in the OEP address onto the call stack. UPack, however, has a second unpacking loop that overwrites the first one, removing several basic blocks at once from the function currently executing.&lt;/p&gt;

&lt;p&gt;Packers surveyed in this paper only overwrite their own metacode, but it’s possible to have more complex overwriting scenarios. Packers generally probably only overwrite their own code in an effort to maintain correctness and to be able to be used in a general case (i.e. for any malicious binary passed to it). An example of more complex unpackers: the MoleBox packer tool and the DarkParanoid virus repeatedly unpack sensitive code into a buffer, so only one buffer-full of the protected code is exposed to the analyst at any given time. This approach is sufficiently hard to implement, however, according to a paper in 2002.&lt;/p&gt;

&lt;p&gt;Self-modifying code presents a problem to all approaches of anlaysis because there is no point in time in which all of the program’s code is present in the binary. The only way to account for this is to take snapshots of basic blocks (i.e those without jumps in our out) as soon as the basic blocks execute.&lt;/p&gt;

&lt;h3 id=&quot;disassembly&quot;&gt;Disassembly&lt;/h3&gt;

&lt;p&gt;Once code bytes have been captured, static analysis techniques can accurately disassemble most of the code in compiler-generated program binaries, even when those binaries have been stripped of all symbol information. The general technique employed by disassembly tools is to disassemble the binary code starting from known entry points into the program.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Linear-sweep parsing&lt;/em&gt; disassembles sequentially from the beginning of the code section and assumes that the section contains nothing but code. The problem with this is the code section frequently contains non-code bytes such as string data and padding.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;recursive-traversal approach&lt;/em&gt; finds instructions by following all statically traversable paths through the program’s control flow starting from known function addresses. While more accurate, this technique misses control-transfer targets of instrucions that determine their targets dynamically based on register values and memory contents. 
Binaries stripped of symbol information can still have machine learning techniques applied to them to identify enough function entry points (by recognizing compiler-generated boiler plate code) to help recursive-traversal parsing. 
Of course, the weakness behind this approach is that the malware author would only need to modify the boiler-plate code of the compiler to trick the machine learning algorithms expecting a specific instruction pattern. 
Furthermore, to limit the amount of code that can be found by following control-transfer edges from the entry point (which must be left visible in the binary, or the OS can’t begin executing it), one can handwrite extremely irregular assembly code that a parser will have significant trouble interpreting.&lt;/p&gt;

&lt;p&gt;Here are some techniques that hide code, followed by techniques that corrupt analysis with non-code bytes or uncover errors in the disassembler.&lt;/p&gt;

&lt;h4 id=&quot;non-returning-calls&quot;&gt;Non-returning Calls&lt;/h4&gt;

&lt;p&gt;A &lt;code class=&quot;highlighter-rouge&quot;&gt;call&lt;/code&gt; instruction is basically a glorified &lt;code class=&quot;highlighter-rouge&quot;&gt;jmp&lt;/code&gt; instruction. Its job is to push a return location onto the stack, and then jump to another section of code. It is intended to be used with a corresponding &lt;code class=&quot;highlighter-rouge&quot;&gt;ret&lt;/code&gt; instruction, which pops the previously-pushed value into a register or area in memory and unconditionally jumps to it. This can be abused by, well, using the instructions in unconventional ways. This causes problems for analysis tools in three ways.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Recursive-traversal parsers assume that bytes following a non-returning call represent a valid instruction, because they presume the call will return execution to the area immediately after the call, but it doesn’t need to.&lt;/li&gt;
  &lt;li&gt;The attack breaks an important assumption made by code parsers for identifying function boundaries; namely, that the target of a call belongs to a different function than that of the call itself. There’s no reason why you can’t use a call to transfer execution somewhere else in the current function.&lt;/li&gt;
  &lt;li&gt;A binary instrumenter cannot move the call instruction of a call-pop sequence without changing the PC-relative address that the pop stores into a general-purpose register. Moving the call instruction without compensating for this change usually results in incorrect program execution, as packer metacode frequently uses the PC-relative address as a base pointer from which to access data.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Researchers have proposed removing the assumption that there is valid code at the fall-through address of each call instruction, but doing so drastically reduces the percentage of code that the parser can find, presumably since it can no longer be assumed that any code after a call is actually code. Kruegel et al. compensate by speculatively parsing after call instructions and use a statistical model of real code sequences to determine whether the speculatively parsed instruction sequences are valid. However, this technique was done by researchers in an attempt to just handle one kind of obfuscator, and made assumptions that were valid only for that obfuscator.&lt;/p&gt;

&lt;h4 id=&quot;call-stack-tampering&quot;&gt;Call-stack Tampering&lt;/h4&gt;

&lt;p&gt;One can semantically generate a &lt;code class=&quot;highlighter-rouge&quot;&gt;jmp&lt;/code&gt; instruction with a &lt;code class=&quot;highlighter-rouge&quot;&gt;push [value], ret&lt;/code&gt; combination, since &lt;code class=&quot;highlighter-rouge&quot;&gt;ret&lt;/code&gt; pops and jumps. ASProtect does this frequently. Furthermore, you could have this series of instructions:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pop ebp
inc ebp
push ebp
ret
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This would jump to an area immediately after a call, offset by +1 bytes, which would totally break the assumption that code &lt;strong&gt;immediately&lt;/strong&gt; following a &lt;code class=&quot;highlighter-rouge&quot;&gt;call&lt;/code&gt; is valid, since the valid code is now offset by an amount.&lt;/p&gt;

&lt;p&gt;The authors of this paper implement a technique to deal with this. They apply static analysis techniques to a &lt;code class=&quot;highlighter-rouge&quot;&gt;ret&lt;/code&gt; target prediction, which allows them to improve coverage and accuracy of pre-execution analyses. They use backwards slices at return instructions to determine whether a  &lt;code class=&quot;highlighter-rouge&quot;&gt;ret&lt;/code&gt; jumps to a function’s return address as expected or to another address, and falls back on dynamic analysis if static analysis fails.&lt;/p&gt;

&lt;h4 id=&quot;obfuscated-control-transfer-targets&quot;&gt;Obfuscated control-transfer targets&lt;/h4&gt;

&lt;p&gt;Using indirect versions of the &lt;code class=&quot;highlighter-rouge&quot;&gt;call&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;jmp&lt;/code&gt; instructions obfuscates control-transfer targets by using register or memory values to determine their targets at runtime. Furthermore, it provides some space savings, which is significant motivation for small packers. Obfuscation is also a considerable motivating factor as static analysis tools often let these jumps go unresolved. Single indirect jumps can have multiple targets as well over the course of an unpacker’s runtime lifetime.&lt;/p&gt;

&lt;p&gt;Static analysis of indirect control-transfer targets is particularly difficult in packed binaries, as they frequently use instructions whose targets depend on register values. Value-set analyses [Balakrishnan and Reps 2004] can theoretically reveal all possible targets for such indirect control-transfer instructions, but this requires knowing all the code in the binary, which is not a satisfiable condition in the realm of packed binaries. Dynamic analysis trivially discovers targets of indirect control transfers that execute, but may leave a significant fraction of code unexecuted. There has been research done on forcing program execution down multiple execution paths [Babic et. al. 2011; Moser et al. 2007] but these are extremely resource-intensive techniques and do not acheive perfect code coverage.&lt;/p&gt;

&lt;h4 id=&quot;exception-based-control-transfers&quot;&gt;Exception-based control transfers&lt;/h4&gt;
&lt;p&gt;Signal- and exception-handling mechanisms allow for the creation of obfuscated control transfers whose source instruction and target address are well-hidden from static analysis techniques. Statically identifying sources of control transfers such as these requires predicting which instructions will raise exceptions, which is difficult in theory and practice [Muth and Debray 2000]. This means current disassembly algorithms wil usually parse through fault-raising instructions into what may be non-code bytes that’ll never execute. Furthermore, at least on Windows, it is hard to find exception handlers, since they can be registered on the call stack at runtime with no need to perform any Windows API or system calls.&lt;/p&gt;

&lt;p&gt;Using a debugger is the easiest way to detect exception-based control transfers, as it informs the debugger process of any fault-raising instructions and identifies all registered exception handlers whenever a fault occurs. However, use of a debugger interface can be detectd unless extensive precautions are taken.&lt;/p&gt;

&lt;h4 id=&quot;ambiguous-code-and-data&quot;&gt;Ambiguous code and data&lt;/h4&gt;

&lt;p&gt;Yet another form of control flow obfuscation involves using conditional branches to introduce a fork in the program’s control flow with only one path that ever executes, while junk code (fake code bytes or non-code) populates the other path.&lt;/p&gt;

&lt;p&gt;Using current techniques, the only way to identify code with perfect exclusion of data is to disassemble only those instruction sthat appear in an execution trace of a program.&lt;/p&gt;

&lt;h4 id=&quot;disassembler-fuzz-testing&quot;&gt;Disassembler Fuzz Testing&lt;/h4&gt;
&lt;p&gt;Fuzz testing refers to the practice of stress testing a software component by feeding it large quantities of unusual inputs int eh hope of detecting a case that the component hadles incorrectly. By fuzz testing binary-code disassemblers, packer tools can cause the diassembler to misparse instructions or mistake valid instructions for invalid ones.&lt;/p&gt;</content><author><name></name></author><summary type="html">Abstract</summary></entry><entry><title type="html">Evading OllyDump’s ‘Find OEP by Section Hop’ feature</title><link href="http://localhost:4000/notes/2018/11/03/getting_around_section_hop.html" rel="alternate" type="text/html" title="Evading OllyDump's 'Find OEP by Section Hop' feature" /><published>2018-11-03T14:31:00-06:00</published><updated>2018-11-03T14:31:00-06:00</updated><id>http://localhost:4000/notes/2018/11/03/getting_around_section_hop</id><content type="html" xml:base="http://localhost:4000/notes/2018/11/03/getting_around_section_hop.html">&lt;h2 id=&quot;ollydump&quot;&gt;OllyDump&lt;/h2&gt;

&lt;p&gt;One of the best tools in the malware analyst’s toolbox is OllyDbg’s ‘OllyDump’ plugin. It sports the ability to dump a debugged program’s memory, meaning if you can unpack a packed executable up to the point in which it transfers execution to the malicious payload, OllyDump can write out that program to a file that you can further analyze. This point in execution is called the &lt;em&gt;original entry point&lt;/em&gt;, or OEP. The jump that the program makes from unpacking code to execution of the malicious payload is called the &lt;em&gt;tail jump&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&quot;finding-the-oep-by-section-hop&quot;&gt;Finding the OEP by section hop&lt;/h3&gt;
&lt;p&gt;Finding the OEP of a program isn’t always trivial. That’s why OllyDump provides two methods that can be used to help you. Labeled “Find OEP by Section Hop,” OllyDump creates a conditional breakpoint that monitors the section of the executable that is currently executing. When execution hops out of that section, the breakpoint triggers. Often times, the section will change when making the tail jump, since the malicious payload likely won’t be in the same section as the unpacker code. OllyDump has two versions of this functionality: a trace over feature and a trace into feature. From what I understand, the trace over feature won’t monitor section transfers within calls. For example, if the code you’re looking at calls a library function, the EIP will definitely be out of range of the current section, but Trace Over won’t trigger a break in execution. Trace into will, however. As such, Trace Into goes into more depth, but can also churn out more false positives. Trace Over goes into less depth, but is less likely to churn out false positives. Each is useful in certain situations. Sometimes using a combination of both is the best strategy. Sometimes, neither one will work well.&lt;/p&gt;

&lt;h3 id=&quot;evading-this-tool&quot;&gt;Evading this tool&lt;/h3&gt;
&lt;p&gt;So, how can malware nullify these tools? I can think of a couple ways:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;If the unpacking stub is contained within two or more sections and transfers execution between them frequently. Then, the section would change frequently, causing both versions of the section hop feature to trigger. Of course, this could be combatted by adding a multi-section conditional check, but I don’t believe this feature is currently available within OllyDump.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Self-modifying code/partially unpacking malware will cause problems. If the code only partially unpacks itself into memory, we may find the section in which it executes using OllyDump’s features, but we can’t dump the file into a complete executable at any given moment in time.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In order to further understand how to get around this technique, it will pay to read up on general obfuscation techniques. That will, in turn, lead me to theorize about which can be detected with OllyDbg and which can’t.&lt;/p&gt;

&lt;h3 id=&quot;details-on-how-a-few-common-packers-work-and-how-to-augment-ollydumps-find-oep-by-section-hop-functionality-to-be-able-to-handle-these-packers&quot;&gt;Details on how a few common packers work, and how to augment OllyDump’s “Find OEP by section hop” functionality to be able to handle these packers&lt;/h3&gt;

&lt;h4 id=&quot;fsg-fast-small-good&quot;&gt;FSG: FAst, Small, Good&lt;/h4&gt;

&lt;h4 id=&quot;upx-ultimate-packer-for-executables&quot;&gt;UPX: Ultimate Packer for eXecutables&lt;/h4&gt;

&lt;h4 id=&quot;upack&quot;&gt;UPack&lt;/h4&gt;

&lt;h4 id=&quot;polyene&quot;&gt;PolyEnE&lt;/h4&gt;

&lt;h4 id=&quot;mew&quot;&gt;MEW&lt;/h4&gt;

&lt;h4 id=&quot;pecompact&quot;&gt;PECompact&lt;/h4&gt;

&lt;h4 id=&quot;nspack&quot;&gt;NSPack&lt;/h4&gt;

&lt;h4 id=&quot;npack&quot;&gt;nPack&lt;/h4&gt;

&lt;h4 id=&quot;aspack&quot;&gt;ASPack&lt;/h4&gt;

&lt;h4 id=&quot;petite&quot;&gt;PEtite&lt;/h4&gt;

&lt;h4 id=&quot;yodas-protector&quot;&gt;Yoda’s Protector&lt;/h4&gt;

&lt;h4 id=&quot;asprotect&quot;&gt;ASProtect&lt;/h4&gt;</content><author><name></name></author><summary type="html">OllyDump</summary></entry><entry><title type="html">PMA Ch.18 Labs: Packed Malware</title><link href="http://localhost:4000/labs/2018/10/28/PMA_ch18_labs.html" rel="alternate" type="text/html" title="PMA Ch.18 Labs: Packed Malware" /><published>2018-10-28T12:31:00-06:00</published><updated>2018-10-28T12:31:00-06:00</updated><id>http://localhost:4000/labs/2018/10/28/PMA_ch18_labs</id><content type="html" xml:base="http://localhost:4000/labs/2018/10/28/PMA_ch18_labs.html">&lt;h2 id=&quot;lab-summary-questions&quot;&gt;Lab summary questions&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Considering malware analysis as a whole, how important is it to a general aspiring analyst to complete this chapter’s exercises?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What did doing the lab exercises teach that was not gained from reading the chapter?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;challenges-encountered-in-the-labs&quot;&gt;Challenges encountered in the labs&lt;/h2&gt;

&lt;h2 id=&quot;lab-walkthrough-includes-answers&quot;&gt;Lab Walkthrough (includes answers!)&lt;/h2&gt;

&lt;p&gt;The goal of each of these labs is to unpack the code for further analysis so that other static techniques can be used. Try to avoid using automated unpackers and use the skills taught in this chapter. Each lab is a packed version of a previous lab.&lt;/p&gt;

&lt;h3 id=&quot;181&quot;&gt;18.1&lt;/h3&gt;

&lt;p&gt;I opened the file in OllyDbg and Ida, and just tried OllyDump’s “Find OEP by section hop (trace over)” option. You can verify that the program is progressing by clicking in the registers window. If the registers update when you click, you know the plugin is working.&lt;/p&gt;

&lt;p&gt;After waiting about a minute, OllyDbg broke due to a conditional breakpoint: “EIP outside the range 407000…409FFF (i.e. a hop outside of that section). The code points directly to what looks like a function now located at 40154F.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/ch18sc/1_01unpacked.PNG&quot; alt=&quot;1_01unpacked.PNG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I used OllyDbg to dump the process (** plugins -&amp;gt; OllyDump -&amp;gt; Dump debugged process **) (no changes to the dump options screen) and loaded the new exe into Ida, and it appears to be a good-looking, unpacked sample.&lt;/p&gt;

&lt;h3 id=&quot;182&quot;&gt;18.2&lt;/h3&gt;

&lt;p&gt;Upon first opening this sample with Ida, we get a warning that said&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Truncated section &quot; at file offsets 0x1000..0x2000 
Will read 0x290 bytes
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;which I don’t understand, but that’s okay for now.&lt;/p&gt;

&lt;p&gt;Furthermore, when opening the file with OllyDbg, we get this message:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/ch18sc/2_02open.PNG&quot; alt=&quot;2_02open.PNG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Stepping through the code a few times yields a pretty obfuscated seeming loop pattern. I’m not sure what it’s doing or how it’s doing it, but the classic approach is to let Olly do that for you. So I did, and it broke here.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/ch18sc/3_wat.PNG&quot; alt=&quot;3_wat.PNG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This looks like data. Or perhaps it’s just in the data section of the executable. These are just bytes; let’s get Olly to interpret it as code: &lt;strong&gt;right click in the disassembly window -&amp;gt; analysis -&amp;gt; analyse code&lt;/strong&gt; and boom, there we are. A function.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/ch18sc/4_02unpacked.PNG&quot; alt=&quot;4_02unpacked.PNG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I dumped the program (default options) and opened the new executable in Ida, and it revealed something that looked similar to a ch7 sample analyzed earlier. Specifically the second lab.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/ch18sc/5_0702.PNG&quot; alt=&quot;5_0702.PNG&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;183&quot;&gt;18.3&lt;/h3&gt;

&lt;p&gt;I ran this file in OllyDbg and observed a pattern: it’s unpacking some code into another section, and then calling it, and that code unpacks some code into another section and then calls it, and etc. I bet this will mess with the &lt;code class=&quot;highlighter-rouge&quot;&gt;Find OEP by Section Hop&lt;/code&gt; functionality– at least the “step over” part, since calls don’t return to the right place (as that’s how it transfers execution– by pushing a new variable onto the stack and then calling a ‘ret’ (I believe)).&lt;/p&gt;

&lt;p&gt;Sections: 40Axxx, 407xxx, and some kernel calls. Arriving in these sections triggers OllyDump’s plugin to stop execution.&lt;/p&gt;

&lt;p&gt;And, after attempting to find the OEP by section hop, I discovered it does indeed render the technique much less helpful. I sort of stumbled through and kept trying it and it would run to the next point in the code that was out of the current section. Theoretically, I can keep doing this until I finally hit a breakpoint that doesn’t look like unpacking code, but I don’t know if this is the most helpful strategy. I continued trying to resume the code for a while (i.e. using OllyDump’s trace into feature and then OllyDbg’s execute until user code feature), and it beame clear to me that this strategy isn’t very feasible.&lt;/p&gt;

&lt;p&gt;I was hesitant to try the other “find section hop by jumping over” as I believe this code transfers execution by modifying where “ret” transfers execution to. In other words, we may have calls that never return to the instruction immediately after the call. Either way, I tried it, and it took me to a section that looks like data. I got Olly to treat it as code and disassemble it in the same way I did for the previous problem.&lt;/p&gt;

&lt;p&gt;As it turns out, this was indeed the entry point– 0x401577. I am wondering if using a combination of section jumps with trace over and with trace into is a viable strategy.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/ch18sc/6_ollyEntry3.PNG&quot; alt=&quot;6_ollyEntry3.PNG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Interestingly, after exporting the file with the EIP at this location, the imports section is still destroyed according to Ida, and furthermore, Ida’s disassembly code differs slightly (but makes more sense) than Olly’s.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/ch18sc/7_idaUnpacked3.PNG&quot; alt=&quot;7_idaUnpacked3.PNG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In either case, after looking around this file with Ida, it appears to look much more like non-unpacking code, which further confirms my suspicion that this is the payload we’re after.&lt;/p&gt;

&lt;h4 id=&quot;after-reading-the-book-answers&quot;&gt;After reading the book answers…&lt;/h4&gt;

&lt;p&gt;The book acknowledges a pushf and a pusha at the very, very beginning of the file. It suggests that a packer will likely have corresponding popa and popf instructions at the end of the unpacking loop, and suggests putting a breakpoint on access of that pushed memory. I tried this, and it worked great.&lt;/p&gt;</content><author><name></name></author><summary type="html">Lab summary questions Considering malware analysis as a whole, how important is it to a general aspiring analyst to complete this chapter’s exercises?</summary></entry><entry><title type="html">PMA Ch.18 Notes: Packers and Unpacking</title><link href="http://localhost:4000/notes/2018/10/15/ch18_PMA_notes.html" rel="alternate" type="text/html" title="PMA Ch.18 Notes: Packers and Unpacking" /><published>2018-10-15T14:31:00-06:00</published><updated>2018-10-15T14:31:00-06:00</updated><id>http://localhost:4000/notes/2018/10/15/ch18_PMA_notes</id><content type="html" xml:base="http://localhost:4000/notes/2018/10/15/ch18_PMA_notes.html">&lt;h2 id=&quot;chapter-summary-questions&quot;&gt;Chapter summary questions&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;In two sentences or less, provide an overview of what this chapter is about.&lt;/li&gt;
  &lt;li&gt;What are the three most important takeaways from this chapter?&lt;/li&gt;
  &lt;li&gt;What problems does this chapter address? In other words, why should we care about this chapter?&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;overview-of-how-packing-works&quot;&gt;Overview of how packing works&lt;/h2&gt;
&lt;p&gt;Packers generally follow the same pattern: they transform (compress, encrypt, etc) an executable into raw data. This is the act of packing. Packers then prepend a valid executable (called an unpacking stub) to that data. The unpacking stub exists to decrypt or decode or unzip the packed portion of the executable into memory at run time, and then transfer execution to the unpacked code. This is significant because it conceals the program’s instructions to static analysis tools (excluding the instructions of the unpacking stub).&lt;/p&gt;

&lt;p&gt;To maintain the functionality of the original program, a packing program needs to store the program’s import information. The information can be stored in any format, and there are several common strategies which will be discussed later.&lt;/p&gt;

&lt;p&gt;Packers can pack the entire executable, including all data and the resource section, or they can pack only the code and data sections.&lt;/p&gt;

&lt;h2 id=&quot;the-unpacking-stub&quot;&gt;The Unpacking Stub&lt;/h2&gt;
&lt;p&gt;The purpose of the unpacking stub is typically to load the packed packed program, unpack it, resolve imports of the original executable, and transfer execution to the original entry point. It need not unpack the entire executable at any given point in time. Understanding how the stub works is almost always crucial to understanding the malware.&lt;/p&gt;

&lt;h2 id=&quot;resolving-imports&quot;&gt;Resolving imports&lt;/h2&gt;
&lt;p&gt;Because the Windows loader cannot read import information that is packed, the unpacking stub must resolve the imports. There are a few approaches that can be taken to do this.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Most common: have the unpacking stub import &lt;code class=&quot;highlighter-rouge&quot;&gt;LoadLibrary&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;GetProcAddress&lt;/code&gt; functions. After the unpacking stub unpacks the original executable, it reads the original import information, uses &lt;code class=&quot;highlighter-rouge&quot;&gt;LoadLibrary&lt;/code&gt; to load those libraries, and uses &lt;code class=&quot;highlighter-rouge&quot;&gt;GetProcAddress&lt;/code&gt; to get the address for functions in each library.&lt;/li&gt;
  &lt;li&gt;Another approach: Keep the imports table intact.&lt;/li&gt;
  &lt;li&gt;A third approach: keep one import function from each DLL in the original import table. In this case, &lt;code class=&quot;highlighter-rouge&quot;&gt;LoadLibrary&lt;/code&gt; will not be needed, but the stub will still need to resolve the other functions.&lt;/li&gt;
  &lt;li&gt;The final discussed approach is to remove all imports including &lt;code class=&quot;highlighter-rouge&quot;&gt;LoadLibrary&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;GetProcAddress&lt;/code&gt;. Then, the packer must find all functions needed from other libraries without using those functions, or it must find &lt;code class=&quot;highlighter-rouge&quot;&gt;LoadLibrary&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;GetProcAddress&lt;/code&gt; and then use them to load other libraries. This is the stealthiest method, but also the most difficult to implement.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;recognizing-packed-programs&quot;&gt;Recognizing packed programs&lt;/h2&gt;
&lt;p&gt;There are often giveaways that are indicative of a packed program.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;One sign is a program has few imports, and those imports are often just &lt;code class=&quot;highlighter-rouge&quot;&gt;LoadLibrary&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;GetProcAddress&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;When the program is opened in IDA, only a small amount of code is recognized by the automatic analysis.&lt;/li&gt;
  &lt;li&gt;When the program is opened in OllyDbg, there is a warning that the program is packed.
    &lt;ul&gt;
      &lt;li&gt;How does OllyDbg identify this? Do we even care in 64-bit land?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;The program shows section names that indicate a particular packer
    &lt;ul&gt;
      &lt;li&gt;What are section names typically for executables?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;the program has abnormal section sizes, such as a &lt;code class=&quot;highlighter-rouge&quot;&gt;.text&lt;/code&gt; section that has a raw size of 0 but a virtual size of nonzero.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;entropy-calculation&quot;&gt;Entropy Calculation&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;Entropy Calculation&lt;/em&gt; is a technique where packed executables can be detected based on the randomness of the executable. Encrypted or otherwise packed programs usually have high entropy.&lt;/p&gt;

&lt;h2 id=&quot;unpacking-executables&quot;&gt;Unpacking executables&lt;/h2&gt;
&lt;p&gt;Three options:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Automated static unpacking.&lt;/li&gt;
  &lt;li&gt;Automated dynamic unpacking.&lt;/li&gt;
  &lt;li&gt;Manual dynamic unpacking.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Manual static unpacking is completely infeasible.&lt;/p&gt;

&lt;h3 id=&quot;automated-static-unpacking&quot;&gt;Automated static unpacking&lt;/h3&gt;
&lt;p&gt;This is generally the best and fastest method, when it works, because it unpacks a program but does not run the unpacked program. Programs that perform automated static unpacking generally only work for one type of packer.&lt;/p&gt;

&lt;h3 id=&quot;automated-dynamic-unpacking&quot;&gt;Automated dynamic unpacking&lt;/h3&gt;
&lt;p&gt;These run the packed program and allow the unpacking stub to unpack the original executable code. Once the unpacking stub finishes, it writes the unpacked program to disk, and the unpacker reconstructs the import table.&lt;/p&gt;

&lt;p&gt;The unpacking program must determine where the unpacking stub ends and where the original executable begins, which is difficult.&lt;/p&gt;

&lt;p&gt;As of the time of this book’s writing, “there are no good publicly available automated dynamic unpackers.”&lt;/p&gt;

&lt;h3 id=&quot;manual-unpacking&quot;&gt;Manual unpacking&lt;/h3&gt;
&lt;p&gt;There are two common approaches to manually unpacking a program.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Discover the packing algorithm and write a program to run it in reverse. This is generally less efficient, but may be useful if dealing with many different executables that are packed in the same manner.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Run the packed program up to the point where the unpacking stub finishes and does the work for you, and then dump the process out of memory and manually fix up the PE header so that the program is complete.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;a-walkthrough-of-the-manual-unpacking-process-for-ideal-packed-executables&quot;&gt;A walkthrough of the manual unpacking process for ideal packed executables&lt;/h4&gt;

&lt;p&gt;The first step is to use the following workflow to see if OllyDbg’s OllyDump plugin can unpack the executable for you. To begin, open the packed program with OllyDbg.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Select &lt;strong&gt;Plugins -&amp;gt; OllyDump -&amp;gt; Find OEP by Section Hop&lt;/strong&gt;. Olly will hit a breakpoint just before the OEP executes. (It’s sort of slow to run, mind you!)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Write down where OllyDbg broke. This is the OEP.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Select &lt;strong&gt;Plugins -&amp;gt; OllyDump -&amp;gt; Dump Debugged Process.&lt;/strong&gt; This dumps everything from process memory to disk.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;using-import-reconstructor&quot;&gt;Using Import Reconstructor&lt;/h4&gt;

&lt;p&gt;If OllyDbg fails, you can try to use Import Reconstructor (ImpRec) to repair the import table for packed programs.In this case, see p390 for more details.&lt;/p&gt;

&lt;h4 id=&quot;how-ollydumps-find-oep-by-section-hop-tool-works&quot;&gt;How OllyDump’s Find OEP by Section Hop tool works&lt;/h4&gt;

&lt;p&gt;Normally, the unpacking stub is in one section and the executable is packed in another section. OllyDbg detects whenthere is a transfer from one section to another and breaks there, using either the step-over or step-into method.&lt;/p&gt;

&lt;p&gt;The step-over method will step over any &lt;code class=&quot;highlighter-rouge&quot;&gt;call&lt;/code&gt; instruction. Calls are often used to execute code in another section, and this method is designed to prevent OllyDbg from incorrectly labeling one of those calls as the OEP. But, if a call never returns, of course OllyDbg won’t locate the OEP.&lt;/p&gt;

&lt;p&gt;The step-into method will step into calls, but it might provide false positives as well.&lt;/p&gt;

&lt;h4 id=&quot;things-to-look-for-when-manually-finding-the-oep&quot;&gt;Things to look for when manually finding the OEP&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Jumps outside of a section&lt;/li&gt;
  &lt;li&gt;Jumps that are followed by a bunch of invalid code&lt;/li&gt;
  &lt;li&gt;Jumps that are unreasonably far away&lt;/li&gt;
  &lt;li&gt;Jumps immediately followed by classic function boiler plate code (&lt;code class=&quot;highlighter-rouge&quot;&gt;push ebp, mov ebp, esp&lt;/code&gt; for example)
:&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;terminology&quot;&gt;Terminology&lt;/h2&gt;

&lt;h2 id=&quot;page-to-page-notes&quot;&gt;Page-to-page notes&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;here
    &lt;ul&gt;
      &lt;li&gt;here&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;tools-discussed-in-this-section&quot;&gt;Tools discussed in this section&lt;/h2&gt;
&lt;p&gt;here&lt;/p&gt;

&lt;h2 id=&quot;questions-encountered-and-answers-if-found&quot;&gt;Questions encountered (and answers, if found)&lt;/h2&gt;
&lt;p&gt;here&lt;/p&gt;</content><author><name></name></author><summary type="html">Chapter summary questions In two sentences or less, provide an overview of what this chapter is about. What are the three most important takeaways from this chapter? What problems does this chapter address? In other words, why should we care about this chapter?</summary></entry><entry><title type="html">PMA Ch9 Lab: Using OllyDbg</title><link href="http://localhost:4000/labs/2018/10/12/PMA_ch9_labs.html" rel="alternate" type="text/html" title="PMA Ch9 Lab: Using OllyDbg" /><published>2018-10-12T16:28:00-06:00</published><updated>2018-10-12T16:28:00-06:00</updated><id>http://localhost:4000/labs/2018/10/12/PMA_ch9_labs</id><content type="html" xml:base="http://localhost:4000/labs/2018/10/12/PMA_ch9_labs.html">&lt;h2 id=&quot;lab-summary-questions&quot;&gt;Lab summary questions&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Considering malware analysis as a whole, how important is it to a general aspiring analyst to complete this chapter’s exercises?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What did doing the lab exercises teach that was not gained from reading the chapter?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;challenges-encountered-in-the-labs&quot;&gt;Challenges encountered in the labs&lt;/h2&gt;

&lt;h2 id=&quot;lab-walkthrough-includes-answers&quot;&gt;Lab Walkthrough (includes answers!)&lt;/h2&gt;

&lt;h3 id=&quot;91&quot;&gt;9.1&lt;/h3&gt;

&lt;p&gt;Analyze the malware found in Lab09-01.exe using OllyDbg and IDA Pro to answer the following questions. Note that this malware was initially analyzed in the Chapter 3 labs using basic static and dynamic techniques. (Uh oh…)&lt;/p&gt;

&lt;h4 id=&quot;questions-to-answer&quot;&gt;Questions to answer&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;How can you get this malware to install itself?&lt;/p&gt;

    &lt;p&gt;One way (of at least two) is to call it as such: &lt;code class=&quot;highlighter-rouge&quot;&gt;./Lab09-01.exe -in abcd&lt;/code&gt; (90% confidence)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What are the command-line options for the program? What is the password requirement?&lt;/p&gt;

    &lt;p&gt;The last command-line argument of the program is the password. The password must be ‘abcd’.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How can you use OllyDbg to permanently patch this malware, so it doesn’t require the special command-line password?&lt;/p&gt;

    &lt;p&gt;Simply overwrite the function call to the password checking program with NOPs.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What are the host-based indicators of this program?&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;A service called “ Manager Service”.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What are the different actions this malware can be instructed to take via the network?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Are there any useful network-based signatures for this malware?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;walkthrough-process&quot;&gt;Walkthrough process&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: Before running this program or beginning to analyze it with Ida or OllyDbg, I recommend making a couple copies of it for backup purposes.&lt;/p&gt;

&lt;p&gt;First, I opened the files in OllyDbg and Ida. I looked through main() on Ida to see what sorts of things we could expect to see, and did a little bit of initial commenting.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/ch9sc/01_startup.PNG&quot; alt=&quot;01_initial.PNG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I opened up sub_402510 to discover a big mess of movs and some repne scasbs and other things. After putting about 5 minutes of effort into trying to understand how all this worked, I realized it would be a lot brighter to, you know, use the tool I just learned about. I migrated over to Olly with the mindset that I wanted to watch how sub_402510 works, since I believe this function is what determines if the malware will install, or delete itself.&lt;/p&gt;

&lt;p&gt;Upon first looking at this new tool’s interface, I noticed OllyDbg broke at _start, while Ida starts up at main(). So, I stepped through code in Olly until I hit where main was called. As I walked through code and matched where Olly was vs. where we were in Ida, I discovered/confirmed:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl + g&lt;/code&gt; is how you do goto address in OllyDbg&lt;/li&gt;
  &lt;li&gt;Return back after going somewhere by using &lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;. It doesn’t necessarily go “back” mind you… but that hasn’t gotten in the way enough for me to put time into it, yet.&lt;/li&gt;
  &lt;li&gt;Place a breakpoint by hitting F2.&lt;/li&gt;
  &lt;li&gt;To change the contents of some registers, you just right click it and choose the appropriate option. EIP doesn’t follow this convention. To change EIP, you must goto the location you want EIP to execute next, right click it, and choose &lt;strong&gt;New Origin Here&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;To rename a memory label in Olly (such as for a call instruction), goto that address and then right click the first instruction at that address and type “:” or right-click the address and click &lt;strong&gt;label&lt;/strong&gt;, and type the new name. This will have all references to that address propogate with the new name. In this way, I made the functions I named in Ida have the same names in Olly, which is very helpful when I’m switching between both programs so much.&lt;/li&gt;
  &lt;li&gt;Double clicking an address will make all addresses around it appear with numbers relative to the one you clicked. This can be helpful for finding out how far away two instructions or bits of data in memory are.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the first run of this program where there are no command line arguments, the argument passed to sub_402510 is the program’s path.&lt;/p&gt;

&lt;p&gt;Let’s look into the function that processes the last command line argument.&lt;/p&gt;

&lt;h4 id=&quot;is-this-the-password-checking-function&quot;&gt;Is this the password checking function?&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/files/ch9sc/02_processArgvLast.PNG&quot; alt=&quot;processArgvLast&quot; /&gt;&lt;/p&gt;

&lt;p&gt;It contains a &lt;code class=&quot;highlighter-rouge&quot;&gt;repne scasb&lt;/code&gt; instruction. This instruction is not something I know off the top of my head, so I checked out a &lt;a href=&quot;https://reverseengineering.stackexchange.com/questions/2774/what-does-the-assembly-instruction-repne-scas-byte-ptr-esedi&quot;&gt;post on the reverse engineering stackexchange&lt;/a&gt; that explains how the command breaks down.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;repne: repeat while not equal.&lt;/li&gt;
  &lt;li&gt;scas: SCan A String. It compares values in a string (the one pointed to by the ES:[EDI] register) to the value in the accumulator register (&lt;code class=&quot;highlighter-rouge&quot;&gt;EAX&lt;/code&gt;) until it finds a match.
    &lt;ul&gt;
      &lt;li&gt;ES: a segment register. These are used to derive memory addresses. How? I’m not sure, and I am not sure it matters for purposes of this assignment yet. WEEDS&lt;/li&gt;
      &lt;li&gt;EDI: contains a pointer to the string. Why yes, OllyDbg is indeed reporting that the string is in EDI!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Overall, it scans the string until it finds an element in it equal to the element in the accumulator. So, in this case, since EAX is 0, it’s looking for the null terminator.&lt;/p&gt;

&lt;p&gt;Hitting F7 (i.e. step into) shows how the string in EDI shrinks one by one from the left side, and each time that happens, ECX is decremented. (ECX was 0xFFFFFFFF at the beginning). (Just to be clear, it’s not that the string is “shrinking”… We are just changing the pointer in EDI to look one character ahead, and that is what gives the illusion that the string is shrinking.)&lt;/p&gt;

&lt;p&gt;ECX is manipulated to contain the string length!&lt;/p&gt;

&lt;p&gt;Moving on, we see that a comparison of the string length to 4 happens. Since the string length is not 4, it leaves the function. Clearly, it’s looking for something that is a 4 character argument. I reran the program with the argument “asdf” by clicking Olly’s black X in the top left corner, opening a file, and putting “asdf” in the arguments field, and then I stepped through until at the same block of code discussed right above.&lt;/p&gt;

&lt;p&gt;CL, the lower byte of ECX, had moved into it the first letter of the argument being processed by this function. That was then moved into var_4. So, what Ida labeled as var_4 is actually the first character of the command line parameter.  We can tell by reading the assembly in Ida that a comparison of 61 (hex) happens shortly after, and the code leaves if it detects the comparison is not equal. 61 is an ‘a’ in ascii. How convenient. The first guess takes us to step 2 of the checking process.&lt;/p&gt;

&lt;p&gt;Step two (starting at memory location 402563) threw me off for a little, until I just ran it in Olly and observed what happened.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/ch9sc/03_step2.PNG&quot; alt=&quot;step2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;It did a bunch of pointer math, and compared to 1 shortly after. Instead of spending too much time trying to know exactly what the assembly was doing, I just ran the code up to 0x40255A, and discovered that with “asdf”, the value resulting in ECX after the pointer math occurs was 0x12. I also noticed that 0x12 is just about the value that results if you subtract the second character of my current password from the first– s - a = 12. So, this step checks to see if the second character is one more than the first– i.e. ‘b’. So I reran the code with the password ‘abcd’.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/ch9sc/04_step3and4.PNG&quot; alt=&quot;step3and4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Step three employs more strange pointer math. We’ll notice that, however, at 0x402566, 63h (i.e. ‘c’) is moved into dl. After skipping past all but one of the movs, we see an &lt;code class=&quot;highlighter-rouge&quot;&gt;[ecx + 2]&lt;/code&gt; is part of the final mov. This is probably somehow referencing the third char of our string (the second, if we refer to the characters in a zero-indexed fashion). Either way, 0x63 is compared to 0x63 with my password of ‘abcd’, and the code moves on to check four.&lt;/p&gt;

&lt;p&gt;Step 4 takes the current char ‘c’ and adds 1 to it. That makes a ‘d’! Stepping through yields a comparison of ‘d’ to ‘d’, and we know that the password is now ‘abcd’ as a 1 is put into eax and we return.&lt;/p&gt;

&lt;h4 id=&quot;we-have-the-password-but-how-can-we-patch-the-program-to-not-require-one-at-all-question-3&quot;&gt;We have the password, but how can we patch the program to not require one at all (question 3)?&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/files/ch9sc/05_prePatchingObservation.PNG&quot; alt=&quot;prePatchingObservation&quot; /&gt;&lt;/p&gt;

&lt;p&gt;If the password checking function runs successfully, it puts the value ‘1’ into EAX. Otherwise, it zeroes EAX. The &lt;code class=&quot;highlighter-rouge&quot;&gt;test&lt;/code&gt; instruction combined with a &lt;code class=&quot;highlighter-rouge&quot;&gt;jnz&lt;/code&gt; instruction effectively tests to see if what’s in EAX is zero. If we just … didn’t call that function, EAX would contain a nonzero value from the &lt;code class=&quot;highlighter-rouge&quot;&gt;mov&lt;/code&gt; at address 0x402B2A, and the &lt;code class=&quot;highlighter-rouge&quot;&gt;jnz&lt;/code&gt; jump would be taken. All we need to do is &lt;code class=&quot;highlighter-rouge&quot;&gt;nop&lt;/code&gt; out the call, and the code will always take the jnz branch to the next phase of the malware.&lt;/p&gt;

&lt;p&gt;The book specifically has a section on how to do this (see the patching section in my previous notes post). I right clicked the call instruction of the password checking function in Olly, and selected &lt;strong&gt;Binary -&amp;gt; Edit&lt;/strong&gt;. Now Olly displays the updated code in the disassembler. I then saved this patched version of the program.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/ch9sc/06_patched.PNG&quot; alt=&quot;patched&quot; /&gt;&lt;/p&gt;

&lt;p&gt;HA. Sick. It works.&lt;/p&gt;

&lt;h4 id=&quot;getting-the-malware-to-install-itself&quot;&gt;Getting the malware to install itself&lt;/h4&gt;

&lt;p&gt;To answer this question, I took a shot in the dark and assumed installing itself involved creating a service. I looked through the strings within Ida and found one, “ Manager Service”. Cross-referencing that leads to one use: within sub_402600. This function also does stuff with the registry. If we cross-reference this, we find that it’s used in two places.&lt;/p&gt;

&lt;p&gt;My next observation came from this block of code here.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/ch9sc/07.PNG&quot; alt=&quot;07&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We see that it’s doing a string comparison after it passes the password check function. OllyDbg tells us that the comparison is done with the “-in” hardcoded string, and we can observe it’s comparing one of the command line arguments. Furthermore, if strcmp finds that two strings are the same, it returns 0. So, the &lt;code class=&quot;highlighter-rouge&quot;&gt;jnz&lt;/code&gt; will NOT be taken if the comparison results in finding a “-in” argument.&lt;/p&gt;

&lt;p&gt;The red branch checks to see if there are a total of three arguments (say, perhaps, the program name, -in, and the password). If there are, the &lt;code class=&quot;highlighter-rouge&quot;&gt;jnz&lt;/code&gt; is again not taken due to the nature of how &lt;code class=&quot;highlighter-rouge&quot;&gt;cmp&lt;/code&gt; works. If we follow that red path, we arrive at…&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/ch9sc/08.PNG&quot; alt=&quot;08&quot; /&gt;&lt;/p&gt;

&lt;p&gt;…a block of code that much closer to the install function. At this point, I think it’s safe to say one way to get this malware to install itself is by calling it as such:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;./lab09-01.exe -in asdf&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;realizations-made-after-reading-the-book-answers&quot;&gt;Realizations made after reading the book answers:&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;here&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;92&quot;&gt;9.2&lt;/h3&gt;

&lt;p&gt;Analyze the malware using OllyDbg.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;What strings do you see statically in the binary?&lt;/p&gt;

    &lt;p&gt;Answer here&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What happens when you run the binary?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How can you get this sample to run its malicious payload?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What’s happening at 0x401133?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What arguments are being passed to subroutine 0x401089?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What domain name does this malware use?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What encoding routine is being used to obfuscate the domain name?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What is the significance of the &lt;code class=&quot;highlighter-rouge&quot;&gt;CreateProcessA&lt;/code&gt; call at 0x40106E?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;realizations-made-after-reading-the-book-answers-1&quot;&gt;Realizations made after reading the book answers:&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;here&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;93&quot;&gt;9.3&lt;/h3&gt;

&lt;p&gt;Analyze the malware found in Lab09-03.exe using OllyDbg and Ida. The malware loads three included DLLs that are built to request the same memory load location, which means Ida will show differing memory addresses than Olly when loaded in each. This is done by design to give you experience going from Ida to Olly and back, when the addresses differ.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;What DLLs are imported by Lab09-03.exe?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What is the base address requested by DLL1.dll, DLL2.dll, and DLL3.dll?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;When you use OllyDbg to debug Lab09-03.exe, what is the assigned base address for all three DLL files?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;When Lab09-03.exe calls an import function from DLL1.dll, what does this import function do?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;When the exe calls WriteFile, what is the filename it writes to?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;When the exe creates a job using NetScheduleJobAdd, where does it get the data for the second parameter?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;While running or debugging th eprogram, you’ll see it prints out three piees of mystery data, one of each corresponding to each DLL. What are these pieces of mystery data?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How can you load DLL2.dll into Ida so that it matches the load address used by OllyDbg?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><summary type="html">Lab summary questions Considering malware analysis as a whole, how important is it to a general aspiring analyst to complete this chapter’s exercises?</summary></entry><entry><title type="html">PMA Ch.9 Notes: OllyDbg</title><link href="http://localhost:4000/notes/2018/10/12/ch9_PMA_notes.html" rel="alternate" type="text/html" title="PMA Ch.9 Notes: OllyDbg" /><published>2018-10-12T14:31:00-06:00</published><updated>2018-10-12T14:31:00-06:00</updated><id>http://localhost:4000/notes/2018/10/12/ch9_PMA_notes</id><content type="html" xml:base="http://localhost:4000/notes/2018/10/12/ch9_PMA_notes.html">&lt;h2 id=&quot;chapter-summary-questions&quot;&gt;Chapter summary questions&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;In two sentences or less, provide an overview of what this chapter is about.&lt;/p&gt;

    &lt;p&gt;This chapter covers how to use many features that OllyDbg provides.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What are the three most important takeaways from this chapter?&lt;/p&gt;

    &lt;p&gt;For this chapter, it’s hard to choose three &lt;em&gt;most&lt;/em&gt; important takeaways, simply because all the information inside the chapter is helpful in some form of malware analysis scenario.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What problems does this chapter address? In other words, why should we care about this chapter?&lt;/p&gt;

    &lt;p&gt;We should care about this chapter as it gives us the introducton to one of the most powerful and popular tools in the malware analyst’s toolbox.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;using-ollydbg&quot;&gt;Using OllyDbg&lt;/h2&gt;

&lt;h3 id=&quot;opening-a-file&quot;&gt;Opening a file&lt;/h3&gt;
&lt;p&gt;EZ. &lt;strong&gt;File -&amp;gt; open.&lt;/strong&gt; The only time in which you can pass in command line arguments is at this time.&lt;/p&gt;

&lt;p&gt;You can also attach OllyDbg to a running process using &lt;strong&gt;File -&amp;gt; attach&lt;/strong&gt;. When you do this, OllyDbg will foist itself upon the running process and break all threads. It’ll display the current executing thread’s code. This may be windows API code, so you should have the program break upon access to the entire code section.&lt;/p&gt;

&lt;h3 id=&quot;understanding-ollys-gui&quot;&gt;Understanding Olly’s GUI&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/files/ch9sc/n1.PNG&quot; alt=&quot;n1.PNG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Upon opening a program with OllyDbg (in my case, Lab09-01.exe), we have four different windows.&lt;/p&gt;

&lt;h4 id=&quot;top-left-the-disassembler-window&quot;&gt;Top left: the disassembler window&lt;/h4&gt;
&lt;p&gt;This is the disassember window. It shows the debugged program’s code– the current instruction pointer with several instructions before and after it. To modify instructions or data (or add new instructions), press spacebar within this window.&lt;/p&gt;

&lt;h4 id=&quot;top-right-registers-window&quot;&gt;Top right: registers window&lt;/h4&gt;
&lt;p&gt;You guessed it– it shows registers. They will change color as the program executes. Red is to highlight a recently changed value. You can right click any register value and select &lt;strong&gt;modify&lt;/strong&gt; to change any register value.&lt;/p&gt;

&lt;h4 id=&quot;bottom-right-stack-window&quot;&gt;Bottom right: stack window&lt;/h4&gt;
&lt;p&gt;This shows the stack of the program. It’ll always show the top of the stack for a given thread. You can manipulate it in the same way as you can manipulate registers– right clicking a spot on the stack and selecting &lt;strong&gt;modify&lt;/strong&gt;.&lt;/p&gt;

&lt;h4 id=&quot;bottom-left-memory-dump-window&quot;&gt;Bottom left: memory dump window&lt;/h4&gt;
&lt;p&gt;This window shows a dump of live memory for the debugged process. Pressing &lt;strong&gt;ctrl+G&lt;/strong&gt; in this window permits you to go to a specific spot in memory. Clicking a memory address and selecting &lt;strong&gt;Follow in Dump&lt;/strong&gt; permits you to dump tha tmemory address.&lt;/p&gt;

&lt;p&gt;You can edit memory in this window, too. Right click some memory and choose &lt;strong&gt;Binary -&amp;gt; edit&lt;/strong&gt; to do so. This can be used to modify global variables and other data that malware stores in RAM.&lt;/p&gt;

&lt;h3 id=&quot;executing-code&quot;&gt;Executing code&lt;/h3&gt;

&lt;p&gt;See page 186 for a nice table on the hotkeys used to execute code. There are a few notable features worth mentioning:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;When paused within library code, do a &lt;strong&gt;Debug -&amp;gt; Execute until User Code&lt;/strong&gt; to run until you’re no longer in the library.&lt;/li&gt;
  &lt;li&gt;Step-into: F7.&lt;/li&gt;
  &lt;li&gt;Step-over: F8&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;breakpoints&quot;&gt;Breakpoints&lt;/h4&gt;

&lt;p&gt;You can add or remove a breakpoin tby selecting the instruction in the disassembler window and pressing F2. You can view active breakpoints by selecting ** View -&amp;gt; Breakpoints** or clicking the B icon in the toolbar.&lt;/p&gt;

&lt;p&gt;You can generally select what breakpoints you want to use by right-clicking and going from &lt;strong&gt;Breakpoint -&amp;gt; [breakpoint type here]&lt;/strong&gt;. There are hotkeys for some of these too– see p188.&lt;/p&gt;

&lt;h3 id=&quot;buttons-and-other-windows&quot;&gt;Buttons and other windows&lt;/h3&gt;

&lt;h4 id=&quot;memory-map-window-m&quot;&gt;Memory map window (M)&lt;/h4&gt;
&lt;p&gt;Click the M box or click &lt;strong&gt;View -&amp;gt; Memory&lt;/strong&gt; to display all memory blocks allocated by the debugged program. This is a great way to see how a program is laid out in memory. All DLLs and their code sections are also visible. You cna double-click any row in the memory map to show a memory dump of that section, or you can send the data in a memory dump to the disassembler window by right-clicking and selecting &lt;strong&gt;View in Disassembler.&lt;/strong&gt; &lt;strong&gt;This seems very helpful for obfuscated malware.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;dlls&quot;&gt;DLLs&lt;/h3&gt;
&lt;p&gt;OllyDbg can debug DLL files. Since DLLs cannot be executed directly, OllyDbg uses a dummy program called &lt;em&gt;loaddll.exe&lt;/em&gt; to load them. By default, OllyDbg breaks at the DLL entry point (dllmain) when the DLL is loaded.&lt;/p&gt;

&lt;p&gt;To call exported functions with arguments inside the debugged DLL:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Load the DLL&lt;/li&gt;
  &lt;li&gt;Click the play button to run &lt;code class=&quot;highlighter-rouge&quot;&gt;DllMain&lt;/code&gt; and any other intialization code the DLL requires&lt;/li&gt;
  &lt;li&gt;Olly will pause, and you can call specific exports with arguments and debug them by selecting &lt;strong&gt;Debug -&amp;gt; Call DLL Export&lt;/strong&gt; from the main menu. (See an example of this on p191/p192.)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;tracing&quot;&gt;Tracing&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Tracing&lt;/strong&gt; is a powerful debugging technique that records detailed execution information for you to examine.&lt;/p&gt;

&lt;h4 id=&quot;standard-back-trace&quot;&gt;Standard Back Trace&lt;/h4&gt;
&lt;p&gt;Whenever you’re moving through the disassembler window with the Step Into and Step Over functions, OllyDbg is recording the movement. You can use the minus key on the keyboard to move back in time and see the instructions previously executed. The plus key takes you forward.&lt;/p&gt;

&lt;h4 id=&quot;call-stack&quot;&gt;Call Stack&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;View -&amp;gt; Call Stack&lt;/strong&gt; will allow you to view the call stack. Imagine that.&lt;/p&gt;

&lt;p&gt;To walk the call stack, click the Address or Called From sections of the call stack window. The registers and stack will not show you what was going on when in that location, unless you are performing a run trace.&lt;/p&gt;

&lt;h4 id=&quot;run-trace&quot;&gt;Run Trace&lt;/h4&gt;
&lt;p&gt;A &lt;strong&gt;run trace&lt;/strong&gt; allows you to execute code and have OllyDbg save every executed instruction and all changes made to the registers and flags.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Highlight code you wish to trace. Select &lt;strong&gt;Run Trace -&amp;gt; Add Selection&lt;/strong&gt;. After, choose &lt;strong&gt;View -&amp;gt; Run Trace&lt;/strong&gt; to see the instructions. Use the + and - keys as discussed above to run through the trace.&lt;/li&gt;
  &lt;li&gt;You can also use the &lt;strong&gt;Trace Into&lt;/strong&gt; and &lt;strong&gt;Trace Over&lt;/strong&gt; options. These will simply trace until a breakpoint is hit.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;patching&quot;&gt;Patching&lt;/h3&gt;
&lt;p&gt;You can modify instructions or memory by highlighting a region, right-clicking the region, and selecting &lt;strong&gt;Binary -&amp;gt; Edit&lt;/strong&gt;. This just changes the live memory; to take patching a step further and saving the on-disk executable, right click the disassembler window wher eyou patched the code and select &lt;strong&gt;Copy to Executable-&amp;gt;All Modifications&lt;/strong&gt;, and then select &lt;strong&gt;Save file&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&quot;analyzing-shellcode-or-other-random-instructions&quot;&gt;Analyzing shellcode (or other random instructions)&lt;/h3&gt;

&lt;p&gt;See the step by step process on p196. All I would do in these notes is copy that ordered list of instructions, more or less otherwise.&lt;/p&gt;

&lt;h2 id=&quot;rebasing&quot;&gt;Rebasing&lt;/h2&gt;
&lt;p&gt;This occurs when a module in Windows is not loaded at its preferred &lt;em&gt;base address.&lt;/em&gt; All PE files in Windows have a preferred base address, known as the &lt;em&gt;image base&lt;/em&gt; defined in the PE header. Most executables are designed to be loaded at &lt;code class=&quot;highlighter-rouge&quot;&gt;0x400000&lt;/code&gt;, which is probably why so many variables and functions in Ida are named using 0x400000 or some close number in some fashion.&lt;/p&gt;

&lt;p&gt;Of course, this is a preferred address, but it doesn’t guarantee a program will be loaded there. For example, if a program has two DLLs and they each have the same base address, they can’t both be loaded at the same address.&lt;/p&gt;

&lt;p&gt;Some instructions rely on the data being loaded at a specifc address, such as this instruction:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mov eax, dword__40CF60&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;That won’t work if the DLL with that instruction isn’t loaded in the right spot due to the use of an absolute address. Most DLLs come packaged with a list of fix-up locations in the &lt;code class=&quot;highlighter-rouge&quot;&gt;.reloc&lt;/code&gt; section of the PE header.&lt;/p&gt;

&lt;p&gt;DLLs are loaded after the .exe and are loaded in any order, meaning you can’t generally predict where DLLs will be located in memory if they’re rebased. If a DLL lacking a relocation section can’t be loaded at its preferred base address, then it cannot be loaded.&lt;/p&gt;

&lt;h2 id=&quot;wrapping-up&quot;&gt;Wrapping up&lt;/h2&gt;

&lt;p&gt;Assistance features– p197&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Logging&lt;/li&gt;
  &lt;li&gt;Watches window (i.e. watching when certain things change)&lt;/li&gt;
  &lt;li&gt;Help&lt;/li&gt;
  &lt;li&gt;Labelling
    &lt;ul&gt;
      &lt;li&gt;right click an address and select &lt;strong&gt;Label&lt;/strong&gt; which will prop up a window, promting for a label name. Works like in Ida.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;How to use plugins– p197&lt;/p&gt;

&lt;p&gt;Scriptable debugging – using Python to do plugins.&lt;/p&gt;</content><author><name></name></author><summary type="html">Chapter summary questions In two sentences or less, provide an overview of what this chapter is about.</summary></entry><entry><title type="html">PMA Ch8 Notes: Debuggers</title><link href="http://localhost:4000/notes/2018/10/07/PMA_ch8_notes.html" rel="alternate" type="text/html" title="PMA Ch8 Notes: Debuggers" /><published>2018-10-07T12:02:00-06:00</published><updated>2018-10-07T12:02:00-06:00</updated><id>http://localhost:4000/notes/2018/10/07/PMA_ch8_notes</id><content type="html" xml:base="http://localhost:4000/notes/2018/10/07/PMA_ch8_notes.html">&lt;h2 id=&quot;chapter-summary-questions&quot;&gt;Chapter summary questions&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;In two sentences or less, provide an overview of what this chapter is about.&lt;/p&gt;

    &lt;p&gt;This chapter provides an overview of what debuggers are, what breakpoints are and how they work, and what exceptions are. They cover just the conceptual topics of debuggers, meaning no technical information is provided.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What are the three most important takeaways from this chapter?&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;There are several types of breakpoints and it pays to know how they work so you can be aware of potential reprecussions of using them.&lt;/li&gt;
      &lt;li&gt;Debuggers can be used to modify program execution by modifying the control registers, which can be helpful for identifying what code &lt;em&gt;would&lt;/em&gt; have done if it detected it was in a different environment.&lt;/li&gt;
      &lt;li&gt;Debuggers can be used to just run single functions as well, which may cause the program to crash afterwards but can be very useful for understanding exactly how, say, a decoding routine works.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What problems does this chapter address? In other words, why should we care about this chapter?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

 	This chapter provides the foundation for understanding what debuggers do and how they work, which enables more technical discussion of how to use debuggers, which is information covered in the next two chapters. 

&lt;h2 id=&quot;terminology&quot;&gt;Terminology&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Debugger&lt;/em&gt;: a piece of software or hardware used to test or examine the &lt;em&gt;execution&lt;/em&gt; of another program.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Malware analysis typically makes use of &lt;em&gt;assembly-level&lt;/em&gt; debuggers, which run an instruction at a time, as opposed to source-level debuggers, which run a line of source code at a time. (We don’t have the source code, so…)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Breakpoints&lt;/em&gt; are used to pause execution of a program.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Step-into vs. step-over&lt;/em&gt;: stepping over means it’ll execute all the code represented by a single instruction. In other words, if you step over a function, it’ll call that function and break immediately after the function returns. Stepping into means you’ll break at the first instruction within a function.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;For instructions that don’t transfer execution, stepping into and stepping over are functionally equivalent.&lt;/li&gt;
  &lt;li&gt;Some debuggers have a step-out function as well– they will run until the function you’re currently in returns.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;types-of-breakpoints-and-how-they-work&quot;&gt;Types of breakpoints (and how they work!)&lt;/h2&gt;

&lt;h3 id=&quot;software-breakpionts&quot;&gt;Software breakpionts&lt;/h3&gt;
&lt;p&gt;When a software breakpoint is set, the debugger overwrites the first byte of the broken instruction with &lt;code class=&quot;highlighter-rouge&quot;&gt;0xCC&lt;/code&gt;, which is the instruction for INT 3, which is the breakpoint interrupt designed for use with debuggers. When this is executed, the OS generates an exception and transfers control to the debugger.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;One problem with this is the code is actually being changed in memory. Functions that perform integrity checks will notice the existence of a breakpoint. Self-modifying code can also remove the breakpoint. Code that reads in the memory of a function will read in a 0xCC byte instead of whatever byte is typically there.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;hardware-breakpoints&quot;&gt;Hardware breakpoints&lt;/h3&gt;
&lt;p&gt;Hardware execution breakpoints are supported via dedicated hardware registers on the x86 architecture. Every time the processor executes an instruction, there is hardware to detect if the instruction pointer is equal to the breakpoint address. As such, the problems discussed with software breakpoints are nonexistent.&lt;/p&gt;

&lt;p&gt;Furthermore, these breakpoints can be set to break on access rather than execution. If code reads memory from a specific address, a hardware breakpoint can be used to break the program on the instruction that reads the memory.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;The drawback with hardware breakpoints is there are only four hardware registers that store breakpoint addresses. Additionally, they are easy to modify by the running program.
    &lt;ul&gt;
      &lt;li&gt;This modification can be partially remediated, however, by setting the General Detect flag in the DR7 register. This causes a break to occur whenever a &lt;code class=&quot;highlighter-rouge&quot;&gt;mov&lt;/code&gt; instruction accesses a debug register.&lt;/li&gt;
      &lt;li&gt;See more info about specific debug registers on page 175.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;conditional-breakpoints&quot;&gt;Conditional breakpoints&lt;/h3&gt;
&lt;p&gt;These are software breakpoints that will break only if a certain condition is true. This would be helpful for breaking when functions are called with certain arguments, for example. They are evaluated as software breakpoints, and the debugger evaluates the condition.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;One problem with these is they slow down the execution speed of a program dramatically, because the program state is examined and evaluated in addition to the actual execution of the program.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;exceptions&quot;&gt;Exceptions&lt;/h2&gt;
&lt;p&gt;Debuggers are usually given two opportunities to handle the same exception: a &lt;em&gt;first-chance exception&lt;/em&gt; and a &lt;em&gt;second-chance&lt;/em&gt; exception.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;When &lt;em&gt;First-chance exceptions&lt;/em&gt; occur, the program stops executing and the debugger is given a first chance at control. The debugger can handle the exception or pass it to the program. If the program has a registered exception handler, that is given a chance to handle the exception after the debugger’s first chance.&lt;/li&gt;
  &lt;li&gt;If the program does not resolve the exception, then the debugger is given a second chance to handle it– &lt;em&gt;second-chance exception&lt;/em&gt;. When the debugger receives these, it means the program would have otherwise crashed, and the debugger must resolve the error if the program is to continue.
    &lt;ul&gt;
      &lt;li&gt;As analysts, we don’t typically care about first-chance exceptions since it’s common that they are used to direct control flow. However, we do care about second-chance exceptions. There may be bugs in the malware, or it’s possible that the malware does not like the environment in which it’s running.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">Chapter summary questions In two sentences or less, provide an overview of what this chapter is about.</summary></entry><entry><title type="html">PMA Ch.7 labs: Playing with Windows-specific malware</title><link href="http://localhost:4000/labs/2018/09/12/PMA_ch7_labs.html" rel="alternate" type="text/html" title="PMA Ch.7 labs: Playing with Windows-specific malware" /><published>2018-09-12T14:31:00-06:00</published><updated>2018-09-12T14:31:00-06:00</updated><id>http://localhost:4000/labs/2018/09/12/PMA_ch7_labs</id><content type="html" xml:base="http://localhost:4000/labs/2018/09/12/PMA_ch7_labs.html">&lt;h2 id=&quot;lab-summary-questions&quot;&gt;Lab summary questions&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Considering malware analysis as a whole, how important is it to a general aspiring analyst to complete this chapter’s exercises?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What did doing the lab exercises teach that was not gained from reading the chapter?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;challenges-encountered-in-the-labs&quot;&gt;Challenges encountered in the labs&lt;/h2&gt;

&lt;h2 id=&quot;lab-walkthrough-includes-answers&quot;&gt;Lab Walkthrough (includes answers!)&lt;/h2&gt;

&lt;h3 id=&quot;71&quot;&gt;7.1&lt;/h3&gt;
&lt;p&gt;Analyze the malware found in file &lt;em&gt;Lab07-01.exe&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Questions to answer as we go on:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;How does this program acheive persistence?&lt;/p&gt;

    &lt;p&gt;By installing a service known as &lt;code class=&quot;highlighter-rouge&quot;&gt;MalService&lt;/code&gt; that runs a malicious function.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Why does this program use a mutex?&lt;/p&gt;

    &lt;p&gt;It runs a mutex to see if a thread needs to be created or not. If the function obtains the mutex, then the program quits. Otherwise, the program attempts to create the mutex and proceeds to attempt to spin up a malicious thread. (This seems counter-intuitive at this point… see the post-answer-reading section below for a more detailed explanation of this.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What’s a good host-based signature for detecting this malware?&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Having a service named &lt;code class=&quot;highlighter-rouge&quot;&gt;Malservice&lt;/code&gt; on the system.&lt;/li&gt;
      &lt;li&gt;Identifcation of a mutex called &lt;code class=&quot;highlighter-rouge&quot;&gt;HGL345&lt;/code&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What’s a good network-based signature for detecting this malware?&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;User agent of just the string &lt;code class=&quot;highlighter-rouge&quot;&gt;Internet Explorer 8.0&lt;/code&gt;
        &lt;ul&gt;
          &lt;li&gt;Connection under that user agent to &lt;code class=&quot;highlighter-rouge&quot;&gt;http://malwareanalysisbook.com/&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What’s the purpose of this program?&lt;/p&gt;

    &lt;p&gt;It looks like this program will attempt to connect to a specific website at a certain time. I believe it’s a program that will turn infected computers into elements of a botnet, which will attack a site at a unified time.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;When will this program finish executing?&lt;/p&gt;

    &lt;p&gt;At some time very close to the turn of the 22nd century.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;First, let’s review and apply static analysis techniques and dynamic analysis techniques from chapters 1-3 before doing too much with Ida.&lt;/p&gt;

&lt;h4 id=&quot;cffexplorer&quot;&gt;CFFExplorer&lt;/h4&gt;

&lt;p&gt;The malware loads three DLLs: &lt;code class=&quot;highlighter-rouge&quot;&gt;ADVAPI32.dll&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;WININET.dll&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;KERNEL32.dll&lt;/code&gt;.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;From ADVAPI.dll: we have CreateServiceA, OpenSCManagerA, and StartServiceCtrlDispatcherA. The book previously described CreateService and OpenSCManager (see ch7 notes in a previous blog post), but I don’t recall seeing the start service function. Luckily, the book again proves its usefulness with Appendix A– the function is used by a service to connect to the main thread of the process to the service control manager. 
&lt;em&gt;Any process that runs as a service must call this function within 30 seconds of startup. Locating this function in malware tells you that the function should be ran as a service.&lt;/em&gt; (This is insightful for question 1.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;From WININET.dll: we have &lt;code class=&quot;highlighter-rouge&quot;&gt;InternetOpenUrlA&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;InternetOpenA&lt;/code&gt;. We know from the book that these functions are used to establish a connection with a specific internet location and to initialize high-level Internet access functions from WinINet. Conveniently for us, InternetOpen requires a user agent parameter, and InternetOpenUrl requires a URL (imagine that). These is insightful for question 4, as each of these could act as network-based signatures if they’re consistent.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;From KERNEL32.dll: There are lots of functions being imported, but the ones that come to mind as notable are:&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CreateMutexA&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;OpenMutexA&lt;/code&gt; as this will require a mutex name, which could act as a host-based signature. I predict the code around this function call will provide the answer to question 2.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CreateThread&lt;/code&gt;, as creating threads for various reasons was discussed in depth in the notes for this chapter.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;GetCurrentProcess&lt;/code&gt;. This will permit the malware to do things with itself.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;GetCommandLineA&lt;/code&gt; tells the process how it was called. This could be used to determine if it’s called as a service or if it’s called to install.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;WriteFile&lt;/code&gt; saves data into a file! Files are always great host-based indicators.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There may be more note-worthy functions used, but none of the others jumped out at me as areas that should be further explored at this moment in time.&lt;/p&gt;

&lt;h4 id=&quot;resource-hacker&quot;&gt;Resource Hacker&lt;/h4&gt;
&lt;p&gt;ResourceHacker found no resources in this file.&lt;/p&gt;

&lt;h4 id=&quot;stringsexe&quot;&gt;Strings.exe&lt;/h4&gt;
&lt;p&gt;In addition to all the imports, strings.exe highlights two notable strings: &lt;code class=&quot;highlighter-rouge&quot;&gt;http://www.malwareanalysisbook.com&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Internet Explorer 8.0&lt;/code&gt;, which I expect to see utilized as the C&amp;amp;C server and the user agent respectively.&lt;/p&gt;

&lt;h4 id=&quot;ida-demo&quot;&gt;Ida Demo&lt;/h4&gt;

&lt;p&gt;The first thing we see when opening this file in Ida is how it establishes persistence.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/ch7sc/01_1main.PNG&quot; alt=&quot;01_1main.PNG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We see that the name of the service is pushed (&lt;code class=&quot;highlighter-rouge&quot;&gt;MalService&lt;/code&gt;) and then a function pointer is pushed. This mimics the structure expected as a parameter to the function, according to MSDN. As such, we can conclude that &lt;code class=&quot;highlighter-rouge&quot;&gt;sub_401040&lt;/code&gt; is what will be called as a service from here on out, which acheives persistence and answers question 1.&lt;/p&gt;

&lt;p&gt;Looking at the function passed to the call above….&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/ch7sc/02_sub401040.PNG&quot; alt=&quot;02_sub401040&quot; /&gt;&lt;/p&gt;

&lt;p&gt;A mutex &lt;code class=&quot;highlighter-rouge&quot;&gt;HGL345&lt;/code&gt; is attempted to be opened (with all access rights– that’s what the constant 0x1F0001 does) first thing. If the call returns 0 (i.e. NULL), that means the function failed to obtain the mutex, perhaps because it doesn’t exist or because it’s in use. If the call does NOT fail, then the program exits, which is sort of strange. 
Otherwise, the program proceeds to create the mutex. (Note that if the mutex exists, CreateMutex simply returns a handle to the mutex).&lt;/p&gt;

&lt;p&gt;It makes a service as it has concluded a service doesn’t exist for itself.&lt;/p&gt;

&lt;p&gt;It waits for some time. Not sure what “FileTime” is at this point, but it seems to wait, perhaps for a specific
date, say, of a planned out DDoS.&lt;/p&gt;

&lt;p&gt;If WaitForSingleObject returns nonzero, the program proceeds to go into an infinite (i.e. INT_MAX) millisecond wait loop. 
If WaitForSingleObject returns 0 (i.e. it has received a signal that it’s done waiting), a thread is created in which more malicious code is called– Ida calls it &lt;code class=&quot;highlighter-rouge&quot;&gt;StartAddress&lt;/code&gt;. What does this do?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/ch7sc/03_startAddress.PNG&quot; alt=&quot;03_startAddress&quot; /&gt;&lt;/p&gt;

&lt;p&gt;It appears to just establish a connection with a domain. Considering the fact that it looks like the previous code waits to create a thread until a specific time, and combined with a little cybersecurity intuition, I believe there’s enough evidence to suggest this program’s purpose is to DDoS a computer at a hardcoded time.&lt;/p&gt;

&lt;p&gt;When? I’m not sure of specifics, but the date pushed to CreateWaitableTimerA includes the year 2100 and the rest of the parameters are 0, which makes me think somehwere around the turn of the century. More in-depth analysis may help me figure this out specifically, but I believe it would be more beneficial to read the answers to this and move on to the next sample of malware.&lt;/p&gt;

&lt;h4 id=&quot;realizations-made-after-reading-the-book-answers&quot;&gt;Realizations made after reading the book answers:&lt;/h4&gt;

&lt;p&gt;The first thing I looked up was an explanation behind the wonky-seeming mutex business. It goes like this:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;If the initial mutex call &lt;code class=&quot;highlighter-rouge&quot;&gt;OpenMutex&lt;/code&gt; succeeds, then the program exits. Otherwise, it continues.&lt;/li&gt;
  &lt;li&gt;If the program continues, the first thing it does is it attempts to create the mutex. The book says that if a copy of the malware was already running, then the first call to &lt;em&gt;OpenMutex&lt;/em&gt; would have succeeded.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I get it now. The program runs forever, so it creates a mutex &lt;em&gt;but does not obtain access to it.&lt;/em&gt; This is an indicator to all future instances of the program that it’s already running. Nothing else will obtain this mutex (or if it is obtained, it’ll be released very soon as the program will obtain it and then exit, which will, I presume, free the mutex). The mutex will simply act as a gatekeeper of sorts.&lt;/p&gt;

&lt;p&gt;But what if the computer restarts? Will the mutex persist? If it will, then, since the function called by the service manager contains the initial mutex check, the service should theoretically end. Is this a bug, or is it author-written protection for newbie malware analysts, or am I just not understanding something? Hmmmm…..&lt;/p&gt;

&lt;p&gt;The answer to this question is answered &lt;a href=&quot;https://blogs.msdn.microsoft.com/oldnewthing/20100903-00/?p=12953&quot;&gt;here&lt;/a&gt;. From what I can conclude, mutexes will not persist after handles to them are closed, so if the computer restarts, the service will recreate the mutex and go on its merry malicious way.&lt;/p&gt;

&lt;p&gt;Anyway. Moving on:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/ch7sc/04_20threads.PNG&quot; alt=&quot;04_20threads&quot; /&gt;&lt;/p&gt;

&lt;p&gt;One thing I did not pay close attention to was how the threads were created. I see now that it moves 20 into &lt;code class=&quot;highlighter-rouge&quot;&gt;esi&lt;/code&gt; and then calls CreateThread until &lt;code class=&quot;highlighter-rouge&quot;&gt;esi&lt;/code&gt; is 0. I believe that, since the startAddress is passed to each thread, we will have 20 different instances of connection requests, per bot in the botnet.&lt;/p&gt;

&lt;p&gt;Furthermore, I see now that the program will not end, as in any case, push INT_MAX followed by a sleep occurs.&lt;/p&gt;

&lt;p&gt;Lastly, looking more carefully at &lt;code class=&quot;highlighter-rouge&quot;&gt;StartAddress&lt;/code&gt; will help one see that the loop that attempts connections with &lt;code class=&quot;highlighter-rouge&quot;&gt;http://www.malwareanalysisbook.com&lt;/code&gt; will unconditionally repeat, meaning we will have 20 * unlimited connection attempts, &lt;em&gt;per bot&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&quot;72&quot;&gt;7.2&lt;/h3&gt;

&lt;p&gt;Questions to keep in mind as we go on:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;How does this program acheive persistence?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What’s the purpose of this program?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;When will this program finish executing?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This time, the first thing I did was open this program in Ida. Upon opening, we see this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/ch7sc/05_OleInitialize.PNG&quot; alt=&quot;05_OleInitialize.PNG&quot; /&gt;;&lt;/p&gt;

&lt;p&gt;So, the COM library will be initialized, which hints that COM objects will be used. A few other functions will be used, and it’s worth looking them up to get the general idea of what they are used for before diving into the details.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CoCreateInstance&lt;/code&gt;: Per &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance&quot;&gt;MDSN docs&lt;/a&gt;, this creats a single uninitialized object of the class associated with a specified CLSID.  It would be worth looking into what the passed-in CLSID is and see what that corresponds to. &lt;strong&gt;Note that the interface pointer created by the function is stored into var ppv&lt;/strong&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;VariantInit&lt;/code&gt;: This function creates a variant. I believe that a variant is simply a data structure that supports many different data types, according to &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/winauto/variant-structure&quot;&gt;Microsoft&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SysAllocString&lt;/code&gt;: Allocates a new string and copies the passed string into it. We should look into what is passed to this.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SysFreeString&lt;/code&gt;: Frees an alloc’d string.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let’s talk about what’s passed to CoCreateInstance. A CLSID is a 128 bit hex number. That’s 128 / 8 = 16 bytes.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/ch7sc/06_CLSID.PNG&quot; alt=&quot;06_CLSID.PNG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We have a four-part structure here: a DD (define double word), a DW (define word), another DW, and then 8 DB (Define bytes). DD’s are 4 bytes, DWs are 2 bytes, and DBs are 1 byte. The 6 dup (0) just means we have 6 duplicate bbytes of the data 0.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;dd&lt;/td&gt;
      &lt;td&gt;dw&lt;/td&gt;
      &lt;td&gt;dw&lt;/td&gt;
      &lt;td&gt;db&lt;/td&gt;
      &lt;td&gt;db&lt;/td&gt;
      &lt;td&gt;db&lt;/td&gt;
      &lt;td&gt;db&lt;/td&gt;
      &lt;td&gt;db&lt;/td&gt;
      &lt;td&gt;db&lt;/td&gt;
      &lt;td&gt;db&lt;/td&gt;
      &lt;td&gt;db&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0002DF01&lt;/td&gt;
      &lt;td&gt;0000&lt;/td&gt;
      &lt;td&gt;0000&lt;/td&gt;
      &lt;td&gt;C0&lt;/td&gt;
      &lt;td&gt;00&lt;/td&gt;
      &lt;td&gt;00&lt;/td&gt;
      &lt;td&gt;00&lt;/td&gt;
      &lt;td&gt;00&lt;/td&gt;
      &lt;td&gt;00&lt;/td&gt;
      &lt;td&gt;00&lt;/td&gt;
      &lt;td&gt;46&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;So if we google this CLSID 0002DF01-0000-0000-C000-000000000046, we get a bunch of results that are basically meaningless. Instead, I just found the registry key that contains CLSIDs: &lt;code class=&quot;highlighter-rouge&quot;&gt;HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID&lt;/code&gt;. In here, all the CLSIDs are organized (thank goodness).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/ch7sc/07_IE.PNG&quot; alt=&quot;07_IE.PNG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;So this CLSID corresponds to Internet Explorer.&lt;/p&gt;

&lt;p&gt;Now let’s talk about the RIID. The RIID is a reference to the identifier of the interface to be used to communicate with the object returned by CoCreateInstance. It has the same byte-age as the above CLSID in memory.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;dd&lt;/td&gt;
      &lt;td&gt;dw&lt;/td&gt;
      &lt;td&gt;dw&lt;/td&gt;
      &lt;td&gt;db&lt;/td&gt;
      &lt;td&gt;db&lt;/td&gt;
      &lt;td&gt;db&lt;/td&gt;
      &lt;td&gt;db&lt;/td&gt;
      &lt;td&gt;db&lt;/td&gt;
      &lt;td&gt;db&lt;/td&gt;
      &lt;td&gt;db&lt;/td&gt;
      &lt;td&gt;db&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;D30C1661&lt;/td&gt;
      &lt;td&gt;CDAF&lt;/td&gt;
      &lt;td&gt;11D0&lt;/td&gt;
      &lt;td&gt;8A&lt;/td&gt;
      &lt;td&gt;3E&lt;/td&gt;
      &lt;td&gt;00&lt;/td&gt;
      &lt;td&gt;C0&lt;/td&gt;
      &lt;td&gt;4F&lt;/td&gt;
      &lt;td&gt;C9&lt;/td&gt;
      &lt;td&gt;E2&lt;/td&gt;
      &lt;td&gt;6E&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;I threw the string D30C1661-CDAF-11D0-8A3E-00C04FC9E26E into Google and up pops a Microsoft &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/shdocvw.iwebbrowser2?view=dynamics-usd-3&quot;&gt;page&lt;/a&gt; that tells us this corresponds to the IWebBrowser2 interface.&lt;/p&gt;

&lt;p&gt;By now it’s quite evident that this program is interfacing with Internet Explorer. Further, it doesn’t appear there is any evident persistence mechanism at this time. We just need to figure out what exactly this program is doing and when it’ll finish executing.&lt;/p&gt;

&lt;p&gt;Moving on. Let’s direct attention to this chunk of code.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/ch7sc/08_magic.PNG&quot; alt=&quot;08_magic&quot; /&gt;.&lt;/p&gt;

&lt;p&gt;The most important thing to note from this part of the code is that the COM object itself is being used to make a special function call. At the time of the &lt;code class=&quot;highlighter-rouge&quot;&gt;call dword ptr [edx+2ch]&lt;/code&gt;, the object is in edx (see how it was dereferenced from [eax] into edx earlier), and the offset 0x2c specifies a function offset from the beginning of the object. 
Identifying what function that offset corresponds to is explained on page 156 of the book. It says to go to the structures subview and then hit &lt;code class=&quot;highlighter-rouge&quot;&gt;insert&lt;/code&gt; and then click “add standard structure.” I was able to add the structure but I didn’t see a way to utilize this information to identify the function being called in the assembly. Perhaps this is an Ida pro specific feature.&lt;/p&gt;

&lt;p&gt;Either way, based on the fact that we are interfacing with Internet Explorer and we have a string that contains a URL, we can perhaps safely conclude that this program will end up having IE go to the website. Since the URL takes us to a page called “ad.html”, we can conclude this is probably adware. (Of course in the real world, we can’t validly make this assumption since anything could be called “ad.html,” but for purposes of this training, I think it’s acceptable in the interest of time.)&lt;/p&gt;

&lt;p&gt;The program ends immediately after performing these actions, which suggests persistence is not acheived and that it won’t run forever or anything like that. It’s a simple baby adware program.&lt;/p&gt;

&lt;h3 id=&quot;73&quot;&gt;7.3&lt;/h3&gt;

&lt;p&gt;I’m putting this sample on the backburner for now, as I need to move on and learn about some malware obfuscation techniques in lieu of finding a thesis project of some form. Check back later on.&lt;/p&gt;

&lt;!--

Alright, our first big boy malware sample! Apparently this malware was caught in the wild and domesticated for training purposes, so while it will no longer connect to a sketchy domain, it may still have dangerous implications unforeseen by the domesticators (i.e. Sikorski and Honig). Run it in a VM.

1. How does this program acheive persistence to ensure it continues running when the machine is rebooted?

2. What are two good host-based signatures?

3. What is the purpose of this program?

4. How could you remove this malware once it's installed?
--&gt;</content><author><name></name></author><summary type="html">Lab summary questions Considering malware analysis as a whole, how important is it to a general aspiring analyst to complete this chapter’s exercises?</summary></entry><entry><title type="html">PMA Ch. 7 notes: Analyzing Malicious Windows Programs</title><link href="http://localhost:4000/notes/2018/09/10/ch7_PMA_notes.html" rel="alternate" type="text/html" title="PMA Ch. 7 notes: Analyzing Malicious Windows Programs" /><published>2018-09-10T14:31:00-06:00</published><updated>2018-09-10T14:31:00-06:00</updated><id>http://localhost:4000/notes/2018/09/10/ch7_PMA_notes</id><content type="html" xml:base="http://localhost:4000/notes/2018/09/10/ch7_PMA_notes.html">&lt;h2 id=&quot;chapter-summary-questions&quot;&gt;Chapter summary questions&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;In two sentences or less, provide an overview of what this chapter is about.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This chapter discusses a plethora of the Windows mechanics that malware authors frequently like to make use of.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;What are the three most important takeaways from this chapter?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The attack surface for Windows-based malware is huge, and it’s important to have a grasp on as much of the workings of Windows internals as possible to be best equipped for analyzing malicious samples.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;What problems does this chapter address? In other words, why should we care about this chapter?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Windows is the most popular malware target simply because more people use Windows than other operating systems. As such, it pays to know how Windows works.&lt;/p&gt;

&lt;h2 id=&quot;windows-mechanics&quot;&gt;Windows Mechanics&lt;/h2&gt;

&lt;h3 id=&quot;common-windows-api-data-types&quot;&gt;Common Windows API Data Types&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;WORD&lt;/code&gt; (w): 16 bits&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DWORD&lt;/code&gt; (dw): 32 bits&lt;/li&gt;
  &lt;li&gt;Handle: a reference to an object. They are like pointers in that they refer to objects or memory addresses, but include more information and cannot be manipulated like pointers.
    &lt;ul&gt;
      &lt;li&gt;Examples: &lt;code class=&quot;highlighter-rouge&quot;&gt;HModule&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;HInstance&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;HKey&lt;/code&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Long Pointer (LP): Pointer to another type. 32 bits, I believe.
    &lt;ul&gt;
      &lt;li&gt;Examples: &lt;code class=&quot;highlighter-rouge&quot;&gt;LPByte&lt;/code&gt; is a pointer to a byte.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Callback: Represents a function that will be called by the Windows API.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;special-files&quot;&gt;Special Files&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Special File&lt;/strong&gt;: one that can be accessed much like other files, but are not accessed by their drive letter and path. They can be hidden to directory listings.&lt;/p&gt;

&lt;h4 id=&quot;shared-files&quot;&gt;Shared Files&lt;/h4&gt;

&lt;p&gt;These start with &lt;code class=&quot;highlighter-rouge&quot;&gt;\\serverName\share&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;\\?\serverName\share&lt;/code&gt;. The &lt;code class=&quot;highlighter-rouge&quot;&gt;\\?\&lt;/code&gt; prefix tells the OS to disable all string parsing, and allows access to longer filenames.&lt;/p&gt;

&lt;h4 id=&quot;namespaces&quot;&gt;Namespaces&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Namepsaces&lt;/strong&gt; can be thought of as a fixed number of folders, each storing different types of objects. All namespaces exist within the NT namespace, and this can be browsed using the &lt;em&gt;WinObj Object Manager namespace viewer&lt;/em&gt; from Microsoft. 
  The Win32 device namespace with the prefix &lt;code class=&quot;highlighter-rouge&quot;&gt;\\.\&lt;/code&gt; can be used to access physical devices directly, and read and write to them like a file. Again, this can be used to get around Windows API calls and avoid detection.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;It seems like namepsaces are a significant threat to analysts due to the covert abilities it equips malware with.&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;alternate-data-streams&quot;&gt;Alternate Data Streams&lt;/h4&gt;

&lt;p&gt;This allows additional data to be added to an existing file within NTFS. The extra data does not show up from within a directory listing, nor is it displayed when showing the contents of a file. &lt;em&gt;It’s only visible when viewing the stream.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;ADS data is named according to the convention &lt;em&gt;normalFile.txt:Stream:$DATA&lt;/em&gt;, which is what allows a program to read and write to a stream. (I don’t really understand the concept of streams in this context yet, but if it’s not further answered in the chapter, I’ll look it up elsewhere.)&lt;/p&gt;

&lt;h3 id=&quot;the-windows-registry&quot;&gt;The Windows Registry&lt;/h3&gt;
&lt;p&gt;The registry is used to store OS and program configuration information, such as settings and options. It is often used by malware to establish persistence in addition to its usual use of configuration. Important terminology related to the registry:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;Root Key&lt;/em&gt;: registry is divided into five top-level sections called root keys. &lt;code class=&quot;highlighter-rouge&quot;&gt;HKEY&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;hive&lt;/code&gt; are pseudonyms of this.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Key&lt;/em&gt;: It’s like a folder in the registry.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Subkey&lt;/em&gt;: it’s like a subfolder within a folder. A subkey is a key.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Value Entry&lt;/em&gt;: An ordered pair with a name and a value.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Value or Data&lt;/em&gt;: data stored in a registry entry.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;root-key-101&quot;&gt;Root Key 101&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HKEY_LOCAL_MACHINE (HKLM)&lt;/code&gt;: Stores settings global to the local machine&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HKEY_CURRENT_USER (HKCU)&lt;/code&gt;: Stores settings specific to the current user&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HKEY_CLASSES_ROOT&lt;/code&gt;: Stores info defining types&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HKEY_CURRENT_CONFIG&lt;/code&gt;: Stores settings about the current hardware configuration (especially differences between current and standard configuration)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HKEY_USERS&lt;/code&gt;: Defines settings for default/new/current users&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;popular-ways-to-establish-persistence&quot;&gt;Popular ways to establish persistence&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run&lt;/code&gt; contains values that are executables that are started as soon as a user logs in.&lt;/p&gt;

&lt;h3 id=&quot;networking-apis&quot;&gt;Networking APIs&lt;/h3&gt;
&lt;p&gt;Note that &lt;code class=&quot;highlighter-rouge&quot;&gt;WSAStartup()&lt;/code&gt; must be called before other networking functions to allocate resources for the networking libraries.&lt;/p&gt;

&lt;h4 id=&quot;berkeley-compatible-sockets&quot;&gt;Berkeley Compatible Sockets&lt;/h4&gt;
&lt;p&gt;These socket functions provide functionality that is almost identical on Unix and Windows systems, and these functions are implemented in the Winsock libraries– &lt;em&gt;ws2_32.dll&lt;/em&gt;. Most common:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;socket&lt;/code&gt;: Creates a socket.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bind&lt;/code&gt;: Attaches a socket to a particular port, prior to the accept call&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;listen&lt;/code&gt;: Indicates that a socket will be listening for incoming connections&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;accept&lt;/code&gt;: Opens a connection to a remote socket and accepts that connection&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;connect&lt;/code&gt;: Opens a connection to a remote socket that is waiting for the connection&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;recv&lt;/code&gt;: Receives data from the remote socket&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;send&lt;/code&gt;: Sends data to the remote socket&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;wininet-api&quot;&gt;WinINet API&lt;/h4&gt;
&lt;p&gt;These functions are stored in &lt;em&gt;Wininet.dll&lt;/em&gt; and provide higher-level networking APIs.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;InternetOpen&lt;/code&gt;: used to initialize a connection to the Internet&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;InternetOpenUrl&lt;/code&gt;: used to connect to a HTTP or FTP resource&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;InternetReadFile&lt;/code&gt;: allows the program to read data from a file downloaded from the Internet.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;processes&quot;&gt;Processes&lt;/h3&gt;
&lt;p&gt;The OS will allocate memory for processes on a per-process basis. One process’s addresses may be the same as another process’s addresses, but due to virtual memory and abstraction by the OS (I believe), these processes will not overlap.&lt;/p&gt;

&lt;h3 id=&quot;threads&quot;&gt;Threads&lt;/h3&gt;
&lt;p&gt;A process’s instructions are executed by one or more threads. A thread is an independent sequence of instructions that are executed by the CPU without waiting for other threads. Threads within a process share the same memory space, but each has its own processer registers and stack.&lt;/p&gt;

&lt;p&gt;Threads have complete control of the CPU when they’re executing. Their context, the &lt;em&gt;thread context&lt;/em&gt;, is saved in a structure when a context switch is performed.&lt;/p&gt;

&lt;h3 id=&quot;mutexes-aka-mutants&quot;&gt;Mutexes (aka Mutants)&lt;/h3&gt;
&lt;p&gt;These are global objects used to control access to shared resources. They often use hard-coded names, which acts as a host-based indicator to the malware analyst.&lt;/p&gt;

&lt;h3 id=&quot;services&quot;&gt;Services&lt;/h3&gt;
&lt;p&gt;These are ran by SYSTEM and can only be installed with administrator privilege. There are different types of services, each of which execute in different ways. The most commonly maliciously used type is the &lt;code class=&quot;highlighter-rouge&quot;&gt;WIN32_SHARE_PROCESS&lt;/code&gt;, type, which stores the code for the service in a DLL and combines several different services into a single, shared process.&lt;/p&gt;

&lt;p&gt;In Task Manager, there exist several &lt;em&gt;svchost.exe&lt;/em&gt; instances, and these run &lt;code class=&quot;highlighter-rouge&quot;&gt;WIN32_SHARE_PROCESS&lt;/code&gt; type services. &lt;code class=&quot;highlighter-rouge&quot;&gt;WIN32_OWN_PROCESS&lt;/code&gt; is also used because it stores the code in a .exe file and runs it as an independent process.&lt;/p&gt;

&lt;p&gt;Services information is stored in &lt;code class=&quot;highlighter-rouge&quot;&gt;HKLM\SYSTEM\CurrentControlset\Services&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;com-executables&quot;&gt;COM executables&lt;/h3&gt;
&lt;p&gt;The &lt;em&gt;Component Object Model&lt;/em&gt; is an interface standard that makes it possible for different software components to call each other’s code without knowledge of specifics of each other. It was designed to support reusable software componets that could be usable by all programs.&lt;/p&gt;

&lt;p&gt;COM is implemented as a client-server framework. The clients are what make use of the COM objects, and the servers are the reusable software components. Every thread that uses COM must call &lt;code class=&quot;highlighter-rouge&quot;&gt;OleInitialize&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;CoInitializeEx&lt;/code&gt; at least once before calling other COM library functions.&lt;/p&gt;

&lt;p&gt;COM objects are accessed via their &lt;em&gt;globally unique identifiers&lt;/em&gt; (GUIDs) known as &lt;em&gt;class identifiers (CLSIDs)&lt;/em&gt; and &lt;em&gt;interface identifiers (IIDs)&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;One common function used by malware is &lt;code class=&quot;highlighter-rouge&quot;&gt;Navigate&lt;/code&gt; which allows a program to launch Internet Explorer and access a web address. &lt;code class=&quot;highlighter-rouge&quot;&gt;Navigate&lt;/code&gt; is part of the &lt;code class=&quot;highlighter-rouge&quot;&gt;IWebBrowser2&lt;/code&gt; interface, which specifies a list of functions that must be implemented, but does not specify which program will provide that functionality. A &lt;em&gt;COM Class&lt;/em&gt; is the program that provides said functionality. Interfaces are identified with an &lt;em&gt;IID&lt;/em&gt; and the classes are identifed with a &lt;em&gt;CLSID&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;COM stuff is tricky and dense. I am going to bookmark this page (by saying here that it’s on and near p155) and come back to it if I encounter such things in malware.&lt;/p&gt;

&lt;h3 id=&quot;exceptions&quot;&gt;Exceptions&lt;/h3&gt;
&lt;p&gt;Windows uses &lt;em&gt;structured exception handling (SEH)&lt;/em&gt; to deal with handling exceptions. In 32 bit systems, SEH info is stored on the stack (which means it’s potentially vulnerable to things such as buffer overflows).&lt;/p&gt;

&lt;h3 id=&quot;kernel-vs-user-mode&quot;&gt;Kernel vs. User Mode&lt;/h3&gt;
&lt;p&gt;Nearly all code runs in user mode, save the operating system itself and hardware drivers. Usually, user mode programs do not have direct access to hardware devices and &lt;em&gt;must&lt;/em&gt; go through the Windows API. &lt;code class=&quot;highlighter-rouge&quot;&gt;SYSENTER&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;SYSCALL&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;Int 0x2E&lt;/code&gt; assembly instructions are all used to do this.&lt;/p&gt;

&lt;p&gt;All processes running in the kernel share resources and memory addresses, and kernel code has fewer security checks, not to mention it has ultimate power over a system. It’s basically the priviliged land for malware authors.&lt;/p&gt;

&lt;h3 id=&quot;the-native-api&quot;&gt;The Native API&lt;/h3&gt;
&lt;p&gt;The Native API is a lower-level interface for interacting with Windows that is rarely used by nonmalicious programs. Calling native API functions bypasses the normal Windows API. See p159 for a diagram describing how context switches from user mode to kernel mode when calling native functions. Native functions are usually predicated by Nt.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ntoskrnl.exe&lt;/code&gt; contains functions that run in kernel space.&lt;/p&gt;

&lt;h2 id=&quot;quick-windows-function-cheat-sheet&quot;&gt;Quick Windows Function Cheat Sheet&lt;/h2&gt;
&lt;p&gt;I include some unintuitive conceptual ‘gotchas’ here, but I don’t discuss details behind how to use the functions. Check out MSDN documentation for that.&lt;/p&gt;

&lt;h3 id=&quot;file-system-functions&quot;&gt;File System Functions&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;CreateFile&lt;/li&gt;
  &lt;li&gt;ReadFile and WriteFile&lt;/li&gt;
  &lt;li&gt;CreateFileMapping and MapViewOfFile
    &lt;ul&gt;
      &lt;li&gt;&lt;em&gt;File Mappings&lt;/em&gt; are commonly used by malware writers because they allow a file to be loaded into memory and manipulated easily. &lt;code class=&quot;highlighter-rouge&quot;&gt;CreateFileMapping&lt;/code&gt; loads a file from disk into memory; &lt;code class=&quot;highlighter-rouge&quot;&gt;MapViewOfFile&lt;/code&gt; returns a pointer to the base address of that mapping.&lt;/li&gt;
      &lt;li&gt;File Mappings can be used to replicate the functionality of the Windows loader– after the malware reads in an executable file to memory, it can parse the PE and do whatever it wants with it, (possibly) without the use of Windows API functions, which can help evade monitoring programs.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;common-registry-functions&quot;&gt;Common Registry Functions&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;RegOpenKeyEx&lt;/li&gt;
  &lt;li&gt;RegSetValueEx: Adds a new value to the registry and sets its data (or modifies an existing value)&lt;/li&gt;
  &lt;li&gt;RegGetValue: Get the data for a value entry in the registry&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;reg-scripts&quot;&gt;.reg scripts&lt;/h4&gt;
&lt;p&gt;You can write scripts that interact with the registry. Files with the .reg extension, when double clicked, modifies the registry by merging the info the file contains &lt;em&gt;into&lt;/em&gt; the registry.&lt;/p&gt;

&lt;h3 id=&quot;common-process-functions&quot;&gt;Common Process Functions&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;CreateProcess
    &lt;ul&gt;
      &lt;li&gt;One of the parameters to this function is the &lt;code class=&quot;highlighter-rouge&quot;&gt;startupinfo&lt;/code&gt; structure. You can configure &lt;code class=&quot;highlighter-rouge&quot;&gt;stdin&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;stdio&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;stderr&lt;/code&gt; streams in this, and potentially set them to sockets that you can send across the wire. See p148 for an example of this.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;Executables can store other executables in their resource section. An executable can extract an executable from within itself in this manner, write it to disk, and then call &lt;code class=&quot;highlighter-rouge&quot;&gt;createProcess&lt;/code&gt; to run it.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;common-thread-functions&quot;&gt;Common Thread Functions&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;CreateThread. The caller of this function specifies the start point of the thread.
    &lt;ul&gt;
      &lt;li&gt;The caller of CreateThread can specify the function where the thread starts, and a &lt;strong&gt;single&lt;/strong&gt; parameter that can be passed to this function.
        &lt;ul&gt;
          &lt;li&gt;Malware can use CreateThread to load a new malicious library into a process when LoadLibrary is what the thread is configured to run, and the parameter is the name of the library that should be passed to LoadLibrary. LoadLibrary could then load a malicious DLL, thereby invoking DllMain, which could do more malicious things.&lt;/li&gt;
          &lt;li&gt;Malware could use CreateThread to create two separate threads– one for input, and one for output.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;common-mutex-functions&quot;&gt;Common Mutex Functions&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;WaitForSingleObject is used by a thread to wait on a mutex.&lt;/li&gt;
  &lt;li&gt;ReleaseMutex is called by a thread when it’s done with a mutex. Obv.&lt;/li&gt;
  &lt;li&gt;CreateMutex: it destroys a mutex. (sarcasm)&lt;/li&gt;
  &lt;li&gt;OpenMutex: One process can get a handle to another process’s mutex by using this. Malware will commonly create a mutex and attempt to open an existing mutex with this technique to ensure only one version of the malware is running on the machine at once.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;common-services-related-functions&quot;&gt;Common Services-related Functions&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;OpenSCManager: returns a handle to the service control manager (SCM), which is used for all subsequent service-related function calls.&lt;/li&gt;
  &lt;li&gt;CreateService: adds a new service to the SCM. Caller specifies if the service is to be ran at startup or not.&lt;/li&gt;
  &lt;li&gt;StartService: You guessed it! It starts a service. It’s used only if the service is not configured to start automatically (or, say, if you just freshly installed the malware on a system and it hasn’t rebooted the machine yet).&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;transferring-execution-among-files&quot;&gt;Transferring execution among files&lt;/h2&gt;

&lt;h3 id=&quot;dll-files&quot;&gt;DLL files&lt;/h3&gt;
&lt;p&gt;DLLs export functions and cannot be ran on their own. They must run their code via an executable of some form.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;They only needed to be loaded into memory once. Then they can be used by multiple programs (unlike static libraries, which would need to be loaded on a per-exectuable-instance basis).&lt;/li&gt;
  &lt;li&gt;DLLs look extremely similar to exectuable files– they use the same format as an execuable (the PE file format).A single flag differentiates the two.&lt;/li&gt;
  &lt;li&gt;DLLs contain DllMain()– a function that has no label and isn’t an export in the DLL, but is specified in the PE header as the file’s entry point. It’s called to notify the DLL when a process loads or unloads the library, creates a new thread, or finishes an existing thread. This allows the DLL to manage any per-process or per-thread resources.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;other-page-to-page-notes&quot;&gt;Other page-to-page notes&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Autoruns&lt;/em&gt; is a program downloadable from Microsoft that lists code that’ll run automatically when the OS starts. It pulls from about 25-30 registry locations (albeit not all of the possible ones).&lt;/p&gt;</content><author><name></name></author><summary type="html">Chapter summary questions</summary></entry><entry><title type="html">PMA Ch.6 Lab: Recognizing C Constructs in Assembly</title><link href="http://localhost:4000/labs/2018/09/09/PMA_ch6_labs.html" rel="alternate" type="text/html" title="PMA Ch.6 Lab: Recognizing C Constructs in Assembly" /><published>2018-09-09T14:31:00-06:00</published><updated>2018-09-09T14:31:00-06:00</updated><id>http://localhost:4000/labs/2018/09/09/PMA_ch6_labs</id><content type="html" xml:base="http://localhost:4000/labs/2018/09/09/PMA_ch6_labs.html">&lt;h2 id=&quot;lab-summary-questions&quot;&gt;Lab summary questions&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Considering malware analysis as a whole, how important is it to a general aspiring analyst to complete this chapter’s exercises?&lt;/p&gt;

    &lt;p&gt;This lab may prove to be less challenging for those already aquainted with C programming, but it was still very helpful because of the way it starts off very easy and builds up. I’d argue that this lab was the most fun one I’ve done so far.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What did doing the lab exercises teach that was not gained from reading the chapter?&lt;/p&gt;

    &lt;p&gt;This lab helps fortify the necessity of paying attention to details, and knowing &lt;em&gt;exactly&lt;/em&gt; what the functionality of MSDN functions are.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;challenges-encountered-in-the-labs&quot;&gt;Challenges encountered in the labs&lt;/h2&gt;

&lt;p&gt;I didn’t encounter too many challenges in this lab, but I believe that was due to my knowledge of C programming. It &lt;strong&gt;significantly&lt;/strong&gt; sped up how fast I was able to gather the semantic meaning of the program because I didn’t need to look up nearly as many functions or parameters as I otherwise would have.&lt;/p&gt;

&lt;h2 id=&quot;lab-walkthrough-includes-answers&quot;&gt;Lab Walkthrough (includes answers!)&lt;/h2&gt;

&lt;h3 id=&quot;61&quot;&gt;6.1&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;What is the major code construct found in the only subroutine called by &lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;?&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/files/ch6sc/1_6.1.PNG&quot; alt=&quot;1_6.1.PNG&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;It’s an ‘if’ condition checking whether or not we’re connected to the internet.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What is the subroutine located at &lt;code class=&quot;highlighter-rouge&quot;&gt;0x40105F&lt;/code&gt;?&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sub_40105F&lt;/code&gt; is called if the code finds there is an internet connection. The first function call in this _stbuf(), which &lt;a href=&quot;https://social.msdn.microsoft.com/Forums/vstudio/en-US/838011e2-7404-4922-989e-3ceacd6e3127/how-about-the-function-stbufstdout-woks-?forum=vclanguage&quot;&gt;appears to be called in preparation for sending content to stdout&lt;/a&gt;. This is enough for me to believe that this function is simply a print function.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What is the purpose of this program?&lt;/p&gt;

    &lt;p&gt;The purpose of this program is to print whether or not an internet connection can be made.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;62&quot;&gt;6.2&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;What operation does the first subroutine called by &lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt; perform?&lt;/p&gt;

    &lt;p&gt;The first subroutine called by main is &lt;code class=&quot;highlighter-rouge&quot;&gt;sub_401000&lt;/code&gt;, which appears to be the exact same subroutine we analyzed in the problem above (i.e. the one that checks to see if we have an internet connection).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What is the subroutine located at &lt;code class=&quot;highlighter-rouge&quot;&gt;0x40117F&lt;/code&gt;?&lt;/p&gt;

    &lt;p&gt;This is printf (same answer to 6.1.2).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What does the second subroutine called by &lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt; do?&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sub_401040&lt;/code&gt;, the second subroutine, phones home looking to get a command, presumably to execute on the infected machine.&lt;/p&gt;

    &lt;p&gt;The function opens a handle to an internet resource (in this case practicalmalwareanalysis.com/cc.htm), and then, if that succeeds, heads to loc_40109d to read 0x200 bytes into a buffer using the InternetReadFile function.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/files/ch6sc/6_6.2.PNG&quot; alt=&quot;6_6.2.PNG&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;We see here that it moves in the dereferenced pointer to the buffer into ecx (i.e. the first character of the buffer), and then compares it to ascii 60. Ascii 60 corresponds to the “&amp;lt;” character, which is the first character of an HTML tag. Immediately after that, it compares to ascii 33, which is the “!” character. Then, it looks for 0x2d or 45 in decimal, which is a “-“ character. It does this twice. If at any time it detects characters that are not these, in this order, it breaks to loc_40111D, which yields an error.&lt;/p&gt;

    &lt;p&gt;So it’s looking for the string “&amp;lt;!–”. This is how a comment in an HTML document is started. We can conclude it’s looking for an HTML comment.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What type of code construct is used in this subroutine?&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/files/ch6sc/2_6.2.PNG&quot; alt=&quot;2_6.2.PNG&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;This looks like a switch nested within an if-statement.&lt;/p&gt;

    &lt;p&gt;Note from after reading the book: the answer they were looking for was an array. There is an array at work here as well, as one can tell from the above screenshot. Bytes of data one byte apart from each other, and referenced in terms of ebp, are sequentially compared, which is indicative of an array.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Are there any network-based indicators for this program?&lt;/p&gt;

    &lt;p&gt;Absolutely. We see that this block of data gets pushed as a parameter to InternetOpenUrlA:&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/files/ch6sc/3_6.2.PNG&quot; alt=&quot;3_6.2.PNG&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;And we can see what the rest of the data is by clicking szUrl.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/files/ch6sc/4_6.2.PNG&quot; alt=&quot;4_6.2.PNG&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;http://www.practicalmalwareanalysis.com/cc.htm&lt;/code&gt; is what the network fellas should look for.&lt;/p&gt;

    &lt;p&gt;The book also mentions that we can look for the user agent that this program uses, which makes sense.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What is the purpose of this malware?&lt;/p&gt;

    &lt;p&gt;The purpose of this malware is to phone home and get commands to execute on the infected machine.&lt;/p&gt;

    &lt;p&gt;If the code passes the HTML comment check, then it moves the character immediately proceeding the comment into al (which is eax’s lowest 8 bits) and returns. Then, that single character is moved into the pointer pointing to the memory address contained within ebp+var_8. This character is then pushed to be in a function that prints a single character immediately before a command, which is indicative that there are a predefined set of commands, each corresponding to a single character, that this malware can run. The purpose of the malware is to get a single character command and do something with it.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;63&quot;&gt;6.3&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Compare the calls in &lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt; to Lab 6.2’s &lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt; method. What is the new funtion called from &lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;?&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/files/ch6sc/5_6.3.PNG&quot; alt=&quot;5_6.3.PNG&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;The new function appears to be shortly after the parsing actions. I presume this function will execute the command received and parsed from the internet.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What parameters does this new function take?&lt;/p&gt;

    &lt;p&gt;Function sub_401130 takes two arguments:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;LpExistingfileName, which is, &lt;em&gt;I believe&lt;/em&gt;, the name of itself. The &lt;code class=&quot;highlighter-rouge&quot;&gt;argv&lt;/code&gt; pointer is equivalent to &lt;code class=&quot;highlighter-rouge&quot;&gt;argv[0]&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;argv[0]&lt;/code&gt; is conventionally the name of the program being executed.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;a magic character. From analysis of 6.2, we are highly confident that this particular character corresponds to a command to execute.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What major code construct does this function contain?&lt;/p&gt;

    &lt;p&gt;Ida has identified a switch. BEAUTIFUL.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/files/ch6sc/7_6.3switch.PNG&quot; alt=&quot;7_6.3switch.PNG&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What can this function do?&lt;/p&gt;

    &lt;p&gt;The function puts the character into ecx and subtracts 97. 97 corresponds to ascii ‘a’. It then jumps to a default case if the resulting number is above 4 (i.e. if the character command was not a, b, c, d, or e).&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/files/ch6sc/8_6.3.PNG&quot; alt=&quot;8_6.3.PNG&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;We see now why it subtracted 97– the resulting number is used as an index in a 5-case jump table.&lt;/p&gt;

    &lt;p&gt;The cases are:&lt;/p&gt;
    &lt;ol start=&quot;0&quot;&gt;
 &lt;li&gt; Create directory &lt;code class=&quot;highlighter-rouge&quot;&gt;C:\\Temp&lt;/code&gt;&lt;/li&gt;
 &lt;li&gt; Copy itself into directory &lt;code class=&quot;highlighter-rouge&quot;&gt;C:\\Temp&lt;/code&gt;, renaming itself &lt;code class=&quot;highlighter-rouge&quot;&gt;cc.exe&lt;/code&gt; (but if the file exists it will not overwrite the existing file)&lt;/li&gt;
 &lt;li&gt; Delete file &lt;code class=&quot;highlighter-rouge&quot;&gt;C:\\Temp\\cc.exe&lt;/code&gt;&lt;/li&gt;
 &lt;li&gt; Modify the &lt;code class=&quot;highlighter-rouge&quot;&gt;Software\\Microsoft\\Windows\\CurrentVersion\\Run&lt;/code&gt; registry key. It adds a new service &lt;code class=&quot;highlighter-rouge&quot;&gt;malware&lt;/code&gt; and sets it to execute &lt;code class=&quot;highlighter-rouge&quot;&gt;C:\\Temp\\cc.exe&lt;/code&gt;. This establishes persistence on the infected machine. &lt;/li&gt;
 &lt;li&gt; Sleep for 100000. The sleep function accepts an integer that represents milliseconds, so it sleeps for 100000/1000 = 100 seconds. &lt;/li&gt;
 &lt;li&gt; (Default case) Print an error message that says it's not a valid command. &lt;/li&gt;&lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Are there any host-based indicators for this malware?&lt;/p&gt;

    &lt;p&gt;Most definitely.&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;From case 1 above: if &lt;code class=&quot;highlighter-rouge&quot;&gt;C:\Temp&lt;/code&gt; exists, you may be infected.&lt;/li&gt;
      &lt;li&gt;From case 2 above: if &lt;code class=&quot;highlighter-rouge&quot;&gt;C:\Temp\cc.exe&lt;/code&gt; exists, you are almost surely infected.&lt;/li&gt;
      &lt;li&gt;From case 3 above: if the registry has added &lt;code class=&quot;highlighter-rouge&quot;&gt;Malware&lt;/code&gt; as a service that executes &lt;code class=&quot;highlighter-rouge&quot;&gt;C:\Temp\cc.exe&lt;/code&gt;, you’re certainly infected.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What is the purpose of this malware?&lt;/p&gt;

    &lt;p&gt;The purpose of this malware is to copy itself into a folder and establish persistence, depending on commands it receives from the internet. If the internet cannot be reached, it terminates. My guess is switch case 4 will be a cooler evil payload in 6.4.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;64&quot;&gt;6.4&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;What’s the difference between the calls made from the &lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt; method in Labs 6-3 and 6-4?&lt;/p&gt;

    &lt;p&gt;They are at different addresses, I believe. I’m not going to put too much time into comparing the two, because being able to compare things is a skill I already have.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What new code construct has been added to &lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;?&lt;/p&gt;

    &lt;p&gt;Ah, now we have the same functionality wrapped in a loop. It will wait 60 seconds every iteration, and execute 1440 times (presuming it’s connected to the internet).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What’s the difference between this lab’s parse HTML function and those of the previous labs?&lt;/p&gt;

    &lt;p&gt;Different user agent?&lt;/p&gt;

    &lt;p&gt;After reading book: Ah yes, it builds a separate user agent using &lt;code class=&quot;highlighter-rouge&quot;&gt;sprintf&lt;/code&gt;.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/files/ch6sc/9_6.4.PNG&quot; alt=&quot;9_6.4.PNG&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How long will this program run? (Assume it’s connected to the internet.)&lt;/p&gt;

    &lt;p&gt;It runs 1440 times * 60 seconds. That’s 1440 minutes, which is 24 hours.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Are there any new network-based indicators for this malware?&lt;/p&gt;

    &lt;p&gt;A different user agent that’ll follow the format of &lt;code class=&quot;highlighter-rouge&quot;&gt;Internet Explorer 7.50/pma%d&lt;/code&gt;, where the number substituted for %d is the iteration number that the malware is on. This can be used as input to the command &amp;amp; control server to serve a HTML file with a different command depending on what iteration the malware is on.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What’s the purpose of this malware?&lt;/p&gt;

    &lt;p&gt;The same as previous samples, but upgraded grab MULTIPLE commands from the command and control server back home.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><summary type="html">Lab summary questions Considering malware analysis as a whole, how important is it to a general aspiring analyst to complete this chapter’s exercises?</summary></entry></feed>