<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>KyleTheReverser</title>
    <description>This is an organized hub for everything technical that I write, set up, or figure out over the course of my last year as a Masters student.</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 02 Mar 2019 20:49:24 -0700</pubDate>
    <lastBuildDate>Sat, 02 Mar 2019 20:49:24 -0700</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>Exploring How Packers Mangle Files While Sticking to the PE Format</title>
        <description>&lt;p&gt;To be able to write or modify a program that analyzes the metadata of a packed program in an attempt to determine visualizable information about packed samples of malware, one has to have a deep understanding of how the Portable Executable file format works. Today, I set out to get a better understanding and appreciation of this.&lt;/p&gt;

&lt;p&gt;My information is mainly pulled from &lt;a href=&quot;https://en.wikipedia.org/wiki/Portable_Executable&quot;&gt;Wikipedia’s PE article&lt;/a&gt; and the official &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/debug/pe-format&quot;&gt;Microsoft PE specification&lt;/a&gt;. I also tie together some bits of information by analyzing the on-disk contents of both packed and unpacked samples of both clean and malicious executables.&lt;/p&gt;

&lt;h2 id=&quot;basics&quot;&gt;Basics&lt;/h2&gt;

&lt;p&gt;A picture is worth a thousand words. The diagram of a PE from Wikipedia is an &lt;em&gt;extremely&lt;/em&gt; valuable resource that helped me immensely with understanding offsets and locations of data relative to other locations of data. Follow along with this picture.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/1/1b/Portable_Executable_32_bit_Structure_in_SVG_fixed.svg&quot; alt=&quot;Wiki Diagram&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Microsoft loves the concept of backwards compatability. As such, every exectuable program generated for Windows &lt;em&gt;technically&lt;/em&gt; runs on prior versions of Windows. The first part of the executable file format is a valid program stub for MS-DOS. All it does is tell you that you can’t run the program in DOS mode, but &lt;em&gt;shrug&lt;/em&gt;! It’s still a valid DOS program.&lt;/p&gt;

&lt;p&gt;Immediately after begins the Common Object File Format (COFF) headers. Note that Microsoft documents what all headers and header fields are as well as what data each should contain– and quite well, in my opinion. I only discuss the fields I believe are important for appreciating how packers work their magic. I will refer to each header chunk by the color in which Wikipedia’s diagram colors it.&lt;/p&gt;

&lt;h3 id=&quot;green-section-coff-header&quot;&gt;Green section: COFF Header&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Signature: must be this or the file isn’t valid. That’s just how it is.&lt;/li&gt;
  &lt;li&gt;Machine: contains magic numbers that identify the type of target machine. It’ll contain numbers (identified in the official docs) that correspond to, for example, x86 architectures, MIPS architectures, etc.&lt;/li&gt;
  &lt;li&gt;NumberOfSections: This tells us the number of sections in the file. Because each section header is a static size, it also inadvertently tells us the size of the section table. I believe the section table is just a collection of metainformation about each section (i.e. one purple section header, per section).&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;yellow-section-standard-coff-fields&quot;&gt;Yellow section: Standard COFF Fields&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Magic: This tells us what kind of executable it is: PE32, PE32+ (ie. 64bit), or ROM.
    &lt;ul&gt;
      &lt;li&gt;PE32: 0x10b&lt;/li&gt;
      &lt;li&gt;PE32+: 0x20b&lt;/li&gt;
      &lt;li&gt;ROM: 0x107&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;SizeOfCode: Size of the actual instructions (i.e. the text section) (or it’s the sum of all the text sections)
    &lt;ul&gt;
      &lt;li&gt;The packer may change these values to be nonsensical. I don’t know at this moment.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;SizeOfInitializedData: Size of initialized data.
    &lt;ul&gt;
      &lt;li&gt;Initialized data is data that is initialized already. This includes global variables and local static variables that are set to nonzero values in the source code. Furthermore, this is often (but not necessarily) known as the .data segment within the executable.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SizeOfUninitializedData: Size of uninitialized data. This includes global or static variables that are assigned a value of 0 in the source code or do not have explicit initialization in the source code.
I found this distinction &lt;a href=&quot;https://en.wikipedia.org/wiki/Data_segment&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;AddressOfEntryPoint: Entry point. So this is how OllyDbg knows where to go. I’m sure this is required to include; otherwise Windows won’t be able to execute the program.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All programs have a &lt;em&gt;preferred address&lt;/em&gt; in which they can be loaded into by the Windows loader. According to &lt;a href=&quot;https://en.wikipedia.org/wiki/Portable_Executable#Relocations&quot;&gt;Wikipedia&lt;/a&gt;, Windows programs do not by default contain position-independent code (which means Windows program instructions cannot be moved internally to the program and expected to work properly). Instead, the programs are compiled to work directly with a preferred base address. Programs refer to this base address when referring to data, functions, etc within the program. If a program is already loaded at a specific base address, then Windows recalculates every one of those position-dependent instructions at runtime, for some other base address that is determined by the Windows loader to be free.
Under ideal circumstances (i.e. no overlaps), this is the faster method as it can be heavily optimized. However, in reality, I’m sure that there are many times in which programs running simultaneously have overlapping preferred addresses and, as such, lose those optimizations, thus causing programs to be slower in this situation.&lt;/p&gt;

&lt;p&gt;ELF– the Linux executable file format– does not do this. They can’t optimize in the same ways that Windows can, but they also won’t struggle if they can’t be loaded to a preferred address (and, matter of fact, I believe ELF by default has position independent code which means the entire concept of a preferred base address doesn’t even exist).&lt;/p&gt;

&lt;h3 id=&quot;red-section-windows-specific-fields&quot;&gt;Red section: Windows Specific Fields&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;ImageBase: the preferred load location. Must be a multiple of 64K (that is, 65536).&lt;/li&gt;
  &lt;li&gt;SizeOfImage: the size (in bytes) of the image, including all headers, &lt;em&gt;as the file is loaded in memory.&lt;/em&gt; I believe this can be used to help identify if something is packed. Not sure entirely yet, but I have a feeling it’s important.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;blue-section-data-directories-fields&quot;&gt;Blue section: Data Directories Fields&lt;/h3&gt;

&lt;p&gt;I’m not sure if anything in this section is particularly notable yet.&lt;/p&gt;

&lt;h3 id=&quot;purple-section-section-headers&quot;&gt;Purple section: Section Headers&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Name: the name of this section– 8 bytes, UTF-8 encoded. If 8 char long, NOT null terminated.
    &lt;ul&gt;
      &lt;li&gt;From what I can tell, this is directly manipulated by packers. It need not actually have any text in the section either, as some packers prove.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;VirtualSize: total size of section when loaded into memory.&lt;/li&gt;
  &lt;li&gt;VirtualAddress: address of the first byte of this section relative to the image base.&lt;/li&gt;
  &lt;li&gt;SizeOfRawData: Size of the initialized data on disk.&lt;/li&gt;
  &lt;li&gt;PointerToRawData: Filei pointer to first page of teh section within this COFF file.
    &lt;ul&gt;
      &lt;li&gt;When the section contains only uninitialized data, this should be set to 0.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The rest of the stuff in this header looks uninteresting or deprecated (often both simultaneously).&lt;/p&gt;

&lt;h2 id=&quot;special-section-names&quot;&gt;Special Section Names&lt;/h2&gt;

&lt;p&gt;Some sections are special and are treated accordingly by the Windows loader.&lt;/p&gt;

&lt;table&gt;
&lt;caption&gt;Notable Microsoft special section names&lt;/caption&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Section name&lt;/th&gt;
&lt;th&gt;Section Contents&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
 &lt;tr&gt;&lt;td&gt;
  .bss
 &lt;/td&gt;
 &lt;td&gt;
  Uninitialized data
 &lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;.data&lt;/td&gt;
 &lt;td&gt;Initialized Data&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;.debug$X&lt;/td&gt;
 &lt;td&gt;debug information; differs for certain values of X&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;.idata&lt;/td&gt;
 &lt;td&gt;Import tables&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;.rdata&lt;/td&gt;
 &lt;td&gt;Read-only initialized data&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;.reloc&lt;/td&gt;
 &lt;td&gt;Image relocataions&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;.rsrc&lt;/td&gt;
 &lt;td&gt;Resource directory&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;.sbss&lt;/td&gt;
 &lt;td&gt;GP-relative uninitialized data&lt;br /&gt;
 See more related section types on Microsoft's docs.
 &lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;.text&lt;/td&gt;
 &lt;td&gt;Exectuable code&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;.xdata&lt;/td&gt;
 &lt;td&gt;Exception information&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Information above was derived from &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/debug/pe-format#special-sections&quot;&gt;Microsoft’s special section names documentation&lt;/a&gt;; see that page for more sections or more details.&lt;/p&gt;

&lt;h2 id=&quot;connecting-the-dots&quot;&gt;Connecting the Dots&lt;/h2&gt;

&lt;p&gt;So, with all this being said, how do some legitimate files actually look? How do malicious files look? How do packed files look? Can we derive any signs that files are packed? These are questions I try to answer in this section of the post.&lt;/p&gt;

&lt;p&gt;I use two programs to analyze the metadata of executables: PEView and PEiD. Note that I only explore 32 bit files for now. 64 bit will come later.&lt;/p&gt;

&lt;h3 id=&quot;starting-off-unpacked-vs-upx-packed-command-prompt&quot;&gt;Starting off: Unpacked vs UPX-Packed command prompt&lt;/h3&gt;

&lt;p&gt;Let’s start off simple. I have taken &lt;strong&gt;cmd.exe&lt;/strong&gt; from my Windows 7 box, copied it to my Linux box, and packed it with UPX. I then copied it back to my Windows box and compared the two.&lt;/p&gt;

&lt;p&gt;Here’s a PEiD information image dump.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2019/0302/01_PEiDCMD.PNG&quot; alt=&quot;PEiDCMD&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2019/0302/02_PEiDsections.PNG&quot; alt=&quot;PEiDCMDsections&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2019/0302/03_PEiDCMDdetails.PNG&quot; alt=&quot;PEiDCMDdetails&quot; /&gt;&lt;/p&gt;

&lt;p&gt;And we can find similar information out from PEview as well, but in a different way. PEview makes it easy to see specific values of headers.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2019/0302/04_PEviewCMD.PNG&quot; alt=&quot;04_PEviewCMD&quot; /&gt;&lt;/p&gt;

&lt;p&gt;And now, here are the corresponding clips of the packed version of CMD:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2019/0302/05_PEiDCMDpacked.PNG&quot; alt=&quot;name&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2019/0302/06_PEiDcmdpackedsections.PNG&quot; alt=&quot;name&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2019/0302/07_PEiDcmdpackeddetails.PNG&quot; alt=&quot;name&quot; /&gt;&lt;/p&gt;

&lt;p&gt;And the PEview details of the first section:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2019/0302/08_PEviewCMDpacked.PNG&quot; alt=&quot;name&quot; /&gt;&lt;/p&gt;

&lt;p&gt;My observations:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Sections can be totally mangled and manipulated, as long as the entry point points to somewhere inside one of the sections.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Entry points can go within any section, at any point in that section. We can use PEiD and PEview together to view the raw data where the entry point begins. (Why this might be helpful, I don’t know; it is, however, interesting to me.)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2019/0302/09_EntryPointRaw.PNG&quot; alt=&quot;name&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Notice that I needed to click the RVA button on PEview to get the corresponding entry point from PEiD to show up properly.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Prediction: Entry points &lt;em&gt;should&lt;/em&gt; point to the .text section of an unpacked, unobfuscated binary– even if the binary is malicious.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Raw sizes of 0 for sections (such as section UPX0) that have large virtual sizes is strange.
    &lt;ul&gt;
      &lt;li&gt;Prediction: this is indicative of where the code is unpacked to at runtime.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Normal behavior seems to indicate that the raw sizes and the virtual sizes of sections are about the same with the virtual size being slightly smaller than the raw size.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;an-unpacked-malicious-executable&quot;&gt;An unpacked, malicious executable&lt;/h3&gt;

&lt;p&gt;I’ve obtained a sample of cryptomining malware from VirusShare named VirusShare_3864106aa2b5e35062b436a39ad83382. It’s, as far as I can tell prior to now, unpacked. Will our observations about the nature of packed vs. unpacked executables thus far confirm this suspicion?&lt;/p&gt;

&lt;p&gt;PEiD says its entry point is within the .text section, which corresponds to observations above.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2019/0302/10_1-38641.PNG&quot; alt=&quot;name&quot; /&gt;&lt;/p&gt;

&lt;p&gt;However, it has some strange section properties.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2019/0302/11_2-38641.PNG&quot; alt=&quot;name&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2019/0302/12_3-38641.PNG&quot; alt=&quot;name&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This executable has some special sections:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;.data: initialized data&lt;/li&gt;
  &lt;li&gt;.idata: Import tables&lt;/li&gt;
  &lt;li&gt;.rdata: read-only initialized data&lt;/li&gt;
  &lt;li&gt;.text: exectuable code&lt;/li&gt;
  &lt;li&gt;.tls section: thread local storage&lt;/li&gt;
  &lt;li&gt;.CRT: a strange section that isn’t microsoft-specific&lt;/li&gt;
  &lt;li&gt;Mystery sections with little data in their names&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The .data section contained nothing of interest– just mangled junk. I’m sure it’s not actually junk, but I can’t derive anything meaningful from it.&lt;/p&gt;

&lt;p&gt;The .idata section, however, does. This makes sense since it is supposed to store imports.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2019/0302/13_idata-38641.PNG&quot; alt=&quot;name&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The .rdata section has some interesting content as well. It looks like error messages. Makes sense as to why it’s read only, I suppose.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2019/0302/14_rdata-38641.PNG&quot; alt=&quot;name&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The .text section contains the entry point. Interestingly, this section is very, very small– both raw and virtual.&lt;/p&gt;

&lt;p&gt;The .tls section is small and contains very little actual content. I don’t know if this is normal or not, but at the moment, I’m also not really that concerned about it.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2019/0302/15_tls-38641.PNG&quot; alt=&quot;name&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The .CRT section is very small and contains little content as well. However, I found &lt;a href=&quot;https://docs.microsoft.com/en-us/cpp/c-runtime-library/crt-library-features?view=vs-2017&quot;&gt;this link&lt;/a&gt; that makes me suspect it has something to do with running C runtime functions. This suspicion is furthered by the fact that prior sections have lots of C-esque function names and error messages and etc etc.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2019/0302/16_crt-38641.PNG&quot; alt=&quot;name&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The rest of the sections had some very interesting content. After scrolling through the second unnamed section for like four seconds, I noticed lots of different types of compilation strings apparently stored in this section. Lots of references to MinGW indicate that was the compiler used to create this executable. The highlighted portion of the next page tells me the path this dude had his source code on and that the code was named “natstart.c.”&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2019/0302/17_strangesection1.PNG&quot; alt=&quot;name&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Other sections were hit or miss. Nothing immediately gave away that this file was malware, at least in my eyes. However, I think it’s fair to presume this file is not packed.&lt;/p&gt;

&lt;h3 id=&quot;looking-at-a-purposely-protected-sample-of-malware&quot;&gt;Looking at a purposely protected sample of malware&lt;/h3&gt;

&lt;p&gt;My last post is incomplete; it remains that way because I was defeated by the packer. The previous post features sample VirusShare_31adfc123d1b85d3f0d43f8401dcd042– a sample protected with Enigma Protector v1.1. Maybe some of what I observed by watching it partially unpack will help me understand what its metadata looks like.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2019/0302/18_31adfPEiDoverview.PNG&quot; alt=&quot;name&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I got distracted with looking at the file in PEview, however. I know that Ida tells you when the import table appears to be destroyed (which is often the case with packed malware). So I found where the import table is marked as being, according to the file headers:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2019/0302/19_31adfimportloc.PNG&quot; alt=&quot;name&quot; /&gt;&lt;/p&gt;

&lt;p&gt;And headed to that part of the file, which was in an unnamed section:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2019/0302/20_31adfimports.PNG&quot; alt=&quot;name&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The imports just seem a little offset. Clearly there are some import strings a ways below. 
For comparison’s sake, this is what Notepad++’s import table looks like, at the address specified in its headers (that is, 0x1EC7B4):&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2019/0302/21_nppimportsstart.PNG&quot; alt=&quot;name&quot; /&gt;&lt;/p&gt;

&lt;p&gt;There’s nothing of any meaning there. However, scrolling down a little reveals MANY imports:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2019/0302/22_nppimports2.PNG&quot; alt=&quot;name&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Again, for comparison, Wireshark imports start at 0x5b842c:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2019/0302/23_wiresharkimports.PNG&quot; alt=&quot;name&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Unfortunately, I see no way to quickly identify a mangled import table from a clean one. Enough with PEview. I proceeded to look at the sections using PEiD:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2019/0302/24_31adfsectionsPEiD.PNG&quot; alt=&quot;name&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Yet again, we have sections with much larger virtual sizes than raw sizes. This seems to be a tried-and-true sign of packers (or at least ones that are applied to full exectuables and not the nasty partially-unpacking ones). If I had to guess, I should look for unpacked code in the unnamed section between .rsrc and .data because that section is MUCH larger than the rest. However, the first one doubles in size too…&lt;/p&gt;

&lt;p&gt;Last post I found two unpacking loops that were simple and easy to follow. I believe these are unpacked in the second and third respectively unnamed sections. It would be interesting to follow the unpacking process in OllyDbg again and see if I can observe some notion as to if this is the case. Perhaps I’ll leave that to the next blog post.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;This article was all about exploring the PE file structure and observing how packers manipulate the headers and data values to conceal, and therefore indicate, the existence of nefarious deeds. While I still have questions to answer, I believe this post was a great start to further understanding how all of this works together.&lt;/p&gt;

</description>
        <pubDate>Sat, 02 Mar 2019 14:24:00 -0700</pubDate>
        <link>http://localhost:4000/PE_FF_Exploration</link>
        <guid isPermaLink="true">http://localhost:4000/PE_FF_Exploration</guid>
        
        
        <category>PE32</category>
        
      </item>
    
      <item>
        <title>Cryptomining Malware Sample Analysis 1: 31ADF</title>
        <description>&lt;p&gt;I recently gained access to VirusShare and downloaded 65,536 samples (00353.zip, for those interested). Due to my inability to search the way I expected to be able to for specific kinds of samples on VirusShare’s website, I decided to download this massive corpus of malware and search for the samples I seek out within it. For my thesis, I need:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Cryptomining malware &lt;em&gt;executable&lt;/em&gt; assets/images/posts (i.e. not HTML scripts, which is what most of the malware in this corpus is)&lt;/li&gt;
  &lt;li&gt;Banking trojans (emotets do the trick just fine)&lt;/li&gt;
  &lt;li&gt;Ransomware (gandcrab, kryptik, etc)&lt;/li&gt;
  &lt;li&gt;Maybe some adware&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now, when we download the samples, we are given the assets/images/posts named in the format VirusShare_[md5sum of file here]. That’s it. We have no notion as to what kind of malware each file is. So, I wrote a python script that used VirusTotal’s api to obtain known information on the samples, and store it in a local database. I store this information, per sample, in the database:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;file name&lt;/li&gt;
  &lt;li&gt;file type (exe and kind of exe, html, word doc, pdf, etc)&lt;/li&gt;
  &lt;li&gt;file hash (md5 or sha256)&lt;/li&gt;
  &lt;li&gt;positives (i.e. how many antivirus vendors marked it as malicious)&lt;/li&gt;
  &lt;li&gt;total (i.e. how many antivirus vendors have information on the file)&lt;/li&gt;
  &lt;li&gt;results (i.e. the tags that antivirus vendors have assigned the file)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Doing this enabled me to search the malware metainformation database for the kind of malware I need. My goals are to run through this malware and identify mining routines within it. Overall, I strive to find what differs and what doesn’t differ between these mining executables, in hopes that I’ll be able to augment a visualization tool with features that help identify when its analyzing a cryptomining sample, as opposed to some other kind of sample. More on that later.&lt;/p&gt;

&lt;p&gt;My search in the SQL database turned up 30 or so different samples of all kinds of executable formats. We have PE32 EXEs, PE32+ EXEs (i.e. 64-bit portable executables), ELF 64-bit executables, and some Windows DLLs. The first one of interest to me is VirusShare_31ADFC123D1B85D3F0D43F8401DCD042.&lt;/p&gt;

&lt;p&gt;First thing first: CFFExplorer.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/31ADFsc/1_dowland.GIF&quot; alt=&quot;CFFExplorer&quot; /&gt;&lt;/p&gt;

&lt;p&gt;“Dowland and Start.exe”. Nice. After a quick google search, I found that &lt;a href=&quot;https://winworldpc.com/product/delphi/4x&quot;&gt;Borland Delphi&lt;/a&gt; is a development environment for Pascal, released in 1998.&lt;/p&gt;

&lt;p&gt;Next up, the obligatory VT search:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/31ADFsc/2_VT.PNG&quot; alt=&quot;VT&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/31ADFsc/3_VT2.PNG&quot; alt=&quot;VT2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/31ADFsc/4_VT3.PNG&quot; alt=&quot;VT3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;It looks like a coinminer, and it also looks packed (as VT hints towards). Sadly, PEiD helps confirm this. Furthermore, after clicking a link in a comment from some dude on VT, I found that &lt;a href=&quot;https://www.hybrid-analysis.com/sample/6a17224be680f1a51d28574b885e0ca54f4dc30af8d0004442cb6c806d2acb01?environmentId=120&quot;&gt;hybrid-analysis&lt;/a&gt; further confirms it’s Enigma– specifically, v1.1 (wow this dude is out of date).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/31ADFsc/5_PEiD.PNG&quot; alt=&quot;PEiD&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Raw section sizes of 0 and virtual section sizes of &amp;gt;0 are very suspicious. Opening it in Ida resulted in a notification that the Imports section is destroyed, which is further evidence that this thing is packed. However, Ida helped identify a potential saving grace:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/31ADFsc/6_Ida.PNG&quot; alt=&quot;6_Ida&quot; /&gt;&lt;/p&gt;

&lt;p&gt;All the jump instructions visible to Ida were to local locations, except for the very last one, which jumps to who knows where. This is very exciting because it means OllyDbg’s “find OEP by Section Hop” feature may work!&lt;/p&gt;

&lt;p&gt;But sadly, it did not. Enigma protector appears to be powerful. My mentors haven’t played with Enigma and I can’t find any easily available unpacking tools. Guess it’s time to try manually unpacking my first live sample!&lt;/p&gt;

&lt;p&gt;I will be using OllyDbg to debug this. If you haven’t seen my &lt;a href=&quot;https://nexusmaximus.github.io/notes/2018/10/12/ch9_PMA_notes.html&quot;&gt;posts on OllyDbg&lt;/a&gt; or my &lt;a href=&quot;https://nexusmaximus.github.io/notes/2018/10/15/ch18_PMA_notes.html&quot;&gt;posts on unpacking&lt;/a&gt;, check those out.&lt;/p&gt;

&lt;p&gt;Upon opening this in OllyDbg (while also having it open in Ida), notice the similarities between instruction addresses.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/31ADFsc/7_IdaInitial.PNG&quot; alt=&quot;7_IdaAddress&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/31ADFsc/8_OllyInitial.PNG&quot; alt=&quot;8_OllyInitial&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Thankfully, Ida and Olly’s addresses line up (at least relative to the last byte). Ida registers the first instruction at 0x74cda6 and Olly registers the first instruction at 0x102cda6. The first interesting bit of code occurs at &lt;strong&gt;0xf388&lt;/strong&gt;– our first XOR decode loop.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/31ADFsc/9_decode1.PNG&quot; alt=&quot;9_decode1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Note that this screenshot is after I have ran through one iteration of the loop. Things to notice:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;We XOR the contents of where EAX points to, with DL, 1 byte at a time.&lt;/li&gt;
  &lt;li&gt;ECX contains how many bytes we decode.&lt;/li&gt;
  &lt;li&gt;Decoded code begins starting at Olly address 0x146f397.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Before much has been decoded, notice the presence of garbage (as is indicated by processing the data as instructions and seeing that the instructions are .. meaningless):&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/31ADFsc/10_decode2.PNG&quot; alt=&quot;10_decode2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;After a few iterations, we see new instructions now exist.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/31ADFsc/11_decode3.PNG&quot; alt=&quot;11_decode3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;One big giveaway that this is important and meaningful code is that it has jump instructions relative to the general area that this code is being decoded into.&lt;/p&gt;

&lt;p&gt;So, I set a hardware breakpoint on the jmp immediately after the JNZ and noted the final address of this loop’s unpacked code: 0x146f94F. Range: 0x146f397-0x146f94f; however we jump to 0x146f39b. Luckily after two instructions, the disassembly in the top left window and in the bottom left window match back up; a sign that the dump is disassembling instructions properly (and is not offset by disassembling in the middle of an instruction).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/31ADFsc/12_decode4.PNG&quot; alt=&quot;12_decode4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Follow on through, not really positive exactly what’s happening but also not caring… and we arrive at decode loop 2. This one decodes 4 bytes at a time, and a lot more! Thank goodness.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/31ADFsc/13_decodeloop2.PNG&quot; alt=&quot;13_decodeloop2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Range of decode: 0x138e269-(0x138e269 + (ECX = 0x38426 * 4))&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/31ADFsc/14_predecode2.PNG&quot; alt=&quot;14_predecode2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;after some iterations…&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/31ADFsc/15_postdecode2.PNG&quot; alt=&quot;15_postdecode2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Sketchy. So I decoded the rest of it and broke at the instruction immediately after.&lt;/p&gt;

&lt;p&gt;0x138e269-0x146f301 is the value of this decode loop’s range. Still below the previous unpacking loop’s range; that code has not been overwritten.&lt;/p&gt;

&lt;p&gt;Following it a little more… it jumps to 146f4aa which looks an awful lot like a generic function prelude.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/31ADFsc/16_functionpreludemaybe.PNG&quot; alt=&quot;16_funcprelude&quot; /&gt;&lt;/p&gt;

&lt;p&gt;After this, things kind of go awry. It gets much harder to follow. It is modifying 110e000 and onwards (to about 110f000). Then it looks like another phase begins.&lt;/p&gt;

&lt;p&gt;I noticed that for the last few thousand instructions, EIP never left the range 146f400-146f650.&lt;/p&gt;

&lt;p&gt;146f4ce-ish: an add that is probably checked&lt;/p&gt;

&lt;h4 id=&quot;notes&quot;&gt;notes&lt;/h4&gt;

&lt;p&gt;102cda6: start&lt;/p&gt;

&lt;p&gt;0x110e000-0x110f000: mystery region. Not sure what’s happening but it’s being heavily modified by code in 146f400-146f650ish.&lt;/p&gt;

&lt;p&gt;0x138e269-146f301: second unpacked region&lt;/p&gt;

&lt;p&gt;0x146f397-146f94f: first unpacked region&lt;/p&gt;

</description>
        <pubDate>Tue, 19 Feb 2019 13:31:00 -0700</pubDate>
        <link>http://localhost:4000/Cryptomining_malware_1_31adf</link>
        <guid isPermaLink="true">http://localhost:4000/Cryptomining_malware_1_31adf</guid>
        
        
        <category>binary_analysis</category>
        
      </item>
    
      <item>
        <title>Notes on Binary Instrumentation and Intel PIN</title>
        <description>&lt;p&gt;Binary instrumentation is a technique that inserts extra code into a program to collect runtime information, as defined by &lt;a href=&quot;http://www.ic.unicamp.br/~rodolfo/mo801/04-PinTutorial.pdf&quot;&gt;this source&lt;/a&gt;. &lt;a href=&quot;https://software.intel.com/en-us/articles/pin-a-dynamic-binary-instrumentation-tool&quot;&gt;Intel PIN&lt;/a&gt; provides a rich library used to do just this.&lt;/p&gt;

&lt;p&gt;Pin is the library provided by Intel to do instrumentation. Instsrumentation is conducted by inserting monitoring code into running executables. To do this, Pin makes use of Pintools, which  can be thought of as plugins that can modify the code generation process inside Pin. Pintools comprise two key components:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;A mechanism taht decides where and waht code is inserted, and&lt;/li&gt;
  &lt;li&gt;The code to execute at insertion points.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Youtube &lt;a href=&quot;https://www.youtube.com/watch?v=kurzaoWuSHA&quot;&gt;link&lt;/a&gt; of someone setting up and using a tracer pintool to monitor Windows API calls (and more).&lt;/p&gt;

&lt;h2 id=&quot;terminology&quot;&gt;Terminology&lt;/h2&gt;

&lt;h2 id=&quot;steps&quot;&gt;Steps&lt;/h2&gt;
&lt;p&gt;Downloaded PIN: https://software.intel.com/en-us/articles/pin-a-binary-instrumentation-tool-downloads&lt;/p&gt;

&lt;p&gt;Worked on downloading dependencies.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Cygwin: https://www.techspot.com/downloads/6590-cygwin.html
    &lt;ul&gt;
      &lt;li&gt;just ‘next’-ed through all the defaults&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 13 Dec 2018 11:31:00 -0700</pubDate>
        <link>http://localhost:4000/binary_instrumentation</link>
        <guid isPermaLink="true">http://localhost:4000/binary_instrumentation</guid>
        
        
        <category>notes</category>
        
      </item>
    
      <item>
        <title>Paper review: Binary-Code Obfuscations in Prevalent Packer Tools</title>
        <description>&lt;h2 id=&quot;abstract&quot;&gt;Abstract&lt;/h2&gt;

&lt;p&gt;Security analysts’ understanding of malware samples depends on the ability to build high-level analysis products from the raw bytes of program binaries. As such, the first step to analyzing defensive malware samples is understanding what obfuscations are present in these binaries, and how the obfuscations hinder analysis. This paper provides details on those techniques.&lt;/p&gt;

&lt;p&gt;Section 2 is all about the methodology and tools used to perform the study. Section 3 is a taxonomy of the obfuscation techniques, along with current approaches to dealing with the techniques. Section 4 provides a summary table of the obfuscation techniques that shows their relative prevalence in real-world malware.&lt;/p&gt;

&lt;h2 id=&quot;section-2-methodology&quot;&gt;Section 2: Methodology&lt;/h2&gt;

&lt;p&gt;– to be written, maybe –&lt;/p&gt;

&lt;h2 id=&quot;section-3-obfuscation-techniques&quot;&gt;Section 3: Obfuscation techniques&lt;/h2&gt;

&lt;h3 id=&quot;binary-code-extraction&quot;&gt;Binary code extraction&lt;/h3&gt;
&lt;p&gt;This is the ultimate goal of analysis– to extract the code from a sample so it can be analyzed. On unpacked/nondefensive binaries, this is trivial, as we simply need to read from the executable portions of the binary file. It gets more challenging with programs that create code or self-modify at runtime.&lt;/p&gt;

&lt;p&gt;In practice, most malware authors create an unpacked executable and then pack it with a packer tool to create a packed version. Most packers can be thought of as elaborations on UPX’s packing scheme.&lt;/p&gt;

&lt;h4 id=&quot;how-upx-works&quot;&gt;How UPX works&lt;/h4&gt;

&lt;p&gt;UPX (or almost any other packing tool) sets the executable’s entry point to the entry point of the bootstrap code that unpacks the payload and then transfers control to the payload’s OEP. When the bootstrap code unrolls packed code and data, it places them at the same memory addresses that they occupied in the original binary, so that position-dependant instructions do not move and data accesses find the data in their expected locations.&lt;/p&gt;

&lt;p&gt;UPX also packs the PE’s Import Table and Import Address Table data structures. These tables list functions to import from other shared libraries. They are packed because just knowing these functions can reveal significant information about the payload code (and also because the tables are highly amenable to compression).&lt;/p&gt;

&lt;h4 id=&quot;building-on-this-technique&quot;&gt;Building on this technique&lt;/h4&gt;

&lt;p&gt;The most common elaboration of this basic recipe is one in which portions of the packer’s bootstrap code itself are also packed. Most packers use a small unpacking loop to decompress a more sophisticated decompression or decryption algorithm that unpacks the actual payload. For example, ASProtect unpacks 99% of its unpacking code, in addition to the program payload itself.&lt;/p&gt;

&lt;h4 id=&quot;the-x-ray-technique-perriot-and-ferrie-2004&quot;&gt;The X-Ray technique [Perriot and Ferrie 2004]&lt;/h4&gt;

&lt;p&gt;This technique statically analyzes the program binary with the aim of seeing through the compression and encryption transformation with which the payload code is packed. It leverages statistical properties of packed code to recognize compression algorithms and uses &lt;em&gt;known cipher-text attacks&lt;/em&gt; to crack weak encryption schemes. Weakness: ineffective against strong encryption and multiple layers of compression or encryption. Further work has been done to improve the technique, but it hasn’t yet been shown to work on a broad collection of samples (as of when this paper was written, in 2013).&lt;/p&gt;

&lt;h4 id=&quot;identifying-written-then-executed-code&quot;&gt;Identifying written-then-executed code&lt;/h4&gt;

&lt;p&gt;This technique is used by a host of dynamic analysis tools. They detect and capture unpacked code bytes by tracing the program’s execution at a fine granularity and logging memory writes to identify written-then-executed code. Some leverage the Qemu whole-system emulator and the Xen virtual machine monitor respectively, which allows them to observe execution of monitored malware without being easily detected. [2007ish time frame– Renovo and EtherUnpack]&lt;/p&gt;

&lt;p&gt;There exist unpacker tools that run packed programs either for a certain timeout period, or until they exhibit behavior that could indicate that they are done unpacking. The primary limitations of fine-grained monitoring techniques are that they only identify code bytes that are actually executed and they incur orders of magnitude slowdowns in execution time (those conditional breakpoints tho). This technique is good for antivirus products, but the coarse memory-page granularity means they cannot identify the actual code bytes on unpacked code pages and they cannot identify or capture overwritten code bytes.&lt;/p&gt;

&lt;h4 id=&quot;code-overwriting&quot;&gt;Code Overwriting&lt;/h4&gt;

&lt;p&gt;Self-modifying programs move beyond unpacking by overwriting existing code with new code at runtime. Code overwriting often occurs in small amounts, affecting just a single instruction or even just a single instruction operand. For example, ASPack modifies the push operand of a &lt;code class=&quot;highlighter-rouge&quot;&gt;push 0, ret&lt;/code&gt; instruction sequence at runtime to plug in the OEP address onto the call stack. UPack, however, has a second unpacking loop that overwrites the first one, removing several basic blocks at once from the function currently executing.&lt;/p&gt;

&lt;p&gt;Packers surveyed in this paper only overwrite their own metacode, but it’s possible to have more complex overwriting scenarios. Packers generally probably only overwrite their own code in an effort to maintain correctness and to be able to be used in a general case (i.e. for any malicious binary passed to it). An example of more complex unpackers: the MoleBox packer tool and the DarkParanoid virus repeatedly unpack sensitive code into a buffer, so only one buffer-full of the protected code is exposed to the analyst at any given time. This approach is sufficiently hard to implement, however, according to a paper in 2002.&lt;/p&gt;

&lt;p&gt;Self-modifying code presents a problem to all approaches of anlaysis because there is no point in time in which all of the program’s code is present in the binary. The only way to account for this is to take snapshots of basic blocks (i.e those without jumps in our out) as soon as the basic blocks execute.&lt;/p&gt;

&lt;h3 id=&quot;disassembly&quot;&gt;Disassembly&lt;/h3&gt;

&lt;p&gt;Once code bytes have been captured, static analysis techniques can accurately disassemble most of the code in compiler-generated program binaries, even when those binaries have been stripped of all symbol information. The general technique employed by disassembly tools is to disassemble the binary code starting from known entry points into the program.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Linear-sweep parsing&lt;/em&gt; disassembles sequentially from the beginning of the code section and assumes that the section contains nothing but code. The problem with this is the code section frequently contains non-code bytes such as string data and padding.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;recursive-traversal approach&lt;/em&gt; finds instructions by following all statically traversable paths through the program’s control flow starting from known function addresses. While more accurate, this technique misses control-transfer targets of instrucions that determine their targets dynamically based on register values and memory contents. 
Binaries stripped of symbol information can still have machine learning techniques applied to them to identify enough function entry points (by recognizing compiler-generated boiler plate code) to help recursive-traversal parsing. 
Of course, the weakness behind this approach is that the malware author would only need to modify the boiler-plate code of the compiler to trick the machine learning algorithms expecting a specific instruction pattern. 
Furthermore, to limit the amount of code that can be found by following control-transfer edges from the entry point (which must be left visible in the binary, or the OS can’t begin executing it), one can handwrite extremely irregular assembly code that a parser will have significant trouble interpreting.&lt;/p&gt;

&lt;p&gt;Here are some techniques that hide code, followed by techniques that corrupt analysis with non-code bytes or uncover errors in the disassembler.&lt;/p&gt;

&lt;h4 id=&quot;non-returning-calls&quot;&gt;Non-returning Calls&lt;/h4&gt;

&lt;p&gt;A &lt;code class=&quot;highlighter-rouge&quot;&gt;call&lt;/code&gt; instruction is basically a glorified &lt;code class=&quot;highlighter-rouge&quot;&gt;jmp&lt;/code&gt; instruction. Its job is to push a return location onto the stack, and then jump to another section of code. It is intended to be used with a corresponding &lt;code class=&quot;highlighter-rouge&quot;&gt;ret&lt;/code&gt; instruction, which pops the previously-pushed value into a register or area in memory and unconditionally jumps to it. This can be abused by, well, using the instructions in unconventional ways. This causes problems for analysis tools in three ways.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Recursive-traversal parsers assume that bytes following a non-returning call represent a valid instruction, because they presume the call will return execution to the area immediately after the call, but it doesn’t need to.&lt;/li&gt;
  &lt;li&gt;The attack breaks an important assumption made by code parsers for identifying function boundaries; namely, that the target of a call belongs to a different function than that of the call itself. There’s no reason why you can’t use a call to transfer execution somewhere else in the current function.&lt;/li&gt;
  &lt;li&gt;A binary instrumenter cannot move the call instruction of a call-pop sequence without changing the PC-relative address that the pop stores into a general-purpose register. Moving the call instruction without compensating for this change usually results in incorrect program execution, as packer metacode frequently uses the PC-relative address as a base pointer from which to access data.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Researchers have proposed removing the assumption that there is valid code at the fall-through address of each call instruction, but doing so drastically reduces the percentage of code that the parser can find, presumably since it can no longer be assumed that any code after a call is actually code. Kruegel et al. compensate by speculatively parsing after call instructions and use a statistical model of real code sequences to determine whether the speculatively parsed instruction sequences are valid. However, this technique was done by researchers in an attempt to just handle one kind of obfuscator, and made assumptions that were valid only for that obfuscator.&lt;/p&gt;

&lt;h4 id=&quot;call-stack-tampering&quot;&gt;Call-stack Tampering&lt;/h4&gt;

&lt;p&gt;One can semantically generate a &lt;code class=&quot;highlighter-rouge&quot;&gt;jmp&lt;/code&gt; instruction with a &lt;code class=&quot;highlighter-rouge&quot;&gt;push [value], ret&lt;/code&gt; combination, since &lt;code class=&quot;highlighter-rouge&quot;&gt;ret&lt;/code&gt; pops and jumps. ASProtect does this frequently. Furthermore, you could have this series of instructions:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pop ebp
inc ebp
push ebp
ret
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This would jump to an area immediately after a call, offset by +1 bytes, which would totally break the assumption that code &lt;strong&gt;immediately&lt;/strong&gt; following a &lt;code class=&quot;highlighter-rouge&quot;&gt;call&lt;/code&gt; is valid, since the valid code is now offset by an amount.&lt;/p&gt;

&lt;p&gt;The authors of this paper implement a technique to deal with this. They apply static analysis techniques to a &lt;code class=&quot;highlighter-rouge&quot;&gt;ret&lt;/code&gt; target prediction, which allows them to improve coverage and accuracy of pre-execution analyses. They use backwards slices at return instructions to determine whether a  &lt;code class=&quot;highlighter-rouge&quot;&gt;ret&lt;/code&gt; jumps to a function’s return address as expected or to another address, and falls back on dynamic analysis if static analysis fails.&lt;/p&gt;

&lt;h4 id=&quot;obfuscated-control-transfer-targets&quot;&gt;Obfuscated control-transfer targets&lt;/h4&gt;

&lt;p&gt;Using indirect versions of the &lt;code class=&quot;highlighter-rouge&quot;&gt;call&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;jmp&lt;/code&gt; instructions obfuscates control-transfer targets by using register or memory values to determine their targets at runtime. Furthermore, it provides some space savings, which is significant motivation for small packers. Obfuscation is also a considerable motivating factor as static analysis tools often let these jumps go unresolved. Single indirect jumps can have multiple targets as well over the course of an unpacker’s runtime lifetime.&lt;/p&gt;

&lt;p&gt;Static analysis of indirect control-transfer targets is particularly difficult in packed binaries, as they frequently use instructions whose targets depend on register values. Value-set analyses [Balakrishnan and Reps 2004] can theoretically reveal all possible targets for such indirect control-transfer instructions, but this requires knowing all the code in the binary, which is not a satisfiable condition in the realm of packed binaries. Dynamic analysis trivially discovers targets of indirect control transfers that execute, but may leave a significant fraction of code unexecuted. There has been research done on forcing program execution down multiple execution paths [Babic et. al. 2011; Moser et al. 2007] but these are extremely resource-intensive techniques and do not acheive perfect code coverage.&lt;/p&gt;

&lt;h4 id=&quot;exception-based-control-transfers&quot;&gt;Exception-based control transfers&lt;/h4&gt;
&lt;p&gt;Signal- and exception-handling mechanisms allow for the creation of obfuscated control transfers whose source instruction and target address are well-hidden from static analysis techniques. Statically identifying sources of control transfers such as these requires predicting which instructions will raise exceptions, which is difficult in theory and practice [Muth and Debray 2000]. This means current disassembly algorithms wil usually parse through fault-raising instructions into what may be non-code bytes that’ll never execute. Furthermore, at least on Windows, it is hard to find exception handlers, since they can be registered on the call stack at runtime with no need to perform any Windows API or system calls.&lt;/p&gt;

&lt;p&gt;Using a debugger is the easiest way to detect exception-based control transfers, as it informs the debugger process of any fault-raising instructions and identifies all registered exception handlers whenever a fault occurs. However, use of a debugger interface can be detectd unless extensive precautions are taken.&lt;/p&gt;

&lt;h4 id=&quot;ambiguous-code-and-data&quot;&gt;Ambiguous code and data&lt;/h4&gt;

&lt;p&gt;Yet another form of control flow obfuscation involves using conditional branches to introduce a fork in the program’s control flow with only one path that ever executes, while junk code (fake code bytes or non-code) populates the other path.&lt;/p&gt;

&lt;p&gt;Using current techniques, the only way to identify code with perfect exclusion of data is to disassemble only those instruction sthat appear in an execution trace of a program.&lt;/p&gt;

&lt;h4 id=&quot;disassembler-fuzz-testing&quot;&gt;Disassembler Fuzz Testing&lt;/h4&gt;
&lt;p&gt;Fuzz testing refers to the practice of stress testing a software component by feeding it large quantities of unusual inputs int eh hope of detecting a case that the component hadles incorrectly. By fuzz testing binary-code disassemblers, packer tools can cause the diassembler to misparse instructions or mistake valid instructions for invalid ones.&lt;/p&gt;

</description>
        <pubDate>Sat, 10 Nov 2018 10:31:00 -0700</pubDate>
        <link>http://localhost:4000/binary-code_obfs_paper_review</link>
        <guid isPermaLink="true">http://localhost:4000/binary-code_obfs_paper_review</guid>
        
        
        <category>notes</category>
        
      </item>
    
      <item>
        <title>Evading OllyDump's 'Find OEP by Section Hop' feature</title>
        <description>&lt;h2 id=&quot;ollydump&quot;&gt;OllyDump&lt;/h2&gt;

&lt;p&gt;One of the best tools in the malware analyst’s toolbox is OllyDbg’s ‘OllyDump’ plugin. It sports the ability to dump a debugged program’s memory, meaning if you can unpack a packed executable up to the point in which it transfers execution to the malicious payload, OllyDump can write out that program to a file that you can further analyze. This point in execution is called the &lt;em&gt;original entry point&lt;/em&gt;, or OEP. The jump that the program makes from unpacking code to execution of the malicious payload is called the &lt;em&gt;tail jump&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&quot;finding-the-oep-by-section-hop&quot;&gt;Finding the OEP by section hop&lt;/h3&gt;
&lt;p&gt;Finding the OEP of a program isn’t always trivial. That’s why OllyDump provides two methods that can be used to help you. Labeled “Find OEP by Section Hop,” OllyDump creates a conditional breakpoint that monitors the section of the executable that is currently executing. When execution hops out of that section, the breakpoint triggers. Often times, the section will change when making the tail jump, since the malicious payload likely won’t be in the same section as the unpacker code. OllyDump has two versions of this functionality: a trace over feature and a trace into feature. From what I understand, the trace over feature won’t monitor section transfers within calls. For example, if the code you’re looking at calls a library function, the EIP will definitely be out of range of the current section, but Trace Over won’t trigger a break in execution. Trace into will, however. As such, Trace Into goes into more depth, but can also churn out more false positives. Trace Over goes into less depth, but is less likely to churn out false positives. Each is useful in certain situations. Sometimes using a combination of both is the best strategy. Sometimes, neither one will work well.&lt;/p&gt;

&lt;h3 id=&quot;evading-this-tool&quot;&gt;Evading this tool&lt;/h3&gt;
&lt;p&gt;So, how can malware nullify these tools? I can think of a couple ways:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;If the unpacking stub is contained within two or more sections and transfers execution between them frequently. Then, the section would change frequently, causing both versions of the section hop feature to trigger. Of course, this could be combatted by adding a multi-section conditional check, but I don’t believe this feature is currently available within OllyDump.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Self-modifying code/partially unpacking malware will cause problems. If the code only partially unpacks itself into memory, we may find the section in which it executes using OllyDump’s features, but we can’t dump the file into a complete executable at any given moment in time.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In order to further understand how to get around this technique, it will pay to read up on general obfuscation techniques. That will, in turn, lead me to theorize about which can be detected with OllyDbg and which can’t.&lt;/p&gt;

&lt;h3 id=&quot;details-on-how-a-few-common-packers-work-and-how-to-augment-ollydumps-find-oep-by-section-hop-functionality-to-be-able-to-handle-these-packers&quot;&gt;Details on how a few common packers work, and how to augment OllyDump’s “Find OEP by section hop” functionality to be able to handle these packers&lt;/h3&gt;

&lt;h4 id=&quot;fsg-fast-small-good&quot;&gt;FSG: FAst, Small, Good&lt;/h4&gt;

&lt;h4 id=&quot;upx-ultimate-packer-for-executables&quot;&gt;UPX: Ultimate Packer for eXecutables&lt;/h4&gt;

&lt;h4 id=&quot;upack&quot;&gt;UPack&lt;/h4&gt;

&lt;h4 id=&quot;polyene&quot;&gt;PolyEnE&lt;/h4&gt;

&lt;h4 id=&quot;mew&quot;&gt;MEW&lt;/h4&gt;

&lt;h4 id=&quot;pecompact&quot;&gt;PECompact&lt;/h4&gt;

&lt;h4 id=&quot;nspack&quot;&gt;NSPack&lt;/h4&gt;

&lt;h4 id=&quot;npack&quot;&gt;nPack&lt;/h4&gt;

&lt;h4 id=&quot;aspack&quot;&gt;ASPack&lt;/h4&gt;

&lt;h4 id=&quot;petite&quot;&gt;PEtite&lt;/h4&gt;

&lt;h4 id=&quot;yodas-protector&quot;&gt;Yoda’s Protector&lt;/h4&gt;

&lt;h4 id=&quot;asprotect&quot;&gt;ASProtect&lt;/h4&gt;

</description>
        <pubDate>Sat, 03 Nov 2018 14:31:00 -0600</pubDate>
        <link>http://localhost:4000/getting_around_section_hop</link>
        <guid isPermaLink="true">http://localhost:4000/getting_around_section_hop</guid>
        
        
        <category>notes</category>
        
      </item>
    
      <item>
        <title>PMA Ch.18 Labs: Packed Malware</title>
        <description>&lt;h2 id=&quot;lab-summary-questions&quot;&gt;Lab summary questions&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Considering malware analysis as a whole, how important is it to a general aspiring analyst to complete this chapter’s exercises?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What did doing the lab exercises teach that was not gained from reading the chapter?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;challenges-encountered-in-the-labs&quot;&gt;Challenges encountered in the labs&lt;/h2&gt;

&lt;h2 id=&quot;lab-walkthrough-includes-answers&quot;&gt;Lab Walkthrough (includes answers!)&lt;/h2&gt;

&lt;p&gt;The goal of each of these labs is to unpack the code for further analysis so that other static techniques can be used. Try to avoid using automated unpackers and use the skills taught in this chapter. Each lab is a packed version of a previous lab.&lt;/p&gt;

&lt;h3 id=&quot;181&quot;&gt;18.1&lt;/h3&gt;

&lt;p&gt;I opened the file in OllyDbg and Ida, and just tried OllyDump’s “Find OEP by section hop (trace over)” option. You can verify that the program is progressing by clicking in the registers window. If the registers update when you click, you know the plugin is working.&lt;/p&gt;

&lt;p&gt;After waiting about a minute, OllyDbg broke due to a conditional breakpoint: “EIP outside the range 407000…409FFF (i.e. a hop outside of that section). The code points directly to what looks like a function now located at 40154F.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/ch18sc/1_01unpacked.PNG&quot; alt=&quot;1_01unpacked.PNG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I used OllyDbg to dump the process (** plugins -&amp;gt; OllyDump -&amp;gt; Dump debugged process **) (no changes to the dump options screen) and loaded the new exe into Ida, and it appears to be a good-looking, unpacked sample.&lt;/p&gt;

&lt;h3 id=&quot;182&quot;&gt;18.2&lt;/h3&gt;

&lt;p&gt;Upon first opening this sample with Ida, we get a warning that said&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Truncated section &quot; at file offsets 0x1000..0x2000 
Will read 0x290 bytes
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;which I don’t understand, but that’s okay for now.&lt;/p&gt;

&lt;p&gt;Furthermore, when opening the file with OllyDbg, we get this message:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/ch18sc/2_02open.PNG&quot; alt=&quot;2_02open.PNG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Stepping through the code a few times yields a pretty obfuscated seeming loop pattern. I’m not sure what it’s doing or how it’s doing it, but the classic approach is to let Olly do that for you. So I did, and it broke here.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/ch18sc/3_wat.PNG&quot; alt=&quot;3_wat.PNG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This looks like data. Or perhaps it’s just in the data section of the executable. These are just bytes; let’s get Olly to interpret it as code: &lt;strong&gt;right click in the disassembly window -&amp;gt; analysis -&amp;gt; analyse code&lt;/strong&gt; and boom, there we are. A function.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/ch18sc/4_02unpacked.PNG&quot; alt=&quot;4_02unpacked.PNG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I dumped the program (default options) and opened the new executable in Ida, and it revealed something that looked similar to a ch7 sample analyzed earlier. Specifically the second lab.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/ch18sc/5_0702.PNG&quot; alt=&quot;5_0702.PNG&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;183&quot;&gt;18.3&lt;/h3&gt;

&lt;p&gt;I ran this file in OllyDbg and observed a pattern: it’s unpacking some code into another section, and then calling it, and that code unpacks some code into another section and then calls it, and etc. I bet this will mess with the &lt;code class=&quot;highlighter-rouge&quot;&gt;Find OEP by Section Hop&lt;/code&gt; functionality– at least the “step over” part, since calls don’t return to the right place (as that’s how it transfers execution– by pushing a new variable onto the stack and then calling a ‘ret’ (I believe)).&lt;/p&gt;

&lt;p&gt;Sections: 40Axxx, 407xxx, and some kernel calls. Arriving in these sections triggers OllyDump’s plugin to stop execution.&lt;/p&gt;

&lt;p&gt;And, after attempting to find the OEP by section hop, I discovered it does indeed render the technique much less helpful. I sort of stumbled through and kept trying it and it would run to the next point in the code that was out of the current section. Theoretically, I can keep doing this until I finally hit a breakpoint that doesn’t look like unpacking code, but I don’t know if this is the most helpful strategy. I continued trying to resume the code for a while (i.e. using OllyDump’s trace into feature and then OllyDbg’s execute until user code feature), and it beame clear to me that this strategy isn’t very feasible.&lt;/p&gt;

&lt;p&gt;I was hesitant to try the other “find section hop by jumping over” as I believe this code transfers execution by modifying where “ret” transfers execution to. In other words, we may have calls that never return to the instruction immediately after the call. Either way, I tried it, and it took me to a section that looks like data. I got Olly to treat it as code and disassemble it in the same way I did for the previous problem.&lt;/p&gt;

&lt;p&gt;As it turns out, this was indeed the entry point– 0x401577. I am wondering if using a combination of section jumps with trace over and with trace into is a viable strategy.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/ch18sc/6_ollyEntry3.PNG&quot; alt=&quot;6_ollyEntry3.PNG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Interestingly, after exporting the file with the EIP at this location, the imports section is still destroyed according to Ida, and furthermore, Ida’s disassembly code differs slightly (but makes more sense) than Olly’s.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/ch18sc/7_idaUnpacked3.PNG&quot; alt=&quot;7_idaUnpacked3.PNG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In either case, after looking around this file with Ida, it appears to look much more like non-unpacking code, which further confirms my suspicion that this is the payload we’re after.&lt;/p&gt;

&lt;h4 id=&quot;after-reading-the-book-answers&quot;&gt;After reading the book answers…&lt;/h4&gt;

&lt;p&gt;The book acknowledges a pushf and a pusha at the very, very beginning of the file. It suggests that a packer will likely have corresponding popa and popf instructions at the end of the unpacking loop, and suggests putting a breakpoint on access of that pushed memory. I tried this, and it worked great.&lt;/p&gt;

</description>
        <pubDate>Sun, 28 Oct 2018 12:31:00 -0600</pubDate>
        <link>http://localhost:4000/PMA_ch18_labs</link>
        <guid isPermaLink="true">http://localhost:4000/PMA_ch18_labs</guid>
        
        
        <category>labs</category>
        
      </item>
    
      <item>
        <title>PMA Ch.18 Notes: Packers and Unpacking</title>
        <description>&lt;h2 id=&quot;chapter-summary-questions&quot;&gt;Chapter summary questions&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;In two sentences or less, provide an overview of what this chapter is about.&lt;/li&gt;
  &lt;li&gt;What are the three most important takeaways from this chapter?&lt;/li&gt;
  &lt;li&gt;What problems does this chapter address? In other words, why should we care about this chapter?&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;overview-of-how-packing-works&quot;&gt;Overview of how packing works&lt;/h2&gt;
&lt;p&gt;Packers generally follow the same pattern: they transform (compress, encrypt, etc) an executable into raw data. This is the act of packing. Packers then prepend a valid executable (called an unpacking stub) to that data. The unpacking stub exists to decrypt or decode or unzip the packed portion of the executable into memory at run time, and then transfer execution to the unpacked code. This is significant because it conceals the program’s instructions to static analysis tools (excluding the instructions of the unpacking stub).&lt;/p&gt;

&lt;p&gt;To maintain the functionality of the original program, a packing program needs to store the program’s import information. The information can be stored in any format, and there are several common strategies which will be discussed later.&lt;/p&gt;

&lt;p&gt;Packers can pack the entire executable, including all data and the resource section, or they can pack only the code and data sections.&lt;/p&gt;

&lt;h2 id=&quot;the-unpacking-stub&quot;&gt;The Unpacking Stub&lt;/h2&gt;
&lt;p&gt;The purpose of the unpacking stub is typically to load the packed packed program, unpack it, resolve imports of the original executable, and transfer execution to the original entry point. It need not unpack the entire executable at any given point in time. Understanding how the stub works is almost always crucial to understanding the malware.&lt;/p&gt;

&lt;h2 id=&quot;resolving-imports&quot;&gt;Resolving imports&lt;/h2&gt;
&lt;p&gt;Because the Windows loader cannot read import information that is packed, the unpacking stub must resolve the imports. There are a few approaches that can be taken to do this.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Most common: have the unpacking stub import &lt;code class=&quot;highlighter-rouge&quot;&gt;LoadLibrary&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;GetProcAddress&lt;/code&gt; functions. After the unpacking stub unpacks the original executable, it reads the original import information, uses &lt;code class=&quot;highlighter-rouge&quot;&gt;LoadLibrary&lt;/code&gt; to load those libraries, and uses &lt;code class=&quot;highlighter-rouge&quot;&gt;GetProcAddress&lt;/code&gt; to get the address for functions in each library.&lt;/li&gt;
  &lt;li&gt;Another approach: Keep the imports table intact.&lt;/li&gt;
  &lt;li&gt;A third approach: keep one import function from each DLL in the original import table. In this case, &lt;code class=&quot;highlighter-rouge&quot;&gt;LoadLibrary&lt;/code&gt; will not be needed, but the stub will still need to resolve the other functions.&lt;/li&gt;
  &lt;li&gt;The final discussed approach is to remove all imports including &lt;code class=&quot;highlighter-rouge&quot;&gt;LoadLibrary&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;GetProcAddress&lt;/code&gt;. Then, the packer must find all functions needed from other libraries without using those functions, or it must find &lt;code class=&quot;highlighter-rouge&quot;&gt;LoadLibrary&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;GetProcAddress&lt;/code&gt; and then use them to load other libraries. This is the stealthiest method, but also the most difficult to implement.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;recognizing-packed-programs&quot;&gt;Recognizing packed programs&lt;/h2&gt;
&lt;p&gt;There are often giveaways that are indicative of a packed program.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;One sign is a program has few imports, and those imports are often just &lt;code class=&quot;highlighter-rouge&quot;&gt;LoadLibrary&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;GetProcAddress&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;When the program is opened in IDA, only a small amount of code is recognized by the automatic analysis.&lt;/li&gt;
  &lt;li&gt;When the program is opened in OllyDbg, there is a warning that the program is packed.
    &lt;ul&gt;
      &lt;li&gt;How does OllyDbg identify this? Do we even care in 64-bit land?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;The program shows section names that indicate a particular packer
    &lt;ul&gt;
      &lt;li&gt;What are section names typically for executables?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;the program has abnormal section sizes, such as a &lt;code class=&quot;highlighter-rouge&quot;&gt;.text&lt;/code&gt; section that has a raw size of 0 but a virtual size of nonzero.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;entropy-calculation&quot;&gt;Entropy Calculation&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;Entropy Calculation&lt;/em&gt; is a technique where packed executables can be detected based on the randomness of the executable. Encrypted or otherwise packed programs usually have high entropy.&lt;/p&gt;

&lt;h2 id=&quot;unpacking-executables&quot;&gt;Unpacking executables&lt;/h2&gt;
&lt;p&gt;Three options:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Automated static unpacking.&lt;/li&gt;
  &lt;li&gt;Automated dynamic unpacking.&lt;/li&gt;
  &lt;li&gt;Manual dynamic unpacking.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Manual static unpacking is completely infeasible.&lt;/p&gt;

&lt;h3 id=&quot;automated-static-unpacking&quot;&gt;Automated static unpacking&lt;/h3&gt;
&lt;p&gt;This is generally the best and fastest method, when it works, because it unpacks a program but does not run the unpacked program. Programs that perform automated static unpacking generally only work for one type of packer.&lt;/p&gt;

&lt;h3 id=&quot;automated-dynamic-unpacking&quot;&gt;Automated dynamic unpacking&lt;/h3&gt;
&lt;p&gt;These run the packed program and allow the unpacking stub to unpack the original executable code. Once the unpacking stub finishes, it writes the unpacked program to disk, and the unpacker reconstructs the import table.&lt;/p&gt;

&lt;p&gt;The unpacking program must determine where the unpacking stub ends and where the original executable begins, which is difficult.&lt;/p&gt;

&lt;p&gt;As of the time of this book’s writing, “there are no good publicly available automated dynamic unpackers.”&lt;/p&gt;

&lt;h3 id=&quot;manual-unpacking&quot;&gt;Manual unpacking&lt;/h3&gt;
&lt;p&gt;There are two common approaches to manually unpacking a program.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Discover the packing algorithm and write a program to run it in reverse. This is generally less efficient, but may be useful if dealing with many different executables that are packed in the same manner.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Run the packed program up to the point where the unpacking stub finishes and does the work for you, and then dump the process out of memory and manually fix up the PE header so that the program is complete.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;a-walkthrough-of-the-manual-unpacking-process-for-ideal-packed-executables&quot;&gt;A walkthrough of the manual unpacking process for ideal packed executables&lt;/h4&gt;

&lt;p&gt;The first step is to use the following workflow to see if OllyDbg’s OllyDump plugin can unpack the executable for you. To begin, open the packed program with OllyDbg.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Select &lt;strong&gt;Plugins -&amp;gt; OllyDump -&amp;gt; Find OEP by Section Hop&lt;/strong&gt;. Olly will hit a breakpoint just before the OEP executes. (It’s sort of slow to run, mind you!)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Write down where OllyDbg broke. This is the OEP.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Select &lt;strong&gt;Plugins -&amp;gt; OllyDump -&amp;gt; Dump Debugged Process.&lt;/strong&gt; This dumps everything from process memory to disk.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;using-import-reconstructor&quot;&gt;Using Import Reconstructor&lt;/h4&gt;

&lt;p&gt;If OllyDbg fails, you can try to use Import Reconstructor (ImpRec) to repair the import table for packed programs.In this case, see p390 for more details.&lt;/p&gt;

&lt;h4 id=&quot;how-ollydumps-find-oep-by-section-hop-tool-works&quot;&gt;How OllyDump’s Find OEP by Section Hop tool works&lt;/h4&gt;

&lt;p&gt;Normally, the unpacking stub is in one section and the executable is packed in another section. OllyDbg detects whenthere is a transfer from one section to another and breaks there, using either the step-over or step-into method.&lt;/p&gt;

&lt;p&gt;The step-over method will step over any &lt;code class=&quot;highlighter-rouge&quot;&gt;call&lt;/code&gt; instruction. Calls are often used to execute code in another section, and this method is designed to prevent OllyDbg from incorrectly labeling one of those calls as the OEP. But, if a call never returns, of course OllyDbg won’t locate the OEP.&lt;/p&gt;

&lt;p&gt;The step-into method will step into calls, but it might provide false positives as well.&lt;/p&gt;

&lt;h4 id=&quot;things-to-look-for-when-manually-finding-the-oep&quot;&gt;Things to look for when manually finding the OEP&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Jumps outside of a section&lt;/li&gt;
  &lt;li&gt;Jumps that are followed by a bunch of invalid code&lt;/li&gt;
  &lt;li&gt;Jumps that are unreasonably far away&lt;/li&gt;
  &lt;li&gt;Jumps immediately followed by classic function boiler plate code (&lt;code class=&quot;highlighter-rouge&quot;&gt;push ebp, mov ebp, esp&lt;/code&gt; for example)
:&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;terminology&quot;&gt;Terminology&lt;/h2&gt;

&lt;h2 id=&quot;page-to-page-notes&quot;&gt;Page-to-page notes&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;here
    &lt;ul&gt;
      &lt;li&gt;here&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;tools-discussed-in-this-section&quot;&gt;Tools discussed in this section&lt;/h2&gt;
&lt;p&gt;here&lt;/p&gt;

&lt;h2 id=&quot;questions-encountered-and-answers-if-found&quot;&gt;Questions encountered (and answers, if found)&lt;/h2&gt;
&lt;p&gt;here&lt;/p&gt;

</description>
        <pubDate>Mon, 15 Oct 2018 14:31:00 -0600</pubDate>
        <link>http://localhost:4000/ch18_PMA_notes</link>
        <guid isPermaLink="true">http://localhost:4000/ch18_PMA_notes</guid>
        
        
        <category>notes</category>
        
      </item>
    
      <item>
        <title>PMA Ch9 Lab: Using OllyDbg</title>
        <description>&lt;h2 id=&quot;lab-summary-questions&quot;&gt;Lab summary questions&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Considering malware analysis as a whole, how important is it to a general aspiring analyst to complete this chapter’s exercises?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What did doing the lab exercises teach that was not gained from reading the chapter?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;challenges-encountered-in-the-labs&quot;&gt;Challenges encountered in the labs&lt;/h2&gt;

&lt;h2 id=&quot;lab-walkthrough-includes-answers&quot;&gt;Lab Walkthrough (includes answers!)&lt;/h2&gt;

&lt;h3 id=&quot;91&quot;&gt;9.1&lt;/h3&gt;

&lt;p&gt;Analyze the malware found in Lab09-01.exe using OllyDbg and IDA Pro to answer the following questions. Note that this malware was initially analyzed in the Chapter 3 labs using basic static and dynamic techniques. (Uh oh…)&lt;/p&gt;

&lt;h4 id=&quot;questions-to-answer&quot;&gt;Questions to answer&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;How can you get this malware to install itself?&lt;/p&gt;

    &lt;p&gt;One way (of at least two) is to call it as such: &lt;code class=&quot;highlighter-rouge&quot;&gt;./Lab09-01.exe -in abcd&lt;/code&gt; (90% confidence)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What are the command-line options for the program? What is the password requirement?&lt;/p&gt;

    &lt;p&gt;The last command-line argument of the program is the password. The password must be ‘abcd’.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How can you use OllyDbg to permanently patch this malware, so it doesn’t require the special command-line password?&lt;/p&gt;

    &lt;p&gt;Simply overwrite the function call to the password checking program with NOPs.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What are the host-based indicators of this program?&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;A service called “ Manager Service”.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What are the different actions this malware can be instructed to take via the network?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Are there any useful network-based signatures for this malware?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;walkthrough-process&quot;&gt;Walkthrough process&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: Before running this program or beginning to analyze it with Ida or OllyDbg, I recommend making a couple copies of it for backup purposes.&lt;/p&gt;

&lt;p&gt;First, I opened the assets/images/posts in OllyDbg and Ida. I looked through main() on Ida to see what sorts of things we could expect to see, and did a little bit of initial commenting.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/ch9sc/01_startup.PNG&quot; alt=&quot;01_initial.PNG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I opened up sub_402510 to discover a big mess of movs and some repne scasbs and other things. After putting about 5 minutes of effort into trying to understand how all this worked, I realized it would be a lot brighter to, you know, use the tool I just learned about. I migrated over to Olly with the mindset that I wanted to watch how sub_402510 works, since I believe this function is what determines if the malware will install, or delete itself.&lt;/p&gt;

&lt;p&gt;Upon first looking at this new tool’s interface, I noticed OllyDbg broke at _start, while Ida starts up at main(). So, I stepped through code in Olly until I hit where main was called. As I walked through code and matched where Olly was vs. where we were in Ida, I discovered/confirmed:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl + g&lt;/code&gt; is how you do goto address in OllyDbg&lt;/li&gt;
  &lt;li&gt;Return back after going somewhere by using &lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;. It doesn’t necessarily go “back” mind you… but that hasn’t gotten in the way enough for me to put time into it, yet.&lt;/li&gt;
  &lt;li&gt;Place a breakpoint by hitting F2.&lt;/li&gt;
  &lt;li&gt;To change the contents of some registers, you just right click it and choose the appropriate option. EIP doesn’t follow this convention. To change EIP, you must goto the location you want EIP to execute next, right click it, and choose &lt;strong&gt;New Origin Here&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;To rename a memory label in Olly (such as for a call instruction), goto that address and then right click the first instruction at that address and type “:” or right-click the address and click &lt;strong&gt;label&lt;/strong&gt;, and type the new name. This will have all references to that address propogate with the new name. In this way, I made the functions I named in Ida have the same names in Olly, which is very helpful when I’m switching between both programs so much.&lt;/li&gt;
  &lt;li&gt;Double clicking an address will make all addresses around it appear with numbers relative to the one you clicked. This can be helpful for finding out how far away two instructions or bits of data in memory are.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the first run of this program where there are no command line arguments, the argument passed to sub_402510 is the program’s path.&lt;/p&gt;

&lt;p&gt;Let’s look into the function that processes the last command line argument.&lt;/p&gt;

&lt;h4 id=&quot;is-this-the-password-checking-function&quot;&gt;Is this the password checking function?&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/ch9sc/02_processArgvLast.PNG&quot; alt=&quot;processArgvLast&quot; /&gt;&lt;/p&gt;

&lt;p&gt;It contains a &lt;code class=&quot;highlighter-rouge&quot;&gt;repne scasb&lt;/code&gt; instruction. This instruction is not something I know off the top of my head, so I checked out a &lt;a href=&quot;https://reverseengineering.stackexchange.com/questions/2774/what-does-the-assembly-instruction-repne-scas-byte-ptr-esedi&quot;&gt;post on the reverse engineering stackexchange&lt;/a&gt; that explains how the command breaks down.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;repne: repeat while not equal.&lt;/li&gt;
  &lt;li&gt;scas: SCan A String. It compares values in a string (the one pointed to by the ES:[EDI] register) to the value in the accumulator register (&lt;code class=&quot;highlighter-rouge&quot;&gt;EAX&lt;/code&gt;) until it finds a match.
    &lt;ul&gt;
      &lt;li&gt;ES: a segment register. These are used to derive memory addresses. How? I’m not sure, and I am not sure it matters for purposes of this assignment yet. WEEDS&lt;/li&gt;
      &lt;li&gt;EDI: contains a pointer to the string. Why yes, OllyDbg is indeed reporting that the string is in EDI!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Overall, it scans the string until it finds an element in it equal to the element in the accumulator. So, in this case, since EAX is 0, it’s looking for the null terminator.&lt;/p&gt;

&lt;p&gt;Hitting F7 (i.e. step into) shows how the string in EDI shrinks one by one from the left side, and each time that happens, ECX is decremented. (ECX was 0xFFFFFFFF at the beginning). (Just to be clear, it’s not that the string is “shrinking”… We are just changing the pointer in EDI to look one character ahead, and that is what gives the illusion that the string is shrinking.)&lt;/p&gt;

&lt;p&gt;ECX is manipulated to contain the string length!&lt;/p&gt;

&lt;p&gt;Moving on, we see that a comparison of the string length to 4 happens. Since the string length is not 4, it leaves the function. Clearly, it’s looking for something that is a 4 character argument. I reran the program with the argument “asdf” by clicking Olly’s black X in the top left corner, opening a file, and putting “asdf” in the arguments field, and then I stepped through until at the same block of code discussed right above.&lt;/p&gt;

&lt;p&gt;CL, the lower byte of ECX, had moved into it the first letter of the argument being processed by this function. That was then moved into var_4. So, what Ida labeled as var_4 is actually the first character of the command line parameter.  We can tell by reading the assembly in Ida that a comparison of 61 (hex) happens shortly after, and the code leaves if it detects the comparison is not equal. 61 is an ‘a’ in ascii. How convenient. The first guess takes us to step 2 of the checking process.&lt;/p&gt;

&lt;p&gt;Step two (starting at memory location 402563) threw me off for a little, until I just ran it in Olly and observed what happened.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/ch9sc/03_step2.PNG&quot; alt=&quot;step2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;It did a bunch of pointer math, and compared to 1 shortly after. Instead of spending too much time trying to know exactly what the assembly was doing, I just ran the code up to 0x40255A, and discovered that with “asdf”, the value resulting in ECX after the pointer math occurs was 0x12. I also noticed that 0x12 is just about the value that results if you subtract the second character of my current password from the first– s - a = 12. So, this step checks to see if the second character is one more than the first– i.e. ‘b’. So I reran the code with the password ‘abcd’.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/ch9sc/04_step3and4.PNG&quot; alt=&quot;step3and4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Step three employs more strange pointer math. We’ll notice that, however, at 0x402566, 63h (i.e. ‘c’) is moved into dl. After skipping past all but one of the movs, we see an &lt;code class=&quot;highlighter-rouge&quot;&gt;[ecx + 2]&lt;/code&gt; is part of the final mov. This is probably somehow referencing the third char of our string (the second, if we refer to the characters in a zero-indexed fashion). Either way, 0x63 is compared to 0x63 with my password of ‘abcd’, and the code moves on to check four.&lt;/p&gt;

&lt;p&gt;Step 4 takes the current char ‘c’ and adds 1 to it. That makes a ‘d’! Stepping through yields a comparison of ‘d’ to ‘d’, and we know that the password is now ‘abcd’ as a 1 is put into eax and we return.&lt;/p&gt;

&lt;h4 id=&quot;we-have-the-password-but-how-can-we-patch-the-program-to-not-require-one-at-all-question-3&quot;&gt;We have the password, but how can we patch the program to not require one at all (question 3)?&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/ch9sc/05_prePatchingObservation.PNG&quot; alt=&quot;prePatchingObservation&quot; /&gt;&lt;/p&gt;

&lt;p&gt;If the password checking function runs successfully, it puts the value ‘1’ into EAX. Otherwise, it zeroes EAX. The &lt;code class=&quot;highlighter-rouge&quot;&gt;test&lt;/code&gt; instruction combined with a &lt;code class=&quot;highlighter-rouge&quot;&gt;jnz&lt;/code&gt; instruction effectively tests to see if what’s in EAX is zero. If we just … didn’t call that function, EAX would contain a nonzero value from the &lt;code class=&quot;highlighter-rouge&quot;&gt;mov&lt;/code&gt; at address 0x402B2A, and the &lt;code class=&quot;highlighter-rouge&quot;&gt;jnz&lt;/code&gt; jump would be taken. All we need to do is &lt;code class=&quot;highlighter-rouge&quot;&gt;nop&lt;/code&gt; out the call, and the code will always take the jnz branch to the next phase of the malware.&lt;/p&gt;

&lt;p&gt;The book specifically has a section on how to do this (see the patching section in my previous notes post). I right clicked the call instruction of the password checking function in Olly, and selected &lt;strong&gt;Binary -&amp;gt; Edit&lt;/strong&gt;. Now Olly displays the updated code in the disassembler. I then saved this patched version of the program.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/ch9sc/06_patched.PNG&quot; alt=&quot;patched&quot; /&gt;&lt;/p&gt;

&lt;p&gt;HA. Sick. It works.&lt;/p&gt;

&lt;h4 id=&quot;getting-the-malware-to-install-itself&quot;&gt;Getting the malware to install itself&lt;/h4&gt;

&lt;p&gt;To answer this question, I took a shot in the dark and assumed installing itself involved creating a service. I looked through the strings within Ida and found one, “ Manager Service”. Cross-referencing that leads to one use: within sub_402600. This function also does stuff with the registry. If we cross-reference this, we find that it’s used in two places.&lt;/p&gt;

&lt;p&gt;My next observation came from this block of code here.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/ch9sc/07.PNG&quot; alt=&quot;07&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We see that it’s doing a string comparison after it passes the password check function. OllyDbg tells us that the comparison is done with the “-in” hardcoded string, and we can observe it’s comparing one of the command line arguments. Furthermore, if strcmp finds that two strings are the same, it returns 0. So, the &lt;code class=&quot;highlighter-rouge&quot;&gt;jnz&lt;/code&gt; will NOT be taken if the comparison results in finding a “-in” argument.&lt;/p&gt;

&lt;p&gt;The red branch checks to see if there are a total of three arguments (say, perhaps, the program name, -in, and the password). If there are, the &lt;code class=&quot;highlighter-rouge&quot;&gt;jnz&lt;/code&gt; is again not taken due to the nature of how &lt;code class=&quot;highlighter-rouge&quot;&gt;cmp&lt;/code&gt; works. If we follow that red path, we arrive at…&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/ch9sc/08.PNG&quot; alt=&quot;08&quot; /&gt;&lt;/p&gt;

&lt;p&gt;…a block of code that much closer to the install function. At this point, I think it’s safe to say one way to get this malware to install itself is by calling it as such:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;./lab09-01.exe -in asdf&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;realizations-made-after-reading-the-book-answers&quot;&gt;Realizations made after reading the book answers:&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;here&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;92&quot;&gt;9.2&lt;/h3&gt;

&lt;p&gt;Analyze the malware using OllyDbg.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;What strings do you see statically in the binary?&lt;/p&gt;

    &lt;p&gt;Answer here&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What happens when you run the binary?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How can you get this sample to run its malicious payload?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What’s happening at 0x401133?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What arguments are being passed to subroutine 0x401089?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What domain name does this malware use?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What encoding routine is being used to obfuscate the domain name?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What is the significance of the &lt;code class=&quot;highlighter-rouge&quot;&gt;CreateProcessA&lt;/code&gt; call at 0x40106E?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;realizations-made-after-reading-the-book-answers-1&quot;&gt;Realizations made after reading the book answers:&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;here&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;93&quot;&gt;9.3&lt;/h3&gt;

&lt;p&gt;Analyze the malware found in Lab09-03.exe using OllyDbg and Ida. The malware loads three included DLLs that are built to request the same memory load location, which means Ida will show differing memory addresses than Olly when loaded in each. This is done by design to give you experience going from Ida to Olly and back, when the addresses differ.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;What DLLs are imported by Lab09-03.exe?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What is the base address requested by DLL1.dll, DLL2.dll, and DLL3.dll?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;When you use OllyDbg to debug Lab09-03.exe, what is the assigned base address for all three DLL assets/images/posts?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;When Lab09-03.exe calls an import function from DLL1.dll, what does this import function do?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;When the exe calls WriteFile, what is the filename it writes to?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;When the exe creates a job using NetScheduleJobAdd, where does it get the data for the second parameter?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;While running or debugging th eprogram, you’ll see it prints out three piees of mystery data, one of each corresponding to each DLL. What are these pieces of mystery data?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How can you load DLL2.dll into Ida so that it matches the load address used by OllyDbg?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Fri, 12 Oct 2018 16:28:00 -0600</pubDate>
        <link>http://localhost:4000/PMA_ch9_labs</link>
        <guid isPermaLink="true">http://localhost:4000/PMA_ch9_labs</guid>
        
        
        <category>labs</category>
        
      </item>
    
      <item>
        <title>PMA Ch.9 Notes: OllyDbg</title>
        <description>&lt;h2 id=&quot;chapter-summary-questions&quot;&gt;Chapter summary questions&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;In two sentences or less, provide an overview of what this chapter is about.&lt;/p&gt;

    &lt;p&gt;This chapter covers how to use many features that OllyDbg provides.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What are the three most important takeaways from this chapter?&lt;/p&gt;

    &lt;p&gt;For this chapter, it’s hard to choose three &lt;em&gt;most&lt;/em&gt; important takeaways, simply because all the information inside the chapter is helpful in some form of malware analysis scenario.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What problems does this chapter address? In other words, why should we care about this chapter?&lt;/p&gt;

    &lt;p&gt;We should care about this chapter as it gives us the introducton to one of the most powerful and popular tools in the malware analyst’s toolbox.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;using-ollydbg&quot;&gt;Using OllyDbg&lt;/h2&gt;

&lt;h3 id=&quot;opening-a-file&quot;&gt;Opening a file&lt;/h3&gt;
&lt;p&gt;EZ. &lt;strong&gt;File -&amp;gt; open.&lt;/strong&gt; The only time in which you can pass in command line arguments is at this time.&lt;/p&gt;

&lt;p&gt;You can also attach OllyDbg to a running process using &lt;strong&gt;File -&amp;gt; attach&lt;/strong&gt;. When you do this, OllyDbg will foist itself upon the running process and break all threads. It’ll display the current executing thread’s code. This may be windows API code, so you should have the program break upon access to the entire code section.&lt;/p&gt;

&lt;h3 id=&quot;understanding-ollys-gui&quot;&gt;Understanding Olly’s GUI&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/ch9sc/n1.PNG&quot; alt=&quot;n1.PNG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Upon opening a program with OllyDbg (in my case, Lab09-01.exe), we have four different windows.&lt;/p&gt;

&lt;h4 id=&quot;top-left-the-disassembler-window&quot;&gt;Top left: the disassembler window&lt;/h4&gt;
&lt;p&gt;This is the disassember window. It shows the debugged program’s code– the current instruction pointer with several instructions before and after it. To modify instructions or data (or add new instructions), press spacebar within this window.&lt;/p&gt;

&lt;h4 id=&quot;top-right-registers-window&quot;&gt;Top right: registers window&lt;/h4&gt;
&lt;p&gt;You guessed it– it shows registers. They will change color as the program executes. Red is to highlight a recently changed value. You can right click any register value and select &lt;strong&gt;modify&lt;/strong&gt; to change any register value.&lt;/p&gt;

&lt;h4 id=&quot;bottom-right-stack-window&quot;&gt;Bottom right: stack window&lt;/h4&gt;
&lt;p&gt;This shows the stack of the program. It’ll always show the top of the stack for a given thread. You can manipulate it in the same way as you can manipulate registers– right clicking a spot on the stack and selecting &lt;strong&gt;modify&lt;/strong&gt;.&lt;/p&gt;

&lt;h4 id=&quot;bottom-left-memory-dump-window&quot;&gt;Bottom left: memory dump window&lt;/h4&gt;
&lt;p&gt;This window shows a dump of live memory for the debugged process. Pressing &lt;strong&gt;ctrl+G&lt;/strong&gt; in this window permits you to go to a specific spot in memory. Clicking a memory address and selecting &lt;strong&gt;Follow in Dump&lt;/strong&gt; permits you to dump tha tmemory address.&lt;/p&gt;

&lt;p&gt;You can edit memory in this window, too. Right click some memory and choose &lt;strong&gt;Binary -&amp;gt; edit&lt;/strong&gt; to do so. This can be used to modify global variables and other data that malware stores in RAM.&lt;/p&gt;

&lt;h3 id=&quot;executing-code&quot;&gt;Executing code&lt;/h3&gt;

&lt;p&gt;See page 186 for a nice table on the hotkeys used to execute code. There are a few notable features worth mentioning:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;When paused within library code, do a &lt;strong&gt;Debug -&amp;gt; Execute until User Code&lt;/strong&gt; to run until you’re no longer in the library.&lt;/li&gt;
  &lt;li&gt;Step-into: F7.&lt;/li&gt;
  &lt;li&gt;Step-over: F8&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;breakpoints&quot;&gt;Breakpoints&lt;/h4&gt;

&lt;p&gt;You can add or remove a breakpoin tby selecting the instruction in the disassembler window and pressing F2. You can view active breakpoints by selecting ** View -&amp;gt; Breakpoints** or clicking the B icon in the toolbar.&lt;/p&gt;

&lt;p&gt;You can generally select what breakpoints you want to use by right-clicking and going from &lt;strong&gt;Breakpoint -&amp;gt; [breakpoint type here]&lt;/strong&gt;. There are hotkeys for some of these too– see p188.&lt;/p&gt;

&lt;h3 id=&quot;buttons-and-other-windows&quot;&gt;Buttons and other windows&lt;/h3&gt;

&lt;h4 id=&quot;memory-map-window-m&quot;&gt;Memory map window (M)&lt;/h4&gt;
&lt;p&gt;Click the M box or click &lt;strong&gt;View -&amp;gt; Memory&lt;/strong&gt; to display all memory blocks allocated by the debugged program. This is a great way to see how a program is laid out in memory. All DLLs and their code sections are also visible. You cna double-click any row in the memory map to show a memory dump of that section, or you can send the data in a memory dump to the disassembler window by right-clicking and selecting &lt;strong&gt;View in Disassembler.&lt;/strong&gt; &lt;strong&gt;This seems very helpful for obfuscated malware.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;dlls&quot;&gt;DLLs&lt;/h3&gt;
&lt;p&gt;OllyDbg can debug DLL assets/images/posts. Since DLLs cannot be executed directly, OllyDbg uses a dummy program called &lt;em&gt;loaddll.exe&lt;/em&gt; to load them. By default, OllyDbg breaks at the DLL entry point (dllmain) when the DLL is loaded.&lt;/p&gt;

&lt;p&gt;To call exported functions with arguments inside the debugged DLL:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Load the DLL&lt;/li&gt;
  &lt;li&gt;Click the play button to run &lt;code class=&quot;highlighter-rouge&quot;&gt;DllMain&lt;/code&gt; and any other intialization code the DLL requires&lt;/li&gt;
  &lt;li&gt;Olly will pause, and you can call specific exports with arguments and debug them by selecting &lt;strong&gt;Debug -&amp;gt; Call DLL Export&lt;/strong&gt; from the main menu. (See an example of this on p191/p192.)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;tracing&quot;&gt;Tracing&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Tracing&lt;/strong&gt; is a powerful debugging technique that records detailed execution information for you to examine.&lt;/p&gt;

&lt;h4 id=&quot;standard-back-trace&quot;&gt;Standard Back Trace&lt;/h4&gt;
&lt;p&gt;Whenever you’re moving through the disassembler window with the Step Into and Step Over functions, OllyDbg is recording the movement. You can use the minus key on the keyboard to move back in time and see the instructions previously executed. The plus key takes you forward.&lt;/p&gt;

&lt;h4 id=&quot;call-stack&quot;&gt;Call Stack&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;View -&amp;gt; Call Stack&lt;/strong&gt; will allow you to view the call stack. Imagine that.&lt;/p&gt;

&lt;p&gt;To walk the call stack, click the Address or Called From sections of the call stack window. The registers and stack will not show you what was going on when in that location, unless you are performing a run trace.&lt;/p&gt;

&lt;h4 id=&quot;run-trace&quot;&gt;Run Trace&lt;/h4&gt;
&lt;p&gt;A &lt;strong&gt;run trace&lt;/strong&gt; allows you to execute code and have OllyDbg save every executed instruction and all changes made to the registers and flags.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Highlight code you wish to trace. Select &lt;strong&gt;Run Trace -&amp;gt; Add Selection&lt;/strong&gt;. After, choose &lt;strong&gt;View -&amp;gt; Run Trace&lt;/strong&gt; to see the instructions. Use the + and - keys as discussed above to run through the trace.&lt;/li&gt;
  &lt;li&gt;You can also use the &lt;strong&gt;Trace Into&lt;/strong&gt; and &lt;strong&gt;Trace Over&lt;/strong&gt; options. These will simply trace until a breakpoint is hit.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;patching&quot;&gt;Patching&lt;/h3&gt;
&lt;p&gt;You can modify instructions or memory by highlighting a region, right-clicking the region, and selecting &lt;strong&gt;Binary -&amp;gt; Edit&lt;/strong&gt;. This just changes the live memory; to take patching a step further and saving the on-disk executable, right click the disassembler window wher eyou patched the code and select &lt;strong&gt;Copy to Executable-&amp;gt;All Modifications&lt;/strong&gt;, and then select &lt;strong&gt;Save file&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&quot;analyzing-shellcode-or-other-random-instructions&quot;&gt;Analyzing shellcode (or other random instructions)&lt;/h3&gt;

&lt;p&gt;See the step by step process on p196. All I would do in these notes is copy that ordered list of instructions, more or less otherwise.&lt;/p&gt;

&lt;h2 id=&quot;rebasing&quot;&gt;Rebasing&lt;/h2&gt;
&lt;p&gt;This occurs when a module in Windows is not loaded at its preferred &lt;em&gt;base address.&lt;/em&gt; All PE assets/images/posts in Windows have a preferred base address, known as the &lt;em&gt;image base&lt;/em&gt; defined in the PE header. Most executables are designed to be loaded at &lt;code class=&quot;highlighter-rouge&quot;&gt;0x400000&lt;/code&gt;, which is probably why so many variables and functions in Ida are named using 0x400000 or some close number in some fashion.&lt;/p&gt;

&lt;p&gt;Of course, this is a preferred address, but it doesn’t guarantee a program will be loaded there. For example, if a program has two DLLs and they each have the same base address, they can’t both be loaded at the same address.&lt;/p&gt;

&lt;p&gt;Some instructions rely on the data being loaded at a specifc address, such as this instruction:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mov eax, dword__40CF60&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;That won’t work if the DLL with that instruction isn’t loaded in the right spot due to the use of an absolute address. Most DLLs come packaged with a list of fix-up locations in the &lt;code class=&quot;highlighter-rouge&quot;&gt;.reloc&lt;/code&gt; section of the PE header.&lt;/p&gt;

&lt;p&gt;DLLs are loaded after the .exe and are loaded in any order, meaning you can’t generally predict where DLLs will be located in memory if they’re rebased. If a DLL lacking a relocation section can’t be loaded at its preferred base address, then it cannot be loaded.&lt;/p&gt;

&lt;h2 id=&quot;wrapping-up&quot;&gt;Wrapping up&lt;/h2&gt;

&lt;p&gt;Assistance features– p197&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Logging&lt;/li&gt;
  &lt;li&gt;Watches window (i.e. watching when certain things change)&lt;/li&gt;
  &lt;li&gt;Help&lt;/li&gt;
  &lt;li&gt;Labelling
    &lt;ul&gt;
      &lt;li&gt;right click an address and select &lt;strong&gt;Label&lt;/strong&gt; which will prop up a window, promting for a label name. Works like in Ida.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;How to use plugins– p197&lt;/p&gt;

&lt;p&gt;Scriptable debugging – using Python to do plugins.&lt;/p&gt;

</description>
        <pubDate>Fri, 12 Oct 2018 14:31:00 -0600</pubDate>
        <link>http://localhost:4000/ch9_PMA_notes</link>
        <guid isPermaLink="true">http://localhost:4000/ch9_PMA_notes</guid>
        
        
        <category>notes</category>
        
      </item>
    
      <item>
        <title>PMA Ch8 Notes: Debuggers</title>
        <description>&lt;h2 id=&quot;chapter-summary-questions&quot;&gt;Chapter summary questions&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;In two sentences or less, provide an overview of what this chapter is about.&lt;/p&gt;

    &lt;p&gt;This chapter provides an overview of what debuggers are, what breakpoints are and how they work, and what exceptions are. They cover just the conceptual topics of debuggers, meaning no technical information is provided.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What are the three most important takeaways from this chapter?&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;There are several types of breakpoints and it pays to know how they work so you can be aware of potential reprecussions of using them.&lt;/li&gt;
      &lt;li&gt;Debuggers can be used to modify program execution by modifying the control registers, which can be helpful for identifying what code &lt;em&gt;would&lt;/em&gt; have done if it detected it was in a different environment.&lt;/li&gt;
      &lt;li&gt;Debuggers can be used to just run single functions as well, which may cause the program to crash afterwards but can be very useful for understanding exactly how, say, a decoding routine works.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What problems does this chapter address? In other words, why should we care about this chapter?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

 	This chapter provides the foundation for understanding what debuggers do and how they work, which enables more technical discussion of how to use debuggers, which is information covered in the next two chapters. 

&lt;h2 id=&quot;terminology&quot;&gt;Terminology&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Debugger&lt;/em&gt;: a piece of software or hardware used to test or examine the &lt;em&gt;execution&lt;/em&gt; of another program.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Malware analysis typically makes use of &lt;em&gt;assembly-level&lt;/em&gt; debuggers, which run an instruction at a time, as opposed to source-level debuggers, which run a line of source code at a time. (We don’t have the source code, so…)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Breakpoints&lt;/em&gt; are used to pause execution of a program.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Step-into vs. step-over&lt;/em&gt;: stepping over means it’ll execute all the code represented by a single instruction. In other words, if you step over a function, it’ll call that function and break immediately after the function returns. Stepping into means you’ll break at the first instruction within a function.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;For instructions that don’t transfer execution, stepping into and stepping over are functionally equivalent.&lt;/li&gt;
  &lt;li&gt;Some debuggers have a step-out function as well– they will run until the function you’re currently in returns.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;types-of-breakpoints-and-how-they-work&quot;&gt;Types of breakpoints (and how they work!)&lt;/h2&gt;

&lt;h3 id=&quot;software-breakpionts&quot;&gt;Software breakpionts&lt;/h3&gt;
&lt;p&gt;When a software breakpoint is set, the debugger overwrites the first byte of the broken instruction with &lt;code class=&quot;highlighter-rouge&quot;&gt;0xCC&lt;/code&gt;, which is the instruction for INT 3, which is the breakpoint interrupt designed for use with debuggers. When this is executed, the OS generates an exception and transfers control to the debugger.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;One problem with this is the code is actually being changed in memory. Functions that perform integrity checks will notice the existence of a breakpoint. Self-modifying code can also remove the breakpoint. Code that reads in the memory of a function will read in a 0xCC byte instead of whatever byte is typically there.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;hardware-breakpoints&quot;&gt;Hardware breakpoints&lt;/h3&gt;
&lt;p&gt;Hardware execution breakpoints are supported via dedicated hardware registers on the x86 architecture. Every time the processor executes an instruction, there is hardware to detect if the instruction pointer is equal to the breakpoint address. As such, the problems discussed with software breakpoints are nonexistent.&lt;/p&gt;

&lt;p&gt;Furthermore, these breakpoints can be set to break on access rather than execution. If code reads memory from a specific address, a hardware breakpoint can be used to break the program on the instruction that reads the memory.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;The drawback with hardware breakpoints is there are only four hardware registers that store breakpoint addresses. Additionally, they are easy to modify by the running program.
    &lt;ul&gt;
      &lt;li&gt;This modification can be partially remediated, however, by setting the General Detect flag in the DR7 register. This causes a break to occur whenever a &lt;code class=&quot;highlighter-rouge&quot;&gt;mov&lt;/code&gt; instruction accesses a debug register.&lt;/li&gt;
      &lt;li&gt;See more info about specific debug registers on page 175.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;conditional-breakpoints&quot;&gt;Conditional breakpoints&lt;/h3&gt;
&lt;p&gt;These are software breakpoints that will break only if a certain condition is true. This would be helpful for breaking when functions are called with certain arguments, for example. They are evaluated as software breakpoints, and the debugger evaluates the condition.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;One problem with these is they slow down the execution speed of a program dramatically, because the program state is examined and evaluated in addition to the actual execution of the program.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;exceptions&quot;&gt;Exceptions&lt;/h2&gt;
&lt;p&gt;Debuggers are usually given two opportunities to handle the same exception: a &lt;em&gt;first-chance exception&lt;/em&gt; and a &lt;em&gt;second-chance&lt;/em&gt; exception.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;When &lt;em&gt;First-chance exceptions&lt;/em&gt; occur, the program stops executing and the debugger is given a first chance at control. The debugger can handle the exception or pass it to the program. If the program has a registered exception handler, that is given a chance to handle the exception after the debugger’s first chance.&lt;/li&gt;
  &lt;li&gt;If the program does not resolve the exception, then the debugger is given a second chance to handle it– &lt;em&gt;second-chance exception&lt;/em&gt;. When the debugger receives these, it means the program would have otherwise crashed, and the debugger must resolve the error if the program is to continue.
    &lt;ul&gt;
      &lt;li&gt;As analysts, we don’t typically care about first-chance exceptions since it’s common that they are used to direct control flow. However, we do care about second-chance exceptions. There may be bugs in the malware, or it’s possible that the malware does not like the environment in which it’s running.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 07 Oct 2018 12:02:00 -0600</pubDate>
        <link>http://localhost:4000/PMA_ch8_notes</link>
        <guid isPermaLink="true">http://localhost:4000/PMA_ch8_notes</guid>
        
        
        <category>notes</category>
        
      </item>
    
  </channel>
</rss>
