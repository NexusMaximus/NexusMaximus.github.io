<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-10-07T12:12:48-06:00</updated><id>http://localhost:4000/</id><title type="html">Kyle the (Aspiring) Reverser</title><subtitle>A home for a slew of miscellaneous technical (or not) blogs I write in the process of completing my Masters thesis.</subtitle><entry><title type="html">PMA Ch8 Notes: Debuggers</title><link href="http://localhost:4000/notes/2018/10/07/PMA_ch8_notes.html" rel="alternate" type="text/html" title="PMA Ch8 Notes: Debuggers" /><published>2018-10-07T12:02:00-06:00</published><updated>2018-10-07T12:02:00-06:00</updated><id>http://localhost:4000/notes/2018/10/07/PMA_ch8_notes</id><content type="html" xml:base="http://localhost:4000/notes/2018/10/07/PMA_ch8_notes.html">&lt;h2 id=&quot;chapter-summary-questions&quot;&gt;Chapter summary questions&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;In two sentences or less, provide an overview of what this chapter is about.&lt;/p&gt;

    &lt;p&gt;This chapter provides an overview of what debuggers are, what breakpoints are and how they work, and what exceptions are. They cover just the conceptual topics of debuggers, meaning no technical information is provided.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What are the three most important takeaways from this chapter?&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;There are several types of breakpoints and it pays to know how they work so you can be aware of potential reprecussions of using them.&lt;/li&gt;
      &lt;li&gt;Debuggers can be used to modify program execution by modifying the control registers, which can be helpful for identifying what code &lt;em&gt;would&lt;/em&gt; have done if it detected it was in a different environment.&lt;/li&gt;
      &lt;li&gt;Debuggers can be used to just run single functions as well, which may cause the program to crash afterwards but can be very useful for understanding exactly how, say, a decoding routine works.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What problems does this chapter address? In other words, why should we care about this chapter?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

 	This chapter provides the foundation for understanding what debuggers do and how they work, which enables more technical discussion of how to use debuggers, which is information covered in the next two chapters. 

&lt;h2 id=&quot;terminology&quot;&gt;Terminology&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Debugger&lt;/em&gt;: a piece of software or hardware used to test or examine the &lt;em&gt;execution&lt;/em&gt; of another program.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Malware analysis typically makes use of &lt;em&gt;assembly-level&lt;/em&gt; debuggers, which run an instruction at a time, as opposed to source-level debuggers, which run a line of source code at a time. (We don’t have the source code, so…)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Breakpoints&lt;/em&gt; are used to pause execution of a program.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Step-into vs. step-over&lt;/em&gt;: stepping over means it’ll execute all the code represented by a single instruction. In other words, if you step over a function, it’ll call that function and break immediately after the function returns. Stepping into means you’ll break at the first instruction within a function.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;For instructions that don’t transfer execution, stepping into and stepping over are functionally equivalent.&lt;/li&gt;
  &lt;li&gt;Some debuggers have a step-out function as well– they will run until the function you’re currently in returns.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;types-of-breakpoints-and-how-they-work&quot;&gt;Types of breakpoints (and how they work!)&lt;/h2&gt;

&lt;h3 id=&quot;software-breakpionts&quot;&gt;Software breakpionts&lt;/h3&gt;
&lt;p&gt;When a software breakpoint is set, the debugger overwrites the first byte of the broken instruction with &lt;code class=&quot;highlighter-rouge&quot;&gt;0xCC&lt;/code&gt;, which is the instruction for INT 3, which is the breakpoint interrupt designed for use with debuggers. When this is executed, the OS generates an exception and transfers control to the debugger.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;One problem with this is the code is actually being changed in memory. Functions that perform integrity checks will notice the existence of a breakpoint. Self-modifying code can also remove the breakpoint. Code that reads in the memory of a function will read in a 0xCC byte instead of whatever byte is typically there.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;hardware-breakpoints&quot;&gt;Hardware breakpoints&lt;/h3&gt;
&lt;p&gt;Hardware execution breakpoints are supported via dedicated hardware registers on the x86 architecture. Every time the processor executes an instruction, there is hardware to detect if the instruction pointer is equal to the breakpoint address. As such, the problems discussed with software breakpoints are nonexistent.&lt;/p&gt;

&lt;p&gt;Furthermore, these breakpoints can be set to break on access rather than execution. If code reads memory from a specific address, a hardware breakpoint can be used to break the program on the instruction that reads the memory.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;The drawback with hardware breakpoints is there are only four hardware registers that store breakpoint addresses. Additionally, they are easy to modify by the running program.
    &lt;ul&gt;
      &lt;li&gt;This modification can be partially remediated, however, by setting the General Detect flag in the DR7 register. This causes a break to occur whenever a &lt;code class=&quot;highlighter-rouge&quot;&gt;mov&lt;/code&gt; instruction accesses a debug register.&lt;/li&gt;
      &lt;li&gt;See more info about specific debug registers on page 175.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;conditional-breakpoints&quot;&gt;Conditional breakpoints&lt;/h3&gt;
&lt;p&gt;These are software breakpoints that will break only if a certain condition is true. This would be helpful for breaking when functions are called with certain arguments, for example. They are evaluated as software breakpoints, and the debugger evaluates the condition.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;One problem with these is they slow down the execution speed of a program dramatically, because the program state is examined and evaluated in addition to the actual execution of the program.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;exceptions&quot;&gt;Exceptions&lt;/h2&gt;
&lt;p&gt;Debuggers are usually given two opportunities to handle the same exception: a &lt;em&gt;first-chance exception&lt;/em&gt; and a &lt;em&gt;second-chance&lt;/em&gt; exception.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;When &lt;em&gt;First-chance exceptions&lt;/em&gt; occur, the program stops executing and the debugger is given a first chance at control. The debugger can handle the exception or pass it to the program. If the program has a registered exception handler, that is given a chance to handle the exception after the debugger’s first chance.&lt;/li&gt;
  &lt;li&gt;If the program does not resolve the exception, then the debugger is given a second chance to handle it– &lt;em&gt;second-chance exception&lt;/em&gt;. When the debugger receives these, it means the program would have otherwise crashed, and the debugger must resolve the error if the program is to continue.
    &lt;ul&gt;
      &lt;li&gt;As analysts, we don’t typically care about first-chance exceptions since it’s common that they are used to direct control flow. However, we do care about second-chance exceptions. There may be bugs in the malware, or it’s possible that the malware does not like the environment in which it’s running.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">Chapter summary questions In two sentences or less, provide an overview of what this chapter is about.</summary></entry><entry><title type="html">PMA Ch.7 labs: Playing with Windows-specific malware</title><link href="http://localhost:4000/labs/2018/09/12/PMA_ch7_labs.html" rel="alternate" type="text/html" title="PMA Ch.7 labs: Playing with Windows-specific malware" /><published>2018-09-12T14:31:00-06:00</published><updated>2018-09-12T14:31:00-06:00</updated><id>http://localhost:4000/labs/2018/09/12/PMA_ch7_labs</id><content type="html" xml:base="http://localhost:4000/labs/2018/09/12/PMA_ch7_labs.html">&lt;h2 id=&quot;lab-summary-questions&quot;&gt;Lab summary questions&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Considering malware analysis as a whole, how important is it to a general aspiring analyst to complete this chapter’s exercises?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What did doing the lab exercises teach that was not gained from reading the chapter?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;challenges-encountered-in-the-labs&quot;&gt;Challenges encountered in the labs&lt;/h2&gt;

&lt;h2 id=&quot;lab-walkthrough-includes-answers&quot;&gt;Lab Walkthrough (includes answers!)&lt;/h2&gt;

&lt;h3 id=&quot;71&quot;&gt;7.1&lt;/h3&gt;
&lt;p&gt;Analyze the malware found in file &lt;em&gt;Lab07-01.exe&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Questions to answer as we go on:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;How does this program acheive persistence?&lt;/p&gt;

    &lt;p&gt;By installing a service known as &lt;code class=&quot;highlighter-rouge&quot;&gt;MalService&lt;/code&gt; that runs a malicious function.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Why does this program use a mutex?&lt;/p&gt;

    &lt;p&gt;It runs a mutex to see if a thread needs to be created or not. If the function obtains the mutex, then the program quits. Otherwise, the program attempts to create the mutex and proceeds to attempt to spin up a malicious thread. (This seems counter-intuitive at this point… see the post-answer-reading section below for a more detailed explanation of this.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What’s a good host-based signature for detecting this malware?&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Having a service named &lt;code class=&quot;highlighter-rouge&quot;&gt;Malservice&lt;/code&gt; on the system.&lt;/li&gt;
      &lt;li&gt;Identifcation of a mutex called &lt;code class=&quot;highlighter-rouge&quot;&gt;HGL345&lt;/code&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What’s a good network-based signature for detecting this malware?&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;User agent of just the string &lt;code class=&quot;highlighter-rouge&quot;&gt;Internet Explorer 8.0&lt;/code&gt;
        &lt;ul&gt;
          &lt;li&gt;Connection under that user agent to &lt;code class=&quot;highlighter-rouge&quot;&gt;http://malwareanalysisbook.com/&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What’s the purpose of this program?&lt;/p&gt;

    &lt;p&gt;It looks like this program will attempt to connect to a specific website at a certain time. I believe it’s a program that will turn infected computers into elements of a botnet, which will attack a site at a unified time.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;When will this program finish executing?&lt;/p&gt;

    &lt;p&gt;At some time very close to the turn of the 22nd century.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;First, let’s review and apply static analysis techniques and dynamic analysis techniques from chapters 1-3 before doing too much with Ida.&lt;/p&gt;

&lt;h4 id=&quot;cffexplorer&quot;&gt;CFFExplorer&lt;/h4&gt;

&lt;p&gt;The malware loads three DLLs: &lt;code class=&quot;highlighter-rouge&quot;&gt;ADVAPI32.dll&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;WININET.dll&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;KERNEL32.dll&lt;/code&gt;.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;From ADVAPI.dll: we have CreateServiceA, OpenSCManagerA, and StartServiceCtrlDispatcherA. The book previously described CreateService and OpenSCManager (see ch7 notes in a previous blog post), but I don’t recall seeing the start service function. Luckily, the book again proves its usefulness with Appendix A– the function is used by a service to connect to the main thread of the process to the service control manager. 
&lt;em&gt;Any process that runs as a service must call this function within 30 seconds of startup. Locating this function in malware tells you that the function should be ran as a service.&lt;/em&gt; (This is insightful for question 1.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;From WININET.dll: we have &lt;code class=&quot;highlighter-rouge&quot;&gt;InternetOpenUrlA&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;InternetOpenA&lt;/code&gt;. We know from the book that these functions are used to establish a connection with a specific internet location and to initialize high-level Internet access functions from WinINet. Conveniently for us, InternetOpen requires a user agent parameter, and InternetOpenUrl requires a URL (imagine that). These is insightful for question 4, as each of these could act as network-based signatures if they’re consistent.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;From KERNEL32.dll: There are lots of functions being imported, but the ones that come to mind as notable are:&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CreateMutexA&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;OpenMutexA&lt;/code&gt; as this will require a mutex name, which could act as a host-based signature. I predict the code around this function call will provide the answer to question 2.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CreateThread&lt;/code&gt;, as creating threads for various reasons was discussed in depth in the notes for this chapter.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;GetCurrentProcess&lt;/code&gt;. This will permit the malware to do things with itself.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;GetCommandLineA&lt;/code&gt; tells the process how it was called. This could be used to determine if it’s called as a service or if it’s called to install.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;WriteFile&lt;/code&gt; saves data into a file! Files are always great host-based indicators.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There may be more note-worthy functions used, but none of the others jumped out at me as areas that should be further explored at this moment in time.&lt;/p&gt;

&lt;h4 id=&quot;resource-hacker&quot;&gt;Resource Hacker&lt;/h4&gt;
&lt;p&gt;ResourceHacker found no resources in this file.&lt;/p&gt;

&lt;h4 id=&quot;stringsexe&quot;&gt;Strings.exe&lt;/h4&gt;
&lt;p&gt;In addition to all the imports, strings.exe highlights two notable strings: &lt;code class=&quot;highlighter-rouge&quot;&gt;http://www.malwareanalysisbook.com&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Internet Explorer 8.0&lt;/code&gt;, which I expect to see utilized as the C&amp;amp;C server and the user agent respectively.&lt;/p&gt;

&lt;h4 id=&quot;ida-demo&quot;&gt;Ida Demo&lt;/h4&gt;

&lt;p&gt;The first thing we see when opening this file in Ida is how it establishes persistence.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/ch7sc/01_1main.PNG&quot; alt=&quot;01_1main.PNG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We see that the name of the service is pushed (&lt;code class=&quot;highlighter-rouge&quot;&gt;MalService&lt;/code&gt;) and then a function pointer is pushed. This mimics the structure expected as a parameter to the function, according to MSDN. As such, we can conclude that &lt;code class=&quot;highlighter-rouge&quot;&gt;sub_401040&lt;/code&gt; is what will be called as a service from here on out, which acheives persistence and answers question 1.&lt;/p&gt;

&lt;p&gt;Looking at the function passed to the call above….&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/ch7sc/02_sub401040.PNG&quot; alt=&quot;02_sub401040&quot; /&gt;&lt;/p&gt;

&lt;p&gt;A mutex &lt;code class=&quot;highlighter-rouge&quot;&gt;HGL345&lt;/code&gt; is attempted to be opened (with all access rights– that’s what the constant 0x1F0001 does) first thing. If the call returns 0 (i.e. NULL), that means the function failed to obtain the mutex, perhaps because it doesn’t exist or because it’s in use. If the call does NOT fail, then the program exits, which is sort of strange. 
Otherwise, the program proceeds to create the mutex. (Note that if the mutex exists, CreateMutex simply returns a handle to the mutex).&lt;/p&gt;

&lt;p&gt;It makes a service as it has concluded a service doesn’t exist for itself.&lt;/p&gt;

&lt;p&gt;It waits for some time. Not sure what “FileTime” is at this point, but it seems to wait, perhaps for a specific
date, say, of a planned out DDoS.&lt;/p&gt;

&lt;p&gt;If WaitForSingleObject returns nonzero, the program proceeds to go into an infinite (i.e. INT_MAX) millisecond wait loop. 
If WaitForSingleObject returns 0 (i.e. it has received a signal that it’s done waiting), a thread is created in which more malicious code is called– Ida calls it &lt;code class=&quot;highlighter-rouge&quot;&gt;StartAddress&lt;/code&gt;. What does this do?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/ch7sc/03_startAddress.PNG&quot; alt=&quot;03_startAddress&quot; /&gt;&lt;/p&gt;

&lt;p&gt;It appears to just establish a connection with a domain. Considering the fact that it looks like the previous code waits to create a thread until a specific time, and combined with a little cybersecurity intuition, I believe there’s enough evidence to suggest this program’s purpose is to DDoS a computer at a hardcoded time.&lt;/p&gt;

&lt;p&gt;When? I’m not sure of specifics, but the date pushed to CreateWaitableTimerA includes the year 2100 and the rest of the parameters are 0, which makes me think somehwere around the turn of the century. More in-depth analysis may help me figure this out specifically, but I believe it would be more beneficial to read the answers to this and move on to the next sample of malware.&lt;/p&gt;

&lt;h4 id=&quot;realizations-made-after-reading-the-book-answers&quot;&gt;Realizations made after reading the book answers:&lt;/h4&gt;

&lt;p&gt;The first thing I looked up was an explanation behind the wonky-seeming mutex business. It goes like this:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;If the initial mutex call &lt;code class=&quot;highlighter-rouge&quot;&gt;OpenMutex&lt;/code&gt; succeeds, then the program exits. Otherwise, it continues.&lt;/li&gt;
  &lt;li&gt;If the program continues, the first thing it does is it attempts to create the mutex. The book says that if a copy of the malware was already running, then the first call to &lt;em&gt;OpenMutex&lt;/em&gt; would have succeeded.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I get it now. The program runs forever, so it creates a mutex &lt;em&gt;but does not obtain access to it.&lt;/em&gt; This is an indicator to all future instances of the program that it’s already running. Nothing else will obtain this mutex (or if it is obtained, it’ll be released very soon as the program will obtain it and then exit, which will, I presume, free the mutex). The mutex will simply act as a gatekeeper of sorts.&lt;/p&gt;

&lt;p&gt;But what if the computer restarts? Will the mutex persist? If it will, then, since the function called by the service manager contains the initial mutex check, the service should theoretically end. Is this a bug, or is it author-written protection for newbie malware analysts, or am I just not understanding something? Hmmmm…..&lt;/p&gt;

&lt;p&gt;The answer to this question is answered &lt;a href=&quot;https://blogs.msdn.microsoft.com/oldnewthing/20100903-00/?p=12953&quot;&gt;here&lt;/a&gt;. From what I can conclude, mutexes will not persist after handles to them are closed, so if the computer restarts, the service will recreate the mutex and go on its merry malicious way.&lt;/p&gt;

&lt;p&gt;Anyway. Moving on:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/ch7sc/04_20threads.PNG&quot; alt=&quot;04_20threads&quot; /&gt;&lt;/p&gt;

&lt;p&gt;One thing I did not pay close attention to was how the threads were created. I see now that it moves 20 into &lt;code class=&quot;highlighter-rouge&quot;&gt;esi&lt;/code&gt; and then calls CreateThread until &lt;code class=&quot;highlighter-rouge&quot;&gt;esi&lt;/code&gt; is 0. I believe that, since the startAddress is passed to each thread, we will have 20 different instances of connection requests, per bot in the botnet.&lt;/p&gt;

&lt;p&gt;Furthermore, I see now that the program will not end, as in any case, push INT_MAX followed by a sleep occurs.&lt;/p&gt;

&lt;p&gt;Lastly, looking more carefully at &lt;code class=&quot;highlighter-rouge&quot;&gt;StartAddress&lt;/code&gt; will help one see that the loop that attempts connections with &lt;code class=&quot;highlighter-rouge&quot;&gt;http://www.malwareanalysisbook.com&lt;/code&gt; will unconditionally repeat, meaning we will have 20 * unlimited connection attempts, &lt;em&gt;per bot&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&quot;72&quot;&gt;7.2&lt;/h3&gt;

&lt;p&gt;Questions to keep in mind as we go on:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;How does this program acheive persistence?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What’s the purpose of this program?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;When will this program finish executing?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This time, the first thing I did was open this program in Ida. Upon opening, we see this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/ch7sc/05_OleInitialize.PNG&quot; alt=&quot;05_OleInitialize.PNG&quot; /&gt;;&lt;/p&gt;

&lt;p&gt;So, the COM library will be initialized, which hints that COM objects will be used. A few other functions will be used, and it’s worth looking them up to get the general idea of what they are used for before diving into the details.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CoCreateInstance&lt;/code&gt;: Per &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance&quot;&gt;MDSN docs&lt;/a&gt;, this creats a single uninitialized object of the class associated with a specified CLSID.  It would be worth looking into what the passed-in CLSID is and see what that corresponds to. &lt;strong&gt;Note that the interface pointer created by the function is stored into var ppv&lt;/strong&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;VariantInit&lt;/code&gt;: This function creates a variant. I believe that a variant is simply a data structure that supports many different data types, according to &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/winauto/variant-structure&quot;&gt;Microsoft&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SysAllocString&lt;/code&gt;: Allocates a new string and copies the passed string into it. We should look into what is passed to this.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SysFreeString&lt;/code&gt;: Frees an alloc’d string.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let’s talk about what’s passed to CoCreateInstance. A CLSID is a 128 bit hex number. That’s 128 / 8 = 16 bytes.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/ch7sc/06_CLSID.PNG&quot; alt=&quot;06_CLSID.PNG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We have a four-part structure here: a DD (define double word), a DW (define word), another DW, and then 8 DB (Define bytes). DD’s are 4 bytes, DWs are 2 bytes, and DBs are 1 byte. The 6 dup (0) just means we have 6 duplicate bbytes of the data 0.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;dd&lt;/td&gt;
      &lt;td&gt;dw&lt;/td&gt;
      &lt;td&gt;dw&lt;/td&gt;
      &lt;td&gt;db&lt;/td&gt;
      &lt;td&gt;db&lt;/td&gt;
      &lt;td&gt;db&lt;/td&gt;
      &lt;td&gt;db&lt;/td&gt;
      &lt;td&gt;db&lt;/td&gt;
      &lt;td&gt;db&lt;/td&gt;
      &lt;td&gt;db&lt;/td&gt;
      &lt;td&gt;db&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0002DF01&lt;/td&gt;
      &lt;td&gt;0000&lt;/td&gt;
      &lt;td&gt;0000&lt;/td&gt;
      &lt;td&gt;C0&lt;/td&gt;
      &lt;td&gt;00&lt;/td&gt;
      &lt;td&gt;00&lt;/td&gt;
      &lt;td&gt;00&lt;/td&gt;
      &lt;td&gt;00&lt;/td&gt;
      &lt;td&gt;00&lt;/td&gt;
      &lt;td&gt;00&lt;/td&gt;
      &lt;td&gt;46&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;So if we google this CLSID 0002DF01-0000-0000-C000-000000000046, we get a bunch of results that are basically meaningless. Instead, I just found the registry key that contains CLSIDs: &lt;code class=&quot;highlighter-rouge&quot;&gt;HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID&lt;/code&gt;. In here, all the CLSIDs are organized (thank goodness).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/ch7sc/07_IE.PNG&quot; alt=&quot;07_IE.PNG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;So this CLSID corresponds to Internet Explorer.&lt;/p&gt;

&lt;p&gt;Now let’s talk about the RIID. The RIID is a reference to the identifier of the interface to be used to communicate with the object returned by CoCreateInstance. It has the same byte-age as the above CLSID in memory.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;dd&lt;/td&gt;
      &lt;td&gt;dw&lt;/td&gt;
      &lt;td&gt;dw&lt;/td&gt;
      &lt;td&gt;db&lt;/td&gt;
      &lt;td&gt;db&lt;/td&gt;
      &lt;td&gt;db&lt;/td&gt;
      &lt;td&gt;db&lt;/td&gt;
      &lt;td&gt;db&lt;/td&gt;
      &lt;td&gt;db&lt;/td&gt;
      &lt;td&gt;db&lt;/td&gt;
      &lt;td&gt;db&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;D30C1661&lt;/td&gt;
      &lt;td&gt;CDAF&lt;/td&gt;
      &lt;td&gt;11D0&lt;/td&gt;
      &lt;td&gt;8A&lt;/td&gt;
      &lt;td&gt;3E&lt;/td&gt;
      &lt;td&gt;00&lt;/td&gt;
      &lt;td&gt;C0&lt;/td&gt;
      &lt;td&gt;4F&lt;/td&gt;
      &lt;td&gt;C9&lt;/td&gt;
      &lt;td&gt;E2&lt;/td&gt;
      &lt;td&gt;6E&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;I threw the string D30C1661-CDAF-11D0-8A3E-00C04FC9E26E into Google and up pops a Microsoft &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/shdocvw.iwebbrowser2?view=dynamics-usd-3&quot;&gt;page&lt;/a&gt; that tells us this corresponds to the IWebBrowser2 interface.&lt;/p&gt;

&lt;p&gt;By now it’s quite evident that this program is interfacing with Internet Explorer. Further, it doesn’t appear there is any evident persistence mechanism at this time. We just need to figure out what exactly this program is doing and when it’ll finish executing.&lt;/p&gt;

&lt;p&gt;Moving on. Let’s direct attention to this chunk of code.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/ch7sc/08_magic.PNG&quot; alt=&quot;08_magic&quot; /&gt;.&lt;/p&gt;

&lt;p&gt;The most important thing to note from this part of the code is that the COM object itself is being used to make a special function call. At the time of the &lt;code class=&quot;highlighter-rouge&quot;&gt;call dword ptr [edx+2ch]&lt;/code&gt;, the object is in edx (see how it was dereferenced from [eax] into edx earlier), and the offset 0x2c specifies a function offset from the beginning of the object. 
Identifying what function that offset corresponds to is explained on page 156 of the book. It says to go to the structures subview and then hit &lt;code class=&quot;highlighter-rouge&quot;&gt;insert&lt;/code&gt; and then click “add standard structure.” I was able to add the structure but I didn’t see a way to utilize this information to identify the function being called in the assembly. Perhaps this is an Ida pro specific feature.&lt;/p&gt;

&lt;p&gt;Either way, based on the fact that we are interfacing with Internet Explorer and we have a string that contains a URL, we can perhaps safely conclude that this program will end up having IE go to the website. Since the URL takes us to a page called “ad.html”, we can conclude this is probably adware. (Of course in the real world, we can’t validly make this assumption since anything could be called “ad.html,” but for purposes of this training, I think it’s acceptable in the interest of time.)&lt;/p&gt;

&lt;p&gt;The program ends immediately after performing these actions, which suggests persistence is not acheived and that it won’t run forever or anything like that. It’s a simple baby adware program.&lt;/p&gt;

&lt;h3 id=&quot;73&quot;&gt;7.3&lt;/h3&gt;

&lt;p&gt;I’m putting this sample on the backburner for now, as I need to move on and learn about some malware obfuscation techniques in lieu of finding a thesis project of some form. Check back later on.&lt;/p&gt;

&lt;!--

Alright, our first big boy malware sample! Apparently this malware was caught in the wild and domesticated for training purposes, so while it will no longer connect to a sketchy domain, it may still have dangerous implications unforeseen by the domesticators (i.e. Sikorski and Honig). Run it in a VM.

1. How does this program acheive persistence to ensure it continues running when the machine is rebooted?

2. What are two good host-based signatures?

3. What is the purpose of this program?

4. How could you remove this malware once it's installed?
--&gt;</content><author><name></name></author><summary type="html">Lab summary questions Considering malware analysis as a whole, how important is it to a general aspiring analyst to complete this chapter’s exercises?</summary></entry><entry><title type="html">PMA Ch. 7 notes: Analyzing Malicious Windows Programs</title><link href="http://localhost:4000/notes/2018/09/10/ch7_PMA_notes.html" rel="alternate" type="text/html" title="PMA Ch. 7 notes: Analyzing Malicious Windows Programs" /><published>2018-09-10T14:31:00-06:00</published><updated>2018-09-10T14:31:00-06:00</updated><id>http://localhost:4000/notes/2018/09/10/ch7_PMA_notes</id><content type="html" xml:base="http://localhost:4000/notes/2018/09/10/ch7_PMA_notes.html">&lt;h2 id=&quot;chapter-summary-questions&quot;&gt;Chapter summary questions&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;In two sentences or less, provide an overview of what this chapter is about.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This chapter discusses a plethora of the Windows mechanics that malware authors frequently like to make use of.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;What are the three most important takeaways from this chapter?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The attack surface for Windows-based malware is huge, and it’s important to have a grasp on as much of the workings of Windows internals as possible to be best equipped for analyzing malicious samples.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;What problems does this chapter address? In other words, why should we care about this chapter?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Windows is the most popular malware target simply because more people use Windows than other operating systems. As such, it pays to know how Windows works.&lt;/p&gt;

&lt;h2 id=&quot;windows-mechanics&quot;&gt;Windows Mechanics&lt;/h2&gt;

&lt;h3 id=&quot;common-windows-api-data-types&quot;&gt;Common Windows API Data Types&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;WORD&lt;/code&gt; (w): 16 bits&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DWORD&lt;/code&gt; (dw): 32 bits&lt;/li&gt;
  &lt;li&gt;Handle: a reference to an object. They are like pointers in that they refer to objects or memory addresses, but include more information and cannot be manipulated like pointers.
    &lt;ul&gt;
      &lt;li&gt;Examples: &lt;code class=&quot;highlighter-rouge&quot;&gt;HModule&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;HInstance&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;HKey&lt;/code&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Long Pointer (LP): Pointer to another type. 32 bits, I believe.
    &lt;ul&gt;
      &lt;li&gt;Examples: &lt;code class=&quot;highlighter-rouge&quot;&gt;LPByte&lt;/code&gt; is a pointer to a byte.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Callback: Represents a function that will be called by the Windows API.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;special-files&quot;&gt;Special Files&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Special File&lt;/strong&gt;: one that can be accessed much like other files, but are not accessed by their drive letter and path. They can be hidden to directory listings.&lt;/p&gt;

&lt;h4 id=&quot;shared-files&quot;&gt;Shared Files&lt;/h4&gt;

&lt;p&gt;These start with &lt;code class=&quot;highlighter-rouge&quot;&gt;\\serverName\share&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;\\?\serverName\share&lt;/code&gt;. The &lt;code class=&quot;highlighter-rouge&quot;&gt;\\?\&lt;/code&gt; prefix tells the OS to disable all string parsing, and allows access to longer filenames.&lt;/p&gt;

&lt;h4 id=&quot;namespaces&quot;&gt;Namespaces&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Namepsaces&lt;/strong&gt; can be thought of as a fixed number of folders, each storing different types of objects. All namespaces exist within the NT namespace, and this can be browsed using the &lt;em&gt;WinObj Object Manager namespace viewer&lt;/em&gt; from Microsoft. 
  The Win32 device namespace with the prefix &lt;code class=&quot;highlighter-rouge&quot;&gt;\\.\&lt;/code&gt; can be used to access physical devices directly, and read and write to them like a file. Again, this can be used to get around Windows API calls and avoid detection.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;It seems like namepsaces are a significant threat to analysts due to the covert abilities it equips malware with.&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;alternate-data-streams&quot;&gt;Alternate Data Streams&lt;/h4&gt;

&lt;p&gt;This allows additional data to be added to an existing file within NTFS. The extra data does not show up from within a directory listing, nor is it displayed when showing the contents of a file. &lt;em&gt;It’s only visible when viewing the stream.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;ADS data is named according to the convention &lt;em&gt;normalFile.txt:Stream:$DATA&lt;/em&gt;, which is what allows a program to read and write to a stream. (I don’t really understand the concept of streams in this context yet, but if it’s not further answered in the chapter, I’ll look it up elsewhere.)&lt;/p&gt;

&lt;h3 id=&quot;the-windows-registry&quot;&gt;The Windows Registry&lt;/h3&gt;
&lt;p&gt;The registry is used to store OS and program configuration information, such as settings and options. It is often used by malware to establish persistence in addition to its usual use of configuration. Important terminology related to the registry:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;Root Key&lt;/em&gt;: registry is divided into five top-level sections called root keys. &lt;code class=&quot;highlighter-rouge&quot;&gt;HKEY&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;hive&lt;/code&gt; are pseudonyms of this.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Key&lt;/em&gt;: It’s like a folder in the registry.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Subkey&lt;/em&gt;: it’s like a subfolder within a folder. A subkey is a key.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Value Entry&lt;/em&gt;: An ordered pair with a name and a value.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Value or Data&lt;/em&gt;: data stored in a registry entry.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;root-key-101&quot;&gt;Root Key 101&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HKEY_LOCAL_MACHINE (HKLM)&lt;/code&gt;: Stores settings global to the local machine&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HKEY_CURRENT_USER (HKCU)&lt;/code&gt;: Stores settings specific to the current user&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HKEY_CLASSES_ROOT&lt;/code&gt;: Stores info defining types&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HKEY_CURRENT_CONFIG&lt;/code&gt;: Stores settings about the current hardware configuration (especially differences between current and standard configuration)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HKEY_USERS&lt;/code&gt;: Defines settings for default/new/current users&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;popular-ways-to-establish-persistence&quot;&gt;Popular ways to establish persistence&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run&lt;/code&gt; contains values that are executables that are started as soon as a user logs in.&lt;/p&gt;

&lt;h3 id=&quot;networking-apis&quot;&gt;Networking APIs&lt;/h3&gt;
&lt;p&gt;Note that &lt;code class=&quot;highlighter-rouge&quot;&gt;WSAStartup()&lt;/code&gt; must be called before other networking functions to allocate resources for the networking libraries.&lt;/p&gt;

&lt;h4 id=&quot;berkeley-compatible-sockets&quot;&gt;Berkeley Compatible Sockets&lt;/h4&gt;
&lt;p&gt;These socket functions provide functionality that is almost identical on Unix and Windows systems, and these functions are implemented in the Winsock libraries– &lt;em&gt;ws2_32.dll&lt;/em&gt;. Most common:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;socket&lt;/code&gt;: Creates a socket.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bind&lt;/code&gt;: Attaches a socket to a particular port, prior to the accept call&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;listen&lt;/code&gt;: Indicates that a socket will be listening for incoming connections&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;accept&lt;/code&gt;: Opens a connection to a remote socket and accepts that connection&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;connect&lt;/code&gt;: Opens a connection to a remote socket that is waiting for the connection&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;recv&lt;/code&gt;: Receives data from the remote socket&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;send&lt;/code&gt;: Sends data to the remote socket&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;wininet-api&quot;&gt;WinINet API&lt;/h4&gt;
&lt;p&gt;These functions are stored in &lt;em&gt;Wininet.dll&lt;/em&gt; and provide higher-level networking APIs.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;InternetOpen&lt;/code&gt;: used to initialize a connection to the Internet&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;InternetOpenUrl&lt;/code&gt;: used to connect to a HTTP or FTP resource&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;InternetReadFile&lt;/code&gt;: allows the program to read data from a file downloaded from the Internet.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;processes&quot;&gt;Processes&lt;/h3&gt;
&lt;p&gt;The OS will allocate memory for processes on a per-process basis. One process’s addresses may be the same as another process’s addresses, but due to virtual memory and abstraction by the OS (I believe), these processes will not overlap.&lt;/p&gt;

&lt;h3 id=&quot;threads&quot;&gt;Threads&lt;/h3&gt;
&lt;p&gt;A process’s instructions are executed by one or more threads. A thread is an independent sequence of instructions that are executed by the CPU without waiting for other threads. Threads within a process share the same memory space, but each has its own processer registers and stack.&lt;/p&gt;

&lt;p&gt;Threads have complete control of the CPU when they’re executing. Their context, the &lt;em&gt;thread context&lt;/em&gt;, is saved in a structure when a context switch is performed.&lt;/p&gt;

&lt;h3 id=&quot;mutexes-aka-mutants&quot;&gt;Mutexes (aka Mutants)&lt;/h3&gt;
&lt;p&gt;These are global objects used to control access to shared resources. They often use hard-coded names, which acts as a host-based indicator to the malware analyst.&lt;/p&gt;

&lt;h3 id=&quot;services&quot;&gt;Services&lt;/h3&gt;
&lt;p&gt;These are ran by SYSTEM and can only be installed with administrator privilege. There are different types of services, each of which execute in different ways. The most commonly maliciously used type is the &lt;code class=&quot;highlighter-rouge&quot;&gt;WIN32_SHARE_PROCESS&lt;/code&gt;, type, which stores the code for the service in a DLL and combines several different services into a single, shared process.&lt;/p&gt;

&lt;p&gt;In Task Manager, there exist several &lt;em&gt;svchost.exe&lt;/em&gt; instances, and these run &lt;code class=&quot;highlighter-rouge&quot;&gt;WIN32_SHARE_PROCESS&lt;/code&gt; type services. &lt;code class=&quot;highlighter-rouge&quot;&gt;WIN32_OWN_PROCESS&lt;/code&gt; is also used because it stores the code in a .exe file and runs it as an independent process.&lt;/p&gt;

&lt;p&gt;Services information is stored in &lt;code class=&quot;highlighter-rouge&quot;&gt;HKLM\SYSTEM\CurrentControlset\Services&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;com-executables&quot;&gt;COM executables&lt;/h3&gt;
&lt;p&gt;The &lt;em&gt;Component Object Model&lt;/em&gt; is an interface standard that makes it possible for different software components to call each other’s code without knowledge of specifics of each other. It was designed to support reusable software componets that could be usable by all programs.&lt;/p&gt;

&lt;p&gt;COM is implemented as a client-server framework. The clients are what make use of the COM objects, and the servers are the reusable software components. Every thread that uses COM must call &lt;code class=&quot;highlighter-rouge&quot;&gt;OleInitialize&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;CoInitializeEx&lt;/code&gt; at least once before calling other COM library functions.&lt;/p&gt;

&lt;p&gt;COM objects are accessed via their &lt;em&gt;globally unique identifiers&lt;/em&gt; (GUIDs) known as &lt;em&gt;class identifiers (CLSIDs)&lt;/em&gt; and &lt;em&gt;interface identifiers (IIDs)&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;One common function used by malware is &lt;code class=&quot;highlighter-rouge&quot;&gt;Navigate&lt;/code&gt; which allows a program to launch Internet Explorer and access a web address. &lt;code class=&quot;highlighter-rouge&quot;&gt;Navigate&lt;/code&gt; is part of the &lt;code class=&quot;highlighter-rouge&quot;&gt;IWebBrowser2&lt;/code&gt; interface, which specifies a list of functions that must be implemented, but does not specify which program will provide that functionality. A &lt;em&gt;COM Class&lt;/em&gt; is the program that provides said functionality. Interfaces are identified with an &lt;em&gt;IID&lt;/em&gt; and the classes are identifed with a &lt;em&gt;CLSID&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;COM stuff is tricky and dense. I am going to bookmark this page (by saying here that it’s on and near p155) and come back to it if I encounter such things in malware.&lt;/p&gt;

&lt;h3 id=&quot;exceptions&quot;&gt;Exceptions&lt;/h3&gt;
&lt;p&gt;Windows uses &lt;em&gt;structured exception handling (SEH)&lt;/em&gt; to deal with handling exceptions. In 32 bit systems, SEH info is stored on the stack (which means it’s potentially vulnerable to things such as buffer overflows).&lt;/p&gt;

&lt;h3 id=&quot;kernel-vs-user-mode&quot;&gt;Kernel vs. User Mode&lt;/h3&gt;
&lt;p&gt;Nearly all code runs in user mode, save the operating system itself and hardware drivers. Usually, user mode programs do not have direct access to hardware devices and &lt;em&gt;must&lt;/em&gt; go through the Windows API. &lt;code class=&quot;highlighter-rouge&quot;&gt;SYSENTER&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;SYSCALL&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;Int 0x2E&lt;/code&gt; assembly instructions are all used to do this.&lt;/p&gt;

&lt;p&gt;All processes running in the kernel share resources and memory addresses, and kernel code has fewer security checks, not to mention it has ultimate power over a system. It’s basically the priviliged land for malware authors.&lt;/p&gt;

&lt;h3 id=&quot;the-native-api&quot;&gt;The Native API&lt;/h3&gt;
&lt;p&gt;The Native API is a lower-level interface for interacting with Windows that is rarely used by nonmalicious programs. Calling native API functions bypasses the normal Windows API. See p159 for a diagram describing how context switches from user mode to kernel mode when calling native functions. Native functions are usually predicated by Nt.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ntoskrnl.exe&lt;/code&gt; contains functions that run in kernel space.&lt;/p&gt;

&lt;h2 id=&quot;quick-windows-function-cheat-sheet&quot;&gt;Quick Windows Function Cheat Sheet&lt;/h2&gt;
&lt;p&gt;I include some unintuitive conceptual ‘gotchas’ here, but I don’t discuss details behind how to use the functions. Check out MSDN documentation for that.&lt;/p&gt;

&lt;h3 id=&quot;file-system-functions&quot;&gt;File System Functions&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;CreateFile&lt;/li&gt;
  &lt;li&gt;ReadFile and WriteFile&lt;/li&gt;
  &lt;li&gt;CreateFileMapping and MapViewOfFile
    &lt;ul&gt;
      &lt;li&gt;&lt;em&gt;File Mappings&lt;/em&gt; are commonly used by malware writers because they allow a file to be loaded into memory and manipulated easily. &lt;code class=&quot;highlighter-rouge&quot;&gt;CreateFileMapping&lt;/code&gt; loads a file from disk into memory; &lt;code class=&quot;highlighter-rouge&quot;&gt;MapViewOfFile&lt;/code&gt; returns a pointer to the base address of that mapping.&lt;/li&gt;
      &lt;li&gt;File Mappings can be used to replicate the functionality of the Windows loader– after the malware reads in an executable file to memory, it can parse the PE and do whatever it wants with it, (possibly) without the use of Windows API functions, which can help evade monitoring programs.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;common-registry-functions&quot;&gt;Common Registry Functions&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;RegOpenKeyEx&lt;/li&gt;
  &lt;li&gt;RegSetValueEx: Adds a new value to the registry and sets its data (or modifies an existing value)&lt;/li&gt;
  &lt;li&gt;RegGetValue: Get the data for a value entry in the registry&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;reg-scripts&quot;&gt;.reg scripts&lt;/h4&gt;
&lt;p&gt;You can write scripts that interact with the registry. Files with the .reg extension, when double clicked, modifies the registry by merging the info the file contains &lt;em&gt;into&lt;/em&gt; the registry.&lt;/p&gt;

&lt;h3 id=&quot;common-process-functions&quot;&gt;Common Process Functions&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;CreateProcess
    &lt;ul&gt;
      &lt;li&gt;One of the parameters to this function is the &lt;code class=&quot;highlighter-rouge&quot;&gt;startupinfo&lt;/code&gt; structure. You can configure &lt;code class=&quot;highlighter-rouge&quot;&gt;stdin&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;stdio&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;stderr&lt;/code&gt; streams in this, and potentially set them to sockets that you can send across the wire. See p148 for an example of this.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;Executables can store other executables in their resource section. An executable can extract an executable from within itself in this manner, write it to disk, and then call &lt;code class=&quot;highlighter-rouge&quot;&gt;createProcess&lt;/code&gt; to run it.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;common-thread-functions&quot;&gt;Common Thread Functions&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;CreateThread. The caller of this function specifies the start point of the thread.
    &lt;ul&gt;
      &lt;li&gt;The caller of CreateThread can specify the function where the thread starts, and a &lt;strong&gt;single&lt;/strong&gt; parameter that can be passed to this function.
        &lt;ul&gt;
          &lt;li&gt;Malware can use CreateThread to load a new malicious library into a process when LoadLibrary is what the thread is configured to run, and the parameter is the name of the library that should be passed to LoadLibrary. LoadLibrary could then load a malicious DLL, thereby invoking DllMain, which could do more malicious things.&lt;/li&gt;
          &lt;li&gt;Malware could use CreateThread to create two separate threads– one for input, and one for output.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;common-mutex-functions&quot;&gt;Common Mutex Functions&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;WaitForSingleObject is used by a thread to wait on a mutex.&lt;/li&gt;
  &lt;li&gt;ReleaseMutex is called by a thread when it’s done with a mutex. Obv.&lt;/li&gt;
  &lt;li&gt;CreateMutex: it destroys a mutex. (sarcasm)&lt;/li&gt;
  &lt;li&gt;OpenMutex: One process can get a handle to another process’s mutex by using this. Malware will commonly create a mutex and attempt to open an existing mutex with this technique to ensure only one version of the malware is running on the machine at once.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;common-services-related-functions&quot;&gt;Common Services-related Functions&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;OpenSCManager: returns a handle to the service control manager (SCM), which is used for all subsequent service-related function calls.&lt;/li&gt;
  &lt;li&gt;CreateService: adds a new service to the SCM. Caller specifies if the service is to be ran at startup or not.&lt;/li&gt;
  &lt;li&gt;StartService: You guessed it! It starts a service. It’s used only if the service is not configured to start automatically (or, say, if you just freshly installed the malware on a system and it hasn’t rebooted the machine yet).&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;transferring-execution-among-files&quot;&gt;Transferring execution among files&lt;/h2&gt;

&lt;h3 id=&quot;dll-files&quot;&gt;DLL files&lt;/h3&gt;
&lt;p&gt;DLLs export functions and cannot be ran on their own. They must run their code via an executable of some form.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;They only needed to be loaded into memory once. Then they can be used by multiple programs (unlike static libraries, which would need to be loaded on a per-exectuable-instance basis).&lt;/li&gt;
  &lt;li&gt;DLLs look extremely similar to exectuable files– they use the same format as an execuable (the PE file format).A single flag differentiates the two.&lt;/li&gt;
  &lt;li&gt;DLLs contain DllMain()– a function that has no label and isn’t an export in the DLL, but is specified in the PE header as the file’s entry point. It’s called to notify the DLL when a process loads or unloads the library, creates a new thread, or finishes an existing thread. This allows the DLL to manage any per-process or per-thread resources.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;other-page-to-page-notes&quot;&gt;Other page-to-page notes&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Autoruns&lt;/em&gt; is a program downloadable from Microsoft that lists code that’ll run automatically when the OS starts. It pulls from about 25-30 registry locations (albeit not all of the possible ones).&lt;/p&gt;</content><author><name></name></author><summary type="html">Chapter summary questions</summary></entry><entry><title type="html">PMA Ch.6 Lab: Recognizing C Constructs in Assembly</title><link href="http://localhost:4000/labs/2018/09/09/PMA_ch6_labs.html" rel="alternate" type="text/html" title="PMA Ch.6 Lab: Recognizing C Constructs in Assembly" /><published>2018-09-09T14:31:00-06:00</published><updated>2018-09-09T14:31:00-06:00</updated><id>http://localhost:4000/labs/2018/09/09/PMA_ch6_labs</id><content type="html" xml:base="http://localhost:4000/labs/2018/09/09/PMA_ch6_labs.html">&lt;h2 id=&quot;lab-summary-questions&quot;&gt;Lab summary questions&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Considering malware analysis as a whole, how important is it to a general aspiring analyst to complete this chapter’s exercises?&lt;/p&gt;

    &lt;p&gt;This lab may prove to be less challenging for those already aquainted with C programming, but it was still very helpful because of the way it starts off very easy and builds up. I’d argue that this lab was the most fun one I’ve done so far.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What did doing the lab exercises teach that was not gained from reading the chapter?&lt;/p&gt;

    &lt;p&gt;This lab helps fortify the necessity of paying attention to details, and knowing &lt;em&gt;exactly&lt;/em&gt; what the functionality of MSDN functions are.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;challenges-encountered-in-the-labs&quot;&gt;Challenges encountered in the labs&lt;/h2&gt;

&lt;p&gt;I didn’t encounter too many challenges in this lab, but I believe that was due to my knowledge of C programming. It &lt;strong&gt;significantly&lt;/strong&gt; sped up how fast I was able to gather the semantic meaning of the program because I didn’t need to look up nearly as many functions or parameters as I otherwise would have.&lt;/p&gt;

&lt;h2 id=&quot;lab-walkthrough-includes-answers&quot;&gt;Lab Walkthrough (includes answers!)&lt;/h2&gt;

&lt;h3 id=&quot;61&quot;&gt;6.1&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;What is the major code construct found in the only subroutine called by &lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;?&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/files/ch6sc/1_6.1.PNG&quot; alt=&quot;1_6.1.PNG&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;It’s an ‘if’ condition checking whether or not we’re connected to the internet.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What is the subroutine located at &lt;code class=&quot;highlighter-rouge&quot;&gt;0x40105F&lt;/code&gt;?&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sub_40105F&lt;/code&gt; is called if the code finds there is an internet connection. The first function call in this _stbuf(), which &lt;a href=&quot;https://social.msdn.microsoft.com/Forums/vstudio/en-US/838011e2-7404-4922-989e-3ceacd6e3127/how-about-the-function-stbufstdout-woks-?forum=vclanguage&quot;&gt;appears to be called in preparation for sending content to stdout&lt;/a&gt;. This is enough for me to believe that this function is simply a print function.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What is the purpose of this program?&lt;/p&gt;

    &lt;p&gt;The purpose of this program is to print whether or not an internet connection can be made.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;62&quot;&gt;6.2&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;What operation does the first subroutine called by &lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt; perform?&lt;/p&gt;

    &lt;p&gt;The first subroutine called by main is &lt;code class=&quot;highlighter-rouge&quot;&gt;sub_401000&lt;/code&gt;, which appears to be the exact same subroutine we analyzed in the problem above (i.e. the one that checks to see if we have an internet connection).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What is the subroutine located at &lt;code class=&quot;highlighter-rouge&quot;&gt;0x40117F&lt;/code&gt;?&lt;/p&gt;

    &lt;p&gt;This is printf (same answer to 6.1.2).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What does the second subroutine called by &lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt; do?&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sub_401040&lt;/code&gt;, the second subroutine, phones home looking to get a command, presumably to execute on the infected machine.&lt;/p&gt;

    &lt;p&gt;The function opens a handle to an internet resource (in this case practicalmalwareanalysis.com/cc.htm), and then, if that succeeds, heads to loc_40109d to read 0x200 bytes into a buffer using the InternetReadFile function.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/files/ch6sc/6_6.2.PNG&quot; alt=&quot;6_6.2.PNG&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;We see here that it moves in the dereferenced pointer to the buffer into ecx (i.e. the first character of the buffer), and then compares it to ascii 60. Ascii 60 corresponds to the “&amp;lt;” character, which is the first character of an HTML tag. Immediately after that, it compares to ascii 33, which is the “!” character. Then, it looks for 0x2d or 45 in decimal, which is a “-“ character. It does this twice. If at any time it detects characters that are not these, in this order, it breaks to loc_40111D, which yields an error.&lt;/p&gt;

    &lt;p&gt;So it’s looking for the string “&amp;lt;!–”. This is how a comment in an HTML document is started. We can conclude it’s looking for an HTML comment.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What type of code construct is used in this subroutine?&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/files/ch6sc/2_6.2.PNG&quot; alt=&quot;2_6.2.PNG&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;This looks like a switch nested within an if-statement.&lt;/p&gt;

    &lt;p&gt;Note from after reading the book: the answer they were looking for was an array. There is an array at work here as well, as one can tell from the above screenshot. Bytes of data one byte apart from each other, and referenced in terms of ebp, are sequentially compared, which is indicative of an array.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Are there any network-based indicators for this program?&lt;/p&gt;

    &lt;p&gt;Absolutely. We see that this block of data gets pushed as a parameter to InternetOpenUrlA:&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/files/ch6sc/3_6.2.PNG&quot; alt=&quot;3_6.2.PNG&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;And we can see what the rest of the data is by clicking szUrl.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/files/ch6sc/4_6.2.PNG&quot; alt=&quot;4_6.2.PNG&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;http://www.practicalmalwareanalysis.com/cc.htm&lt;/code&gt; is what the network fellas should look for.&lt;/p&gt;

    &lt;p&gt;The book also mentions that we can look for the user agent that this program uses, which makes sense.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What is the purpose of this malware?&lt;/p&gt;

    &lt;p&gt;The purpose of this malware is to phone home and get commands to execute on the infected machine.&lt;/p&gt;

    &lt;p&gt;If the code passes the HTML comment check, then it moves the character immediately proceeding the comment into al (which is eax’s lowest 8 bits) and returns. Then, that single character is moved into the pointer pointing to the memory address contained within ebp+var_8. This character is then pushed to be in a function that prints a single character immediately before a command, which is indicative that there are a predefined set of commands, each corresponding to a single character, that this malware can run. The purpose of the malware is to get a single character command and do something with it.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;63&quot;&gt;6.3&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Compare the calls in &lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt; to Lab 6.2’s &lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt; method. What is the new funtion called from &lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;?&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/files/ch6sc/5_6.3.PNG&quot; alt=&quot;5_6.3.PNG&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;The new function appears to be shortly after the parsing actions. I presume this function will execute the command received and parsed from the internet.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What parameters does this new function take?&lt;/p&gt;

    &lt;p&gt;Function sub_401130 takes two arguments:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;LpExistingfileName, which is, &lt;em&gt;I believe&lt;/em&gt;, the name of itself. The &lt;code class=&quot;highlighter-rouge&quot;&gt;argv&lt;/code&gt; pointer is equivalent to &lt;code class=&quot;highlighter-rouge&quot;&gt;argv[0]&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;argv[0]&lt;/code&gt; is conventionally the name of the program being executed.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;a magic character. From analysis of 6.2, we are highly confident that this particular character corresponds to a command to execute.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What major code construct does this function contain?&lt;/p&gt;

    &lt;p&gt;Ida has identified a switch. BEAUTIFUL.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/files/ch6sc/7_6.3switch.PNG&quot; alt=&quot;7_6.3switch.PNG&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What can this function do?&lt;/p&gt;

    &lt;p&gt;The function puts the character into ecx and subtracts 97. 97 corresponds to ascii ‘a’. It then jumps to a default case if the resulting number is above 4 (i.e. if the character command was not a, b, c, d, or e).&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/files/ch6sc/8_6.3.PNG&quot; alt=&quot;8_6.3.PNG&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;We see now why it subtracted 97– the resulting number is used as an index in a 5-case jump table.&lt;/p&gt;

    &lt;p&gt;The cases are:&lt;/p&gt;
    &lt;ol start=&quot;0&quot;&gt;
 &lt;li&gt; Create directory &lt;code class=&quot;highlighter-rouge&quot;&gt;C:\\Temp&lt;/code&gt;&lt;/li&gt;
 &lt;li&gt; Copy itself into directory &lt;code class=&quot;highlighter-rouge&quot;&gt;C:\\Temp&lt;/code&gt;, renaming itself &lt;code class=&quot;highlighter-rouge&quot;&gt;cc.exe&lt;/code&gt; (but if the file exists it will not overwrite the existing file)&lt;/li&gt;
 &lt;li&gt; Delete file &lt;code class=&quot;highlighter-rouge&quot;&gt;C:\\Temp\\cc.exe&lt;/code&gt;&lt;/li&gt;
 &lt;li&gt; Modify the &lt;code class=&quot;highlighter-rouge&quot;&gt;Software\\Microsoft\\Windows\\CurrentVersion\\Run&lt;/code&gt; registry key. It adds a new service &lt;code class=&quot;highlighter-rouge&quot;&gt;malware&lt;/code&gt; and sets it to execute &lt;code class=&quot;highlighter-rouge&quot;&gt;C:\\Temp\\cc.exe&lt;/code&gt;. This establishes persistence on the infected machine. &lt;/li&gt;
 &lt;li&gt; Sleep for 100000. The sleep function accepts an integer that represents milliseconds, so it sleeps for 100000/1000 = 100 seconds. &lt;/li&gt;
 &lt;li&gt; (Default case) Print an error message that says it's not a valid command. &lt;/li&gt;&lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Are there any host-based indicators for this malware?&lt;/p&gt;

    &lt;p&gt;Most definitely.&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;From case 1 above: if &lt;code class=&quot;highlighter-rouge&quot;&gt;C:\Temp&lt;/code&gt; exists, you may be infected.&lt;/li&gt;
      &lt;li&gt;From case 2 above: if &lt;code class=&quot;highlighter-rouge&quot;&gt;C:\Temp\cc.exe&lt;/code&gt; exists, you are almost surely infected.&lt;/li&gt;
      &lt;li&gt;From case 3 above: if the registry has added &lt;code class=&quot;highlighter-rouge&quot;&gt;Malware&lt;/code&gt; as a service that executes &lt;code class=&quot;highlighter-rouge&quot;&gt;C:\Temp\cc.exe&lt;/code&gt;, you’re certainly infected.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What is the purpose of this malware?&lt;/p&gt;

    &lt;p&gt;The purpose of this malware is to copy itself into a folder and establish persistence, depending on commands it receives from the internet. If the internet cannot be reached, it terminates. My guess is switch case 4 will be a cooler evil payload in 6.4.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;64&quot;&gt;6.4&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;What’s the difference between the calls made from the &lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt; method in Labs 6-3 and 6-4?&lt;/p&gt;

    &lt;p&gt;They are at different addresses, I believe. I’m not going to put too much time into comparing the two, because being able to compare things is a skill I already have.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What new code construct has been added to &lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;?&lt;/p&gt;

    &lt;p&gt;Ah, now we have the same functionality wrapped in a loop. It will wait 60 seconds every iteration, and execute 1440 times (presuming it’s connected to the internet).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What’s the difference between this lab’s parse HTML function and those of the previous labs?&lt;/p&gt;

    &lt;p&gt;Different user agent?&lt;/p&gt;

    &lt;p&gt;After reading book: Ah yes, it builds a separate user agent using &lt;code class=&quot;highlighter-rouge&quot;&gt;sprintf&lt;/code&gt;.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/files/ch6sc/9_6.4.PNG&quot; alt=&quot;9_6.4.PNG&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How long will this program run? (Assume it’s connected to the internet.)&lt;/p&gt;

    &lt;p&gt;It runs 1440 times * 60 seconds. That’s 1440 minutes, which is 24 hours.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Are there any new network-based indicators for this malware?&lt;/p&gt;

    &lt;p&gt;A different user agent that’ll follow the format of &lt;code class=&quot;highlighter-rouge&quot;&gt;Internet Explorer 7.50/pma%d&lt;/code&gt;, where the number substituted for %d is the iteration number that the malware is on. This can be used as input to the command &amp;amp; control server to serve a HTML file with a different command depending on what iteration the malware is on.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What’s the purpose of this malware?&lt;/p&gt;

    &lt;p&gt;The same as previous samples, but upgraded grab MULTIPLE commands from the command and control server back home.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><summary type="html">Lab summary questions Considering malware analysis as a whole, how important is it to a general aspiring analyst to complete this chapter’s exercises?</summary></entry><entry><title type="html">PMA Ch. 6 notes: Recognizing C Code Constructs in Assembly</title><link href="http://localhost:4000/notes/2018/09/08/ch6_PMA_notes.html" rel="alternate" type="text/html" title="PMA Ch. 6 notes: Recognizing C Code Constructs in Assembly" /><published>2018-09-08T14:31:00-06:00</published><updated>2018-09-08T14:31:00-06:00</updated><id>http://localhost:4000/notes/2018/09/08/ch6_PMA_notes</id><content type="html" xml:base="http://localhost:4000/notes/2018/09/08/ch6_PMA_notes.html">&lt;h2 id=&quot;chapter-summary-questions&quot;&gt;Chapter summary questions&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;In two sentences or less, provide an overview of what this chapter is about.&lt;/p&gt;

    &lt;p&gt;This chapter introduces how some common C code constructs look when implemented in assembly. Being able to understand what these constructs looks like is extremely helpful when analyzing malware as it’ll provide insight into the general functionality of the malware, more quickly.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What are the three most important takeaways from this chapter?&lt;/p&gt;

    &lt;p&gt;Practice is the only thing that will help a new malware analyst recognize general semantics of a program.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What problems does this chapter address? In other words, why should we care about this chapter?&lt;/p&gt;

    &lt;p&gt;This chapter provides exercises to quickly speed up analysis of executables by providing a foundation for understanding what common code constructs &lt;em&gt;generally&lt;/em&gt; look in assembly. It is, however, no substitute for practicing. Labs coming soon.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;terminology&quot;&gt;Terminology&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;code construct&lt;/strong&gt;: a code abstraction level that defines a functional property, but not the details of its implementation. 
	* if statements, for loops, switches, linked lists, etc&lt;/p&gt;

&lt;h2 id=&quot;page-to-page-notes&quot;&gt;Page-to-page notes&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;This is the part of malware analysis in which it becomes easy to get bogged down with weeds. Keeping the overall picture in mind and not getting infatuated with unnecesary details is very important.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;global-vs-local-variables&quot;&gt;Global vs Local variables&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Global variables are referenced by memory address.&lt;/li&gt;
  &lt;li&gt;Local variables are referenced relative to the stack.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;different-calling-conventions&quot;&gt;Different Calling Conventions&lt;/h3&gt;

&lt;h4 id=&quot;cdecl&quot;&gt;cdecl&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Parameters pushed ontothe stack from right to left.&lt;/li&gt;
  &lt;li&gt;Caller cleans up stack when function is complete.&lt;/li&gt;
  &lt;li&gt;Return value stored in &lt;code class=&quot;highlighter-rouge&quot;&gt;eax.&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;stdcall&quot;&gt;stdcall&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Similar to cdecl, except that stdcall requires the &lt;em&gt;callee&lt;/em&gt; to clean up the stack when the function is complete.&lt;/li&gt;
  &lt;li&gt;Windows API uses stdcall by convention.
    &lt;ul&gt;
      &lt;li&gt;Any code calling API functions will therefore not need to clean up the stack, since that’s the responsibility of the DLL that implement code for the API functions.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;fastcall&quot;&gt;fastcall&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;The first few arguments (typically two) are passed in via registers (usually &lt;code class=&quot;highlighter-rouge&quot;&gt;edx&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;ecx&lt;/code&gt;). Additional arguments are loaded from right to left.&lt;/li&gt;
  &lt;li&gt;Calling function is usually responsible for cleaning up the stack, if necessary.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;In general, you won’t know what your malware was compiled with, so you should know the concepts behind why the calling conventions work, so you can recognize the semantics of any calling convention.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;notes-on-specific-constructs&quot;&gt;Notes on specific constructs&lt;/h3&gt;

&lt;h4 id=&quot;switch-statements&quot;&gt;Switch statements&lt;/h4&gt;
&lt;p&gt;Switches are typically implemented in one of two ways: the if-style, or jump tables.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;If style: each case statement is compared to the switch conditional variable. Typically there are lots of jz’s and cmp’s in these.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Jump table style: Typically seen with large, contiguous switch statements, the compiler optimizes away lots of the comparisons. In this case, there is a lot of &lt;code class=&quot;highlighter-rouge&quot;&gt;dd offset loc_abcd&lt;/code&gt; statements following each other, and the switch variable is used as an index into that table to identify which block of code to hop to (i.e. which case to evaluate).&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;arrays&quot;&gt;Arrays&lt;/h4&gt;
&lt;p&gt;Ararys are accessed using a base address as a starting point. The size of each element is not always obious, but it can be determined by seeing how the array is being indexed.&lt;/p&gt;</content><author><name></name></author><summary type="html">Chapter summary questions In two sentences or less, provide an overview of what this chapter is about.</summary></entry><entry><title type="html">PMA Ch.5 Lab: Ida Pro Practice</title><link href="http://localhost:4000/labs/2018/09/05/PMA_Ch5_Labs.html" rel="alternate" type="text/html" title="PMA Ch.5 Lab: Ida Pro Practice" /><published>2018-09-05T10:31:00-06:00</published><updated>2018-09-05T10:31:00-06:00</updated><id>http://localhost:4000/labs/2018/09/05/PMA_Ch5_Labs</id><content type="html" xml:base="http://localhost:4000/labs/2018/09/05/PMA_Ch5_Labs.html">&lt;p&gt;Use only Ida Pro to analyze Lab05-01.dll.&lt;/p&gt;

&lt;h2 id=&quot;lab-summary-questions&quot;&gt;Lab summary questions&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Considering malware analysis as a whole, how important is it to a general aspiring analyst to complete this chapter’s exercises?&lt;/p&gt;

    &lt;p&gt;As important as the rest of the book thus far. Being able to use Ida to navigate through the binary and answer general questions about an executable is an imperative skill for malware analysts.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What did doing the lab exercises teach that was not gained from reading the chapter?&lt;/p&gt;

    &lt;p&gt;Tons of practice using Ida. Also, it helped me appreciate how quickly it is to accedentally misrepresent certain portions of disassembly (via accedentally converting instructions to constants, or strings to code, or etc). However, this can usually be undone, and “undefining” the data is very helpful in a lot of cases. (&lt;strong&gt;U&lt;/strong&gt; undefines data.)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;challenges-encountered-in-the-labs&quot;&gt;Challenges encountered in the labs&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Ida pro is needed for a couple of questions of this lab, and unfortunately, I don't have that.

Furthermore, I struggled with the symbolic constant naming portion of the lab simply because a DLL referenced in the book didn't seem to exist within my virtual environment. The problem was sidestepped via looking directly at MSDN documentation. See below for details on where the problem was encountered. 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;lab-walkthrough-includes-answers&quot;&gt;Lab Walkthrough (includes answers!)&lt;/h2&gt;

&lt;p&gt;First thing I did was change the settings to include addresses in graph mode, as was suggested by the authors of the book.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/ch5_sc/01_IdaOptionsForGraphMode.PNG&quot; alt=&quot;01_ida.PNG&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;51&quot;&gt;5.1&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;What is the address of &lt;code class=&quot;highlighter-rouge&quot;&gt;DllMain&lt;/code&gt;?&lt;/p&gt;

    &lt;p&gt;This one is easy enough. Just look in the functions window, scroll down to DllMain, and click it.&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0x1000D02E&lt;/code&gt;.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/files/ch5_sc/02_DllMain.PNG&quot; alt=&quot;02_DllMain&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Use the Imports window to browse to &lt;code class=&quot;highlighter-rouge&quot;&gt;gethostbyname&lt;/code&gt;. Where is the import located?&lt;/p&gt;

    &lt;p&gt;Imports is a tab at the top of the disassembly window. Going in there and hitting &lt;strong&gt;ctrl+f&lt;/strong&gt; to search for &lt;code class=&quot;highlighter-rouge&quot;&gt;gethostbyname&lt;/code&gt; is how I arrived at this answer.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/files/ch5_sc/03_gethostbyname.PNG&quot; alt=&quot;03_gethostbyname&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How many functions call &lt;code class=&quot;highlighter-rouge&quot;&gt;gethostbyname&lt;/code&gt;?&lt;/p&gt;

    &lt;p&gt;Ah, we need to find all cross references to &lt;code class=&quot;highlighter-rouge&quot;&gt;gethostbyname&lt;/code&gt; and count the number of unique functions in them. . Do this by hitting &lt;strong&gt;x&lt;/strong&gt; while &lt;code class=&quot;highlighter-rouge&quot;&gt;gethostbyname&lt;/code&gt; is selected.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/files/ch5_sc/04_xrefsGHBN.PNG&quot; alt=&quot;04_xrefsGHBN&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;I count &lt;strong&gt;5&lt;/strong&gt; unique functions.&lt;/p&gt;

    &lt;p&gt;This looks like good information, but what’s that strange letter in the second column? What do the letters stand for? This helpful &lt;a href=&quot;https://resources.infosecinstitute.com/ida-cross-references-xrefs/#gref&quot;&gt;post&lt;/a&gt; provided me insight into the three types of cross references.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;r: read&lt;/li&gt;
      &lt;li&gt;w: write&lt;/li&gt;
      &lt;li&gt;p: pointer&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Focusing on the call to &lt;code class=&quot;highlighter-rouge&quot;&gt;gethostbyname&lt;/code&gt; located at 0x100001757, can you figure out which DNS request will be made?&lt;/p&gt;

    &lt;p&gt;I had a minor panic attack when I didn’t see address 10001757 above, but then I noticed if we do some simple math we find that 1001656 + 101 gives us that number. Woo, ADDITION&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/files/ch5_sc/05_10001757.PNG&quot; alt=&quot;10001757.PNG&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;eax&lt;/code&gt; is being pushed as a parameter. If you hover over the operand for mov, it says “[this is RDO]pics.practicalmalwareanalys…”. Then 0xD is added to this, which pushes the offset to the beginning of the URL.&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;pics.practicalmalwareanalysis.com&lt;/strong&gt; is the DNS request being made.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How many local variables has IDA Pro recognized for the subroutine at 0x10001656?&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/files/ch5_sc/06_10001656.PNG&quot; alt=&quot;10001656.PNG&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;Let’s count em! I believe every variable in the list is a local variable, and there are &lt;strong&gt;24&lt;/strong&gt; of these. But wait! One of the elements of this list is lpThreadParameter, which is actually a parameter. So, 24-1=&lt;strong&gt;23&lt;/strong&gt; local variables.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How many parameters has IDA Pro recognized for the subroutine at 0x10001656?&lt;/p&gt;

    &lt;p&gt;Looking at how the function is called, I see one parameter: lpThreadParameter. &lt;strong&gt;1&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Use the Strings window to locate the string \cmd.exe /c in the disassembly. Where is it located?&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/files/ch5_sc/08_stringscmd.PNG&quot; alt=&quot;08_stringscmd.PNG&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;0x10095B34&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What is happening in the area of code that references \cmd.exe /c?&lt;/p&gt;

    &lt;p&gt;Double click the string, then click the address of this string in the disassembler and find cross references. Find that there is only one:&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/files/ch5_sc/09_xrefcmd.PNG&quot; alt=&quot;09_xrefcmd.PNG&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;Proceed to click this reference to see what’s going on and Ida helps us identify quickly that it’s a check to see whether cmd.exe or command.exe is the correct command to run command prompt on whatever version of Windows this malware is attacking.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/files/ch5_sc/10_cmdorcommand.PNG&quot; alt=&quot;10_cmdorcommand.PNG&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;In the same area, at 0x100101C8, it looks like dword_1008E5C4 is a global variable that helps decide which path to take. How does the malware set dword_1008E5C4? (Hint: Use dword_1008E5C4’s cross-references.)&lt;/p&gt;

    &lt;p&gt;If we look at the xrefs of this, there are three. Two are reads, and one is a write. The write is the one we are interested in because writing the variable implies that’s where it’s set to something. So if we look at where that happens…:&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/files/ch5_sc/11_xref1008e5c4.PNG&quot; alt=&quot;11_xref1008e5c4.PNG&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;So, that area is populated with whatever is in &lt;code class=&quot;highlighter-rouge&quot;&gt;eax&lt;/code&gt; after function &lt;code class=&quot;highlighter-rouge&quot;&gt;sub_10003695&lt;/code&gt; runs. Usually &lt;code class=&quot;highlighter-rouge&quot;&gt;eax&lt;/code&gt; contains return values, so we want to investigate what this function does.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/files/ch5_sc/12_sub_10003695.PNG&quot; alt=&quot;12_sub_10003695.PNG&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;This function is a wrapper for the Microsoft function GetVersionExA, which can quickly be identified (via a google search) as a function that returns the operating system version running on the machine.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A few hundred lines into the subroutine at 0x1000FF58, a series of comparisons use memcmp to compare strings. What happens if the string comparison to robotwork is successful (when memcmp returns 0)?&lt;/p&gt;

    &lt;p&gt;Look at the strings, identify where “robotwork” is, cross reference it, find it’s used here:&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/files/ch5_sc/13_robotwork.PNG&quot; alt=&quot;13_robotwork.PNG&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;So if the comparison returns 0, then eax will be 0. Test sets the flags, and then JNZ jumps if not zero, meaning the jump will be taken (the green path) if the zero flag is NOT set. The question asks what happens if memcmp returns 0, which would result in the zero flag being set, which means this jump will NOT be taken, so we follow the red path.&lt;/p&gt;

    &lt;p&gt;The red path takes us to a guaranteed calling of sub_100052A2 with parameter “s”. This function appears to query a registry key to find some data value labeled as Robot_Worktime.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What does the export PSLIST do?&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/files/ch5_sc/14_pslist.PNG&quot; alt=&quot;14_pslist.PNG&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;After briefly looking over the functions called from within PSLIST I believe PSLIST is looking through a set of processes trying to find one to inject code with.  (I see “OpenProcess” in each function guaranteed to be called from within PSLIST).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Use the graph mode to graph the cross-references from sub_10004E79. Which API functions could be called by entering this function? Based on the API functions alone, what could you rename this function?&lt;/p&gt;

    &lt;p&gt;After finding the function and getting its disassembly onscreen, I went to &lt;strong&gt;view -&amp;gt; graphs -&amp;gt; Xrefs from:&lt;/strong&gt; and obtained this graph.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/files/ch5_sc/15_xrefFrom.PNG&quot; alt=&quot;15_xrefFrom.PNG&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;strlen, sprintf, GetSystemDefaultLangId, malloc, send, free&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;I’d name it something like &lt;code class=&quot;highlighter-rouge&quot;&gt;SendSystemLanguage&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How many Windows API functions does DllMain call directly? How many at a depth of 2?&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/files/ch5_sc/16_dllMainXrefs.PNG&quot; alt=&quot;16_dllMainXrefs.PNG&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;Four direct calls: &lt;strong&gt;Strncpy, createThread, strlen, _strnicmp&lt;/strong&gt;.&lt;/p&gt;

    &lt;p&gt;In order to view calls at a depth of two, we can go to &lt;strong&gt;view -&amp;gt; graphs -&amp;gt; User Xref chart&lt;/strong&gt; and choose a recurive depth of 2. However, this doesn’t seem to have any affect on Ida demo and i’m not sure why. The information could be derived manually, however, from doing xref charts on each of the above listed functions, so I’m not going to spend more time on it.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;At 0x10001358, there is a call to Sleep (an API function that takes one parameter containing the number of milliseconds to sleep). Looking backward through the code, how long will the program sleep if this code executes?&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/files/ch5_sc/17_sleep.PNG&quot; alt=&quot;17_sleep.PNG&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;A pointer to the string “[This is CTI]30” is moved into &lt;code class=&quot;highlighter-rouge&quot;&gt;eax&lt;/code&gt;. Then, 0xD is added to it, which moves forward the address to point directly to the “30” part of the string. Then, atoi converts it to a number and stores it in &lt;code class=&quot;highlighter-rouge&quot;&gt;eax&lt;/code&gt;. Up next, 0x3E8 is multiplied into the 30 in &lt;code class=&quot;highlighter-rouge&quot;&gt;eax&lt;/code&gt;. I clicked this hex number and hit &lt;strong&gt;h&lt;/strong&gt; to turn it into a decimal number, which is 1000. So, 30*1000 is 30,000 milliseconds, which is &lt;strong&gt;30 seconds.&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;At 0x10001701 is a call to socket. What are the three parameters?&lt;/p&gt;

    &lt;p&gt;Do a ‘goto’ and go to that address. Ida lists what the three parameters are:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Protocol: 6&lt;/li&gt;
      &lt;li&gt;Type: 1&lt;/li&gt;
      &lt;li&gt;af: 2&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;All we need to do is identify what those numbers refer to. Pull up the microsoft documentation for &lt;code class=&quot;highlighter-rouge&quot;&gt;socket&lt;/code&gt; and we find that:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Protocol of 6 refers to IPPROTO_TCP, which (shockingly) configures the socket to use the TCP protocol.&lt;/li&gt;
      &lt;li&gt;Type of 1 means SOCK_STREAM, which is ‘a socket type that provides sequenced, reliable, two-way connection-based byte streams with an OOB data transmission mechanism.’&lt;/li&gt;
      &lt;li&gt;af (address family) of 2 means AF_INET– IPv4 address families.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Using the MSDN page for socket and the named symbolic constants functionality in IDA Pro, can you make the parameters more meaningful? What are the parameters after you apply changes?&lt;/p&gt;

    &lt;p&gt;We can make the parameters more meaningful, &lt;em&gt;if Ida Demo actually found the right library to load.&lt;/em&gt; It’s slightly inconvenient to look at MSDN documentation, but it gets the job done, so I’m going to move on.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Search for usage of the in instruction (opcode 0xED). This instruction is used with a magic string VMXh to perform VMware detection. Is that in use in this malware? Using the cross-references to the function that executes the in instruction, is there further evidence of VMware detection?&lt;/p&gt;

    &lt;p&gt;If we do a &lt;strong&gt;search -&amp;gt; text&lt;/strong&gt; and click &lt;strong&gt;find all occurances&lt;/strong&gt; and search for the text &lt;code class=&quot;highlighter-rouge&quot;&gt;in&lt;/code&gt;, we find that in the resulting list there is only one &lt;code class=&quot;highlighter-rouge&quot;&gt;in&lt;/code&gt; instruction. If we go to that location and cross reference the function that contains the instruction, we find that three functions call it: InstallRT, InstallSA, and InstallSB. The functions all look very similar. There certainly is evidence of VMWare detection.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/files/ch5_sc/18_vmwaredetect.PNG&quot; alt=&quot;18_vmwaredetect&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Jump your cursor to 0x1001D988. What do you find?&lt;/p&gt;

    &lt;p&gt;We find information interpreted as characters by Ida.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/files/ch5_sc/19_1001d988.PNG&quot; alt=&quot;1001d988&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If you have the IDA Python plug-in installed (included with the commercial version of IDA Pro), run Lab05-01.py, an IDA Pro Python script provided with the malware for this book. (Make sure the cursor is at 0x1001D988.) What happens after you run the script?&lt;/p&gt;

    &lt;p&gt;I don’t have Ida Pro :/&lt;/p&gt;

    &lt;p&gt;But the book states that the obfuscated string would be decoded to reveal a backdoor.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;With the cursor in the same location, how do you turn this data into a single ASCII string?&lt;/p&gt;

    &lt;p&gt;You’d hit the A key to turn it into a readable string after running the plugin.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Open the script with a text editor. How does it work?&lt;/p&gt;

    &lt;p&gt;I’ll omit this question since I cannot figure it out without doing the above two parts legitimately.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><summary type="html">Use only Ida Pro to analyze Lab05-01.dll.</summary></entry><entry><title type="html">PMA Ch.5 notes: IDA Pro</title><link href="http://localhost:4000/notes/2018/09/04/ch5_PMA_notes.html" rel="alternate" type="text/html" title="PMA Ch.5 notes: IDA Pro" /><published>2018-09-04T18:32:00-06:00</published><updated>2018-09-04T18:32:00-06:00</updated><id>http://localhost:4000/notes/2018/09/04/ch5_PMA_notes</id><content type="html" xml:base="http://localhost:4000/notes/2018/09/04/ch5_PMA_notes.html">&lt;p&gt;There is a HUGE amount of content to know about IDA, and these notes hardly puts a dent in covering the helpful content.&lt;/p&gt;

&lt;h2 id=&quot;chapter-summary-questions&quot;&gt;Chapter summary questions&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;In two sentences or less, provide an overview of what this chapter is about.&lt;/p&gt;

    &lt;p&gt;This chapter introduces Ida Pro, which is one of the most important tools in the market.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What are the three most important takeaways from this chapter?&lt;/p&gt;

    &lt;p&gt;Ida is an extremely powerful tool, and the information in the chapter is just barely enough to &lt;em&gt;get started&lt;/em&gt;. More will be provided as the book continues.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What problems does this chapter address? In other words, why should we care about this chapter?&lt;/p&gt;

    &lt;p&gt;This chapter is more of a flyover tutorial than a conceptually dense section of the book. As such, we should care because it provides tips and tricks to get a novice reverser up and running with Ida.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;terminology&quot;&gt;Terminology&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Rebasing&lt;/strong&gt;: PE files are compiled to load at a preferred base address. If the Windows loader cannot use this address (say, because it’s taken up by another program), then &lt;em&gt;rebasing&lt;/em&gt; may occur. It’s not explicitly defined in this chapter, but they do mention that if DLLs appear to be loading into processes different than what Ida says, the DLL may be being rebased, and this can be fixed by clicking the &lt;em&gt;Manual Load&lt;/em&gt; checkbox on the load file window.&lt;/p&gt;

&lt;h2 id=&quot;ida-cheatsheet&quot;&gt;Ida Cheatsheet&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;switch between graph mode and text mode: &lt;strong&gt;space&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Cross references are things that help you find where certain names are used. Think of it as the opposite of clicking a link– it goes the other direction. Find cross references with &lt;strong&gt;x&lt;/strong&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Jumping to a virtual address can be done with &lt;strong&gt;g&lt;/strong&gt;. GOTO, of course!
    &lt;ul&gt;
      &lt;li&gt;Jumping to a raw offset is possible too with &lt;strong&gt;jump -&amp;gt; jump to file offset&lt;/strong&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Has Ida failed to identify some code as a function? Create it by pressing &lt;strong&gt;p&lt;/strong&gt;.
    &lt;ul&gt;
      &lt;li&gt;Has Ida also failed to identify a EBP-based stack frame, and thus not abstracted away some simple changes that add for readability (like putting variable names into assembly instruction operand spots)? Try &lt;strong&gt;Alt+p&lt;/strong&gt;, select &lt;strong&gt;BP based frame&lt;/strong&gt;, and specify &lt;strong&gt;4 bytes for saved registers.&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Add your own comments to places by putting the cursor on a line of a disassembly and hitting &lt;strong&gt;:&lt;/strong&gt;. OR BETTER YET: put a comment on an address that has cross-references to it, and have the comment be repeated: hit &lt;strong&gt;;&lt;/strong&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Sometimes Ida mislabels numbers to be addresses, or vice versa, since everything’s a number under the hood anyway. Change numbers to cross-referencable addresses and back via &lt;strong&gt;O&lt;/strong&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;To represent highlighted bytes as code: &lt;strong&gt;C&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;To represent defined code as not a function, code, or data: &lt;strong&gt;U&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ida-tips-and-tricks&quot;&gt;Ida Tips and Tricks&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;When Idaing, you may find a few keystrokes suddenly causes the interface to become impossible to navigate (imagine the first couple times you used Vim). Reset the interface with &lt;strong&gt;Windows -&amp;gt; reset desktop.&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Similarly, if you love your current desktop configuration, do a &lt;strong&gt;Windows -&amp;gt; save desktop&lt;/strong&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Graph mode excludes certain helpful info, such as line numbers and op codes. Change this:
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;Options -&amp;gt; general -&amp;gt; select &lt;code class=&quot;highlighter-rouge&quot;&gt;line prefixes&lt;/code&gt;&lt;/strong&gt; and set number of opcode bytes to 6. Most instructions are 6 or less bytes, so setting this to 6 will allow one to see the memory locations and opcode values for each instruction in the code listing.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Auto Comments&lt;/strong&gt; can help aid analysis via adding assembly comments throughout the disassembly window. Go to &lt;strong&gt;Options -&amp;gt; General&lt;/strong&gt; and click the &lt;strong&gt;Auto Comments&lt;/strong&gt; checkbox.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;For information on plugins for Ida, see page 103. I’m not good enough to appreciate that yet, so I’m putting this subsection on the backburner for now.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;useful-analysis-windows&quot;&gt;Useful Analysis Windows&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;Functions Window&lt;/em&gt;: lists all functions in the executable and each function’s length.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Names window&lt;/em&gt;: Lists every address with a name, including functions, named code, named data, and strings.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Strings window&lt;/em&gt;: Shows all strings. Default is ASCII only; longer than 5 characters.
    &lt;ul&gt;
      &lt;li&gt;Can change this by right-clicking in the strings window and selecting setup.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Imports/Exports windows&lt;/em&gt;: self-explanatory. The exports window is helpful when analyzing DLLs (since DLLs provide exports).&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;Structures window&lt;/em&gt;: Lists the layout of all active data structures.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;In general, double clicking stuff in windows will link back to the disassembly window.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;searching&quot;&gt;Searching&lt;/h3&gt;
&lt;p&gt;The Search functionality in the disassembly window is helpful. See p.94 for more details about common searches (if they aren’t self explanatory in Ida). (Search -&amp;gt; next code, search -&amp;gt; test, search-&amp;gt; sequence of bytes for starters)&lt;/p&gt;

&lt;h3 id=&quot;graphing-options&quot;&gt;Graphing Options&lt;/h3&gt;
&lt;p&gt;Graphing options help provide insight into the control flow of the program. However, due to how they are used, it  wouldn’t be very helpful for me to annotate this section as it’s so diagram dependent. Look at page 98 for graphing options information.&lt;/p&gt;

&lt;h3 id=&quot;enhancing-the-disassembly&quot;&gt;Enhancing the disassembly&lt;/h3&gt;

&lt;h4 id=&quot;renaming-locations&quot;&gt;Renaming Locations&lt;/h4&gt;
&lt;p&gt;Should be doable by right clicking names of things like sub_400699. Changes propogate throughout the program.&lt;/p&gt;

&lt;h4 id=&quot;comments&quot;&gt;Comments&lt;/h4&gt;
&lt;p&gt;Add your own comments to places by putting the cursor on a line of a disassembly and hitting &lt;strong&gt;:&lt;/strong&gt;. OR BETTER YET: put a comment on an address that has cross-references to it, and have the comment be repeated: hit &lt;strong&gt;;&lt;/strong&gt;.&lt;/p&gt;

&lt;h4 id=&quot;formatting-operands&quot;&gt;Formatting operands&lt;/h4&gt;
&lt;p&gt;You can right click constants and represent the data there in a plethora of ways (binary, octal, hex, decimal).&lt;/p&gt;

&lt;p&gt;Imagine &lt;code class=&quot;highlighter-rouge&quot;&gt;stdin.&lt;/code&gt; What number comes straight to mind? 0, of course! &lt;code class=&quot;highlighter-rouge&quot;&gt;stdin&lt;/code&gt; is a named constant of sorts. Ida can help reverse where a compiler plugged in a number for a named constant in the initial source code. The option to do so is given in the same menu as the above options.&lt;/p&gt;

&lt;p&gt;If the constants don’t show up, then the proper libraries that correspond to those function calls may not be loaded in Ida. Do a &lt;strong&gt;View -&amp;gt; open subviews -&amp;gt; type libraries&lt;/strong&gt; to get to the submenu to change that.&lt;/p&gt;

&lt;h4 id=&quot;loading-symbolic-constants&quot;&gt;Loading symbolic constants&lt;/h4&gt;
&lt;p&gt;If you have random looking numbers being passed to Windows API functions, you can have Ida identify what constants those numbers refer to. Go to &lt;strong&gt;View -&amp;gt; Open Subviews -&amp;gt; Type Libraries&lt;/strong&gt; and then right click and load a new library. Look for &lt;code class=&quot;highlighter-rouge&quot;&gt;ntapi&lt;/code&gt; and load it. (I presume this will work assuming &lt;code class=&quot;highlighter-rouge&quot;&gt;ntapi&lt;/code&gt; shows up, which, in my case, it does &lt;em&gt;not&lt;/em&gt;.)&lt;/p&gt;

&lt;h2 id=&quot;page-to-page-notes&quot;&gt;Page-to-page notes&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;When loading a program, Ida maps the file into memory in a similar fashion to how the OS does it.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;When loading a file into Ida, you can choose to interpret the file as raw data. This can be helpful in the case that malware has additional stuff appended to the end of the executable. This extra stuff would normally not be loaded into memory.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Jump arrow color key:
    &lt;ul&gt;
      &lt;li&gt;&lt;em&gt;red&lt;/em&gt;: Jump not taken&lt;/li&gt;
      &lt;li&gt;&lt;em&gt;green&lt;/em&gt;: Jump taken&lt;/li&gt;
      &lt;li&gt;&lt;em&gt;blue&lt;/em&gt;: unconditional jump&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Ida provides a &lt;em&gt;Navigation band.&lt;/em&gt;
    &lt;ul&gt;
      &lt;li&gt;Light blue is library code recognized by Ida’s super cool ‘FLIRT’ technology.&lt;/li&gt;
      &lt;li&gt;Red is compiler generated code.&lt;/li&gt;
      &lt;li&gt;Dark blue is user-written code.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">There is a HUGE amount of content to know about IDA, and these notes hardly puts a dent in covering the helpful content.</summary></entry><entry><title type="html">PMA Ch. 4 notes: A Crash Course in x86 Disassembly</title><link href="http://localhost:4000/notes/2018/09/03/ch4_PMA_notes.html" rel="alternate" type="text/html" title="PMA Ch. 4 notes: A Crash Course in x86 Disassembly" /><published>2018-09-03T14:31:00-06:00</published><updated>2018-09-03T14:31:00-06:00</updated><id>http://localhost:4000/notes/2018/09/03/ch4_PMA_notes</id><content type="html" xml:base="http://localhost:4000/notes/2018/09/03/ch4_PMA_notes.html">&lt;h2 id=&quot;chapter-summary-questions&quot;&gt;Chapter summary questions&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;In two sentences or less, provide an overview of what this chapter is about.&lt;/p&gt;

    &lt;p&gt;This chapter lays the foundation of assembly and computer architecture required for effective malware analysis.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What are the three most important takeaways from this chapter?&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;How the stack works and how functions utilize it&lt;/li&gt;
      &lt;li&gt;What information is contained in which parts of RAM (see the Computer Architecture subsection below)&lt;/li&gt;
      &lt;li&gt;Which registers do what. I presume that’s known upon reading this section, but just in case it isn’t, this chapter cover sit.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What problems does this chapter address? In other words, why should we care about this chapter?&lt;/p&gt;

    &lt;p&gt;Without this information, one won’t even have a foundation for being able to understand what 90% of malware analysis is about– assembly instructions and how they’re used.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;page-to-page-notes&quot;&gt;Page-to-page notes&lt;/h2&gt;

&lt;h3 id=&quot;levels-of-abstraction&quot;&gt;Levels of Abstraction&lt;/h3&gt;

&lt;p&gt;There are six levels of abstraction in a computer system. From lowest to highest:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;Hardware.&lt;/em&gt; This is the actual circuitry of the system.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;Microcode.&lt;/em&gt; This is the firmware of the system. It operates &lt;em&gt;only&lt;/em&gt; on the exact circuitry for which it was designed.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;Machine code.&lt;/em&gt; The machine code level consists of &lt;em&gt;opcodes&lt;/em&gt;, which are hex digits that tell the processor what to do. Machine code is the result of the compilation process.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;Low-level languages.&lt;/em&gt; Assembly and the like is what is found here, and is generally accepted as the lowest-level human-readable abstraction level. There are several dialects of assembly, among which include x86, which is what is taught in this book. &lt;strong&gt;Assembly is the highest level language that can be reliably and consistently recovered from machine code when the high level source code is unavailable (as it usually is.)&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;High-level languages.&lt;/em&gt; Things like C, C++, etc.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;Interpreted languages.&lt;/em&gt; Languages like Java, C#, Perl, .NET. Interpreted languages are not compiled but are instead translated into &lt;em&gt;bytecode&lt;/em&gt;, which is an intermediate representation specific to the programming language. It executes within an &lt;em&gt;interpreter&lt;/em&gt;, which translates bytecode into executable machine code on the fly at runtime.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;computer-architecture&quot;&gt;Computer Architecture&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;RAM contains the Stack, Heap, Code, and Data of a program.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;em&gt;Data&lt;/em&gt;. Contains the data section, which contain values put in place when a program is initially loaded. These are static values (opposite of dynamic values which are contained within the heap), or they are global values since they’re available to any part of the program.&lt;/li&gt;
      &lt;li&gt;&lt;em&gt;Code.&lt;/em&gt; Instructions for the CPU are here.&lt;/li&gt;
      &lt;li&gt;&lt;em&gt;Heap.&lt;/em&gt; Used for dynamic memory during program execution.&lt;/li&gt;
      &lt;li&gt;&lt;em&gt;Stack.&lt;/em&gt; Used for local variables and parameters for functions, and to help control program flow. More on this later.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Operands&lt;/em&gt; take one of three forms.
    &lt;ul&gt;
      &lt;li&gt;&lt;em&gt;Immediates&lt;/em&gt;: fixed values. Ex: &lt;code class=&quot;highlighter-rouge&quot;&gt;0x42&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;em&gt;Registers&lt;/em&gt;: refer to registers. Self-explanatory. Ex: &lt;code class=&quot;highlighter-rouge&quot;&gt;eax, esp, ah&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;em&gt;Memory addresses&lt;/em&gt;: refer to memory addresses which in turn could point to locations in memory or registers. Ex: &lt;code class=&quot;highlighter-rouge&quot;&gt;[eax]&lt;/code&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Registers&lt;/em&gt; are small amounts of data storage available to the CPU. We have four different kinds of registers.
    &lt;ul&gt;
      &lt;li&gt;&lt;em&gt;General&lt;/em&gt; registers are used by the CPU during execution.&lt;/li&gt;
      &lt;li&gt;&lt;em&gt;Segment&lt;/em&gt; registers are used to track sections of memory.&lt;/li&gt;
      &lt;li&gt;&lt;em&gt;Status flags&lt;/em&gt; are used to make decisions and are modified by certain instructions.&lt;/li&gt;
      &lt;li&gt;&lt;em&gt;Instruction pointers&lt;/em&gt; point to the next instruction to execute.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;notes-on-specific-assembly-instructions&quot;&gt;Notes on specific assembly instructions&lt;/h3&gt;
&lt;p&gt;The book uses Intel syntax, which follows a &lt;code class=&quot;highlighter-rouge&quot;&gt;dest, src&lt;/code&gt; notation.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;LEA &lt;em&gt;dest, src&lt;/em&gt; is used as a quick way to calculate an effective address. For example, &lt;code class=&quot;highlighter-rouge&quot;&gt;lea eax, [ebx + 8]&lt;/code&gt; puts the value specified within ebx, +8, into eax.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SUB will subtract into the destination register.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;MUL and DIV always operate on EAX.
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MUL *value*&lt;/code&gt; will calculate EDX:EAX = EAX * value&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DIV *value*&lt;/code&gt; will calculate EDX:EAX (treating the two as a compound register) by value, and store the quotient (division) in eax, and the remainder (modulus) in edx.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;XOR is a common instruction used to zero things out. &lt;code class=&quot;highlighter-rouge&quot;&gt;XOR eax, eax&lt;/code&gt; =&amp;gt; eax is 0 now.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;TEST and CMP are used to set flags. They do not affect operands. See p80 for a little table that helps make sense of what cmp sets under what conditions.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;The REP family of instructions are used for manipulating data buffers. I won’t bother with understanding these in too much depth at the moment, as it’s something that can be easily looked up when I’m face-to-face with a rep instruction later on. See page 81.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;stack-details&quot;&gt;Stack Details&lt;/h3&gt;
&lt;p&gt;It’s very important to know how the stack is used to conduct function calls, as it is frequently abused.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Arguments are &lt;code class=&quot;highlighter-rouge&quot;&gt;push&lt;/code&gt;ed onto the stack.&lt;/li&gt;
  &lt;li&gt;A &lt;code class=&quot;highlighter-rouge&quot;&gt;call [functionName]&lt;/code&gt; occurs. FunctionName is simply a pointer to some code.
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;call&lt;/code&gt; is a compound instruction– that is, it is an instruction that combines two others. In this case, those two instructions are &lt;code class=&quot;highlighter-rouge&quot;&gt;push eip&lt;/code&gt; followed by &lt;code class=&quot;highlighter-rouge&quot;&gt;mov eip, functionName&lt;/code&gt;. In this manner, the return address is saved onto the stack.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Function prologue stuff (i.e. boiler plate stuff) happens now. Space is allocated on the stack for local variables, and &lt;code class=&quot;highlighter-rouge&quot;&gt;ebp&lt;/code&gt; is pushed onto the stack. Pushing &lt;code class=&quot;highlighter-rouge&quot;&gt;ebp&lt;/code&gt; ‘saves the context’ of the stack as it was before the function was called, which is important as we need that context back after the function completes.&lt;/li&gt;
  &lt;li&gt;The function does its work.&lt;/li&gt;
  &lt;li&gt;Now, the stack is restored to the state in which it was before the function was called, via a function epilogue. &lt;code class=&quot;highlighter-rouge&quot;&gt;ebp&lt;/code&gt; is restored to what it was. &lt;code class=&quot;highlighter-rouge&quot;&gt;leave&lt;/code&gt; is often used to restore the stack as &lt;code class=&quot;highlighter-rouge&quot;&gt;leave&lt;/code&gt; does a &lt;code class=&quot;highlighter-rouge&quot;&gt;mov esp, ebp&lt;/code&gt; followed by a &lt;code class=&quot;highlighter-rouge&quot;&gt;pop ebp&lt;/code&gt;, which is all that needs to happen to set the stack back to what it was– as long as things weren’t modified by the function.&lt;/li&gt;
  &lt;li&gt;The function returns by calling &lt;code class=&quot;highlighter-rouge&quot;&gt;ret&lt;/code&gt;. &lt;code class=&quot;highlighter-rouge&quot;&gt;ret&lt;/code&gt; does a &lt;code class=&quot;highlighter-rouge&quot;&gt;pop eip&lt;/code&gt;, which transfers control back to the calling function.&lt;/li&gt;
  &lt;li&gt;The stack is adjusted to remove arguments that were sent, unless they’ll be sent again later.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Diagrams are great for visualing the stack. Due to fear of copyright stuff, I’ll just tell you that a great diagram can be found on p79.&lt;/p&gt;

&lt;p&gt;Note that the stack grows upward (i.e. as things are pushed onto the stack, memory addresses of ‘higher’ items are lower in value than memory addresses of ‘lower’ items.&lt;/p&gt;

&lt;p&gt;Finally, note that function &lt;em&gt;arguments&lt;/em&gt; are going to be at a positive offset relative to EBP, while &lt;em&gt;local variables&lt;/em&gt; are going to be at a negative offset relative to EBP.&lt;/p&gt;</content><author><name></name></author><summary type="html">Chapter summary questions In two sentences or less, provide an overview of what this chapter is about. This chapter lays the foundation of assembly and computer architecture required for effective malware analysis.</summary></entry><entry><title type="html">PMA Ch.3 Lab: Basic Dynamic Analysis</title><link href="http://localhost:4000/lab_assignment/2018/08/29/PMA_Ch3_Labs.html" rel="alternate" type="text/html" title="PMA Ch.3 Lab: Basic Dynamic Analysis" /><published>2018-08-29T12:31:00-06:00</published><updated>2018-08-29T12:31:00-06:00</updated><id>http://localhost:4000/lab_assignment/2018/08/29/PMA_Ch3_Labs</id><content type="html" xml:base="http://localhost:4000/lab_assignment/2018/08/29/PMA_Ch3_Labs.html">&lt;h2 id=&quot;lab-summary-questions&quot;&gt;Lab summary questions&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Considering malware analysis as a whole, how important is it to a general aspiring analyst to complete this chapter’s exercises?&lt;/p&gt;

    &lt;p&gt;Very important. Applying the dynamic analysis processes described in this chapter and becoming used to the tools discussed within is going to be helpful experience for when it comes to analyze just about any other piece of malware.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What did doing the lab exercises teach that was not gained from reading the chapter?&lt;/p&gt;

    &lt;p&gt;In this case, it was mainly just practice using the tools.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;challenges-encountered-in-the-labs&quot;&gt;Challenges encountered in the labs&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Using ProcMon to find imports wasn’t done &lt;em&gt;quite&lt;/em&gt; how the book indicated it would be done– I didn’t have a way to launch “depends.exe” in the options generated from right clicking the malicious process. After consulting a &lt;a href=&quot;https://support.microsoft.com/en-us/help/970920/using-process-explorer-to-list-dlls-running-under-the-outlook-exe-proc&quot;&gt;post from Microsoft on how to view imports using ProcMon&lt;/a&gt;, it was made clear that all I needed to do was go to view -&amp;gt; click show lower pane, and then imports could be viewed in the lower pane for whatever process I had selected.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;lab-walkthrough-includes-answers&quot;&gt;Lab Walkthrough (includes answers!)&lt;/h2&gt;

&lt;h3 id=&quot;31&quot;&gt;3.1&lt;/h3&gt;
&lt;p&gt;Analyze the malware found in the file &lt;em&gt;Lab03-01.exe&lt;/em&gt; using basic dynamic analysis tools.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;What are this malware’s imports and strings?&lt;/p&gt;

    &lt;p&gt;Imports:&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/files/ch3_sc2/3.1.1imports.PNG&quot; alt=&quot;3.1.1imports&quot; title=&quot;imports&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;Strings:&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/files/ch3_sc2/3.1.1strings.PNG&quot; alt=&quot;3.1.1strings&quot; title=&quot;strings&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;Note that ProcExp found that the strings on the image as well as on disk were identical.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What are the malware’s host-based indicators?&lt;/p&gt;

    &lt;p&gt;It doesn’t create any files. It doesn’t seem to modify keys (for, say, persistence). I don’t see any evident host based indicators.&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;This seems weird.&lt;/strong&gt; The file crashes. At first I thought that was part of the operation of the file, but with no strange seeming imports and relatively normal strings and no indicators, the file seemed especially well-behaved. After looking into what the “error” message I recieved meant, I now know that the file doesn’t run well on a 64-bit Windows 7 VM.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/files/ch3_sc2/3.1.2fail1.PNG&quot; alt=&quot;fail1&quot; title=&quot;64-bit Windows 7 runtime error&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;And after reading up a little on &lt;a href=&quot;https://superuser.com/questions/610495/the-application-was-unable-to-start-correctly-0xc0000018-windows-8-x64&quot;&gt;what this cryptic error might have meant&lt;/a&gt;, and after trying the top answer in the question to no avail, I decided I needed to try it in a 32 bit environment.&lt;/p&gt;

    &lt;p&gt;So, I spun up a 32-bit windows VM real quick and ran it again…:&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/files/ch3_sc2/3.1.2fail2.PNG&quot; alt=&quot;fail2&quot; title=&quot;32-bit Windows 7 runtime error&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;Ugh. That’s probably not normal either. So, I looked into what &lt;a href=&quot;https://jmprsp.wordpress.com/2016/01/28/practical-malware-analysis-basic-dynamic-techniques-lab-3-01/&quot;&gt;someone else did&lt;/a&gt; and discovered an explanation that seemed to hint towards how this particular sample was built to leverage a Windows XP-specific function– one that was changed in Windows 7.&lt;/p&gt;

    &lt;p&gt;No wonder this sample seemed well-behaved on the 64-bit version of Windows 7– it doesn’t do anything. Unfortunately, I don’t currently have access to a Windows XP .iso, so I’m going to have to put this problem on the backburner. In any case, after reading the answers and what jmprsp did, I’m thinking it wouldn’t have been too difficult to identify this malware’s pesky behavior in an environment in which the malware would actually properly run.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Are there any useful network-based signatures for this malware? If so, what are they?&lt;/p&gt;

    &lt;p&gt;Strings shows the presence of &lt;code class=&quot;highlighter-rouge&quot;&gt;www.practicalmalwareanalysis.com&lt;/code&gt; but due to previously described problems, a true analysis of this sample could not be completed.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;32&quot;&gt;3.2&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;How can you get this malware to install itself?&lt;/p&gt;

    &lt;p&gt;After strictly reading this question, the first thing that comes to mind is we need to use rundll32.exe to run this file, but we need to know what DLL functions should be ran. If we use Ida to check out the exports, we find there exist a few:&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/files/ch3_sc2/3.2.1dllexports.PNG&quot; alt=&quot;3.2.1dllexports&quot; /&gt;)&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Install&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;installA&lt;/code&gt; look promising. Let’s try running &lt;code class=&quot;highlighter-rouge&quot;&gt;Install&lt;/code&gt; with rundll32.exe and see what happens.&lt;/p&gt;

    &lt;p&gt;First, I start up Procmon and…&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rundll32.exe Lab03-02.dll, Install&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/files/ch3_sc2/3.2.2fail.PNG&quot; alt=&quot;3.2.2fail.PNG&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;UGH. WHY.&lt;/p&gt;

    &lt;p&gt;It doesn’t work on 32 bit versions of Windows 7 either, even when ran as an administrator. It looks like this is another piece of Windows XP-specific malware. Unfortunately, I cannot continue with this sample either. Review &lt;a href=&quot;https://jmprsp.wordpress.com/2016/01/31/practical-malware-analysis-basic-dynamic-techniques-lab-3-02/&quot;&gt;jmprsp’s work here&lt;/a&gt; and move on.&lt;/p&gt;

    &lt;p&gt;We will return to this problem as soon as I hit chapter 5 (i.e. the Ida chapter), and identify the exact problem behind why it won’t run. Maybe it’s something that can be fixed.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How would you get this malware to run after installation?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How can you find the process under which this malware is running?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Which filters could you set in order to use procmon to glean information?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What are the malware’s host-based indicators?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Are there any useful network-based signatures for this malware?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;realizations-made-after-reading-the-book-answers&quot;&gt;Realizations made after reading the book answers:&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;here&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;33&quot;&gt;3.3&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;What do you notice when monitoring this malware with Process Explorer?&lt;/p&gt;

    &lt;p&gt;I notice that I get yet another Windows error. This time, it’s 0xc0000142. Frustrating.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/files/ch3_sc2/3.3.1svchostfail.PNG&quot; alt=&quot;3.3.1svchostfail.PNG&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;Although, the failure is coming from svchost.exe – NOT Lab03-03.exe. After running it again, I noticed that Lab03-03.exe appears to spawn this svchost.exe and then exits, which leaves svchost.exe a zombie process. I’m not sure what that svchost.exe is trying to do yet. We know it’s failing with error 0xc0000142, and if we look into &lt;a href=&quot;https://answers.microsoft.com/en-us/windows/forum/windows_10-performance-winpc/error-0xc0000142/3da27a75-178c-4de5-b43c-c538e6005540&quot;&gt;what causes this error&lt;/a&gt; we find that it has something to do with system files not existing, which is indicative of another Windows XP vs 7 problem.&lt;/p&gt;

    &lt;p&gt;In either case, however, running the program in a 32 bit environment yielded a different error than when in a 64 bit environment. Upon viewing the procmon logs on the 32-bit version, it looks like svchost, before crashing, successfully completes a &lt;em&gt;lot&lt;/em&gt; of registry querying.&lt;/p&gt;

    &lt;p&gt;Further, if we look at HOW svchost.exe is called, we notice it’s not called in any special way:&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/files/ch3_sc2/3.3.2svchostcall.PNG&quot; alt=&quot;3.3.2svchostcall.PNG&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;Yet, it appears to be querying the entire registry. I don’t think this is svchost.exe’s main function. This smells like process injection, which could be what ends up causing the Windows error when this malware arrives at the functionality that is supposed to come after the registry querying. Further, process injection often works only for specific builds of Windows (i.e. injecting a process in Windows 7 may not work the same way as injecting a process in Windows XP). I think that’s why we receive a runtime error when runnign this in Windows 7.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Can you identify any live memory modifications?&lt;/p&gt;

    &lt;p&gt;If svchost didn’t unexpectedly crash, I would view the process properties from within procexp and compare the strings in the image to the strings on disk, and, as is confirmed by &lt;a href=&quot;https://jmprsp.wordpress.com/2016/01/31/practical-malware-analysis-basic-dynamic-techniques-lab-3-03/&quot;&gt;jmprsp in his post on ch3 lab3&lt;/a&gt;, we would find that they are indeed very different, which demonstrates process injection as well.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What are the malware’s host-based indicators?&lt;/p&gt;

    &lt;p&gt;This question would be easier to answer if the program ran correctly.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What is the purpose of this program?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;34&quot;&gt;3.4&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;What happens when you run this file?&lt;/p&gt;

    &lt;p&gt;Running the file results in the file’s deleting itself!  (FINALLY, MALWARE THAT RUNS PROPERLY IN A WINDOWS 7 ENVIRONMENT WOOOO).&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/files/ch3_sc2/3.4.1proctree.PNG&quot; alt=&quot;3.4.1proctree.PNG&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;The process tree provided by ProcMon (view -&amp;gt; process tree) shows that cmd is spawned by Lab03-04.exe with a delete command for the initial binary. It doesn’t appear to do much more, despite the fact that there is lots of potential functionality, judging from the imported functions.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What is causing the roadblock in dynamic analysis?&lt;/p&gt;

    &lt;p&gt;If we look at the code using Ida, we see that it calls main passing in command line arguments…&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/files/ch3_sc2/3.4.1callmain.PNG&quot; alt=&quot;3.4.1callmain.PNG&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;and that something happens if there is only one argument passed to the program (i.e. if no command line arguments are passed in).&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/files/ch3_sc2/3.4.2main.PNG&quot; alt=&quot;3.4.2main.PNG&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;Perhaps this is the issue.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Are there other ways to run this program?&lt;/p&gt;

    &lt;p&gt;If we running the program on the command line (i.e. cmd.exe) we can easily pass in more arguments. However, without doing a deeper dive into what sorts of arguments it may require/need, we can’t further process what this program does. I suspect we’ll return to this program shortly after the Ida chapter.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><summary type="html">Lab summary questions Considering malware analysis as a whole, how important is it to a general aspiring analyst to complete this chapter’s exercises?</summary></entry><entry><title type="html">PMA Ch.3 notes: Basic Dynamic Analysis</title><link href="http://localhost:4000/notes/2018/08/22/ch3_PMA_notes.html" rel="alternate" type="text/html" title="PMA Ch.3 notes: Basic Dynamic Analysis" /><published>2018-08-22T14:31:00-06:00</published><updated>2018-08-22T14:31:00-06:00</updated><id>http://localhost:4000/notes/2018/08/22/ch3_PMA_notes</id><content type="html" xml:base="http://localhost:4000/notes/2018/08/22/ch3_PMA_notes.html">&lt;h2 id=&quot;chapter-summary-questions&quot;&gt;Chapter summary questions&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;In two sentences or less, provide an overview of what this chapter is about.&lt;/p&gt;

    &lt;p&gt;This chapter introduces dynamic analysis as well as the main tools used to perform it and how to use those tools. &lt;strong&gt;Dynamic analysis&lt;/strong&gt; is the act of observing a program run, and gathering information about what it’s doing by watching it do its thing in real time while monitoring the state of the machine with several tools.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What are the three most important takeaways from this chapter?&lt;/p&gt;

    &lt;p&gt;Dynamic Analysis is powerful for analytic reasons, but dangerous, since it involves actually running malware. It’s important to have properly set up a malware analysis environment before doing this form of analysis.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What problems does this chapter address? In other words, why should we care about this chapter?&lt;/p&gt;

    &lt;p&gt;The workflow introduced in this chapter is &lt;em&gt;typically&lt;/em&gt; the same workflow used to analyze most malware samples, and provides overview information to the analyst about what the malware does. It is effectively the second step of the analysis process and it will generally help direct the analyst’s efforts by showing them what they need to look more in depth at.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;terminology-and-keys&quot;&gt;Terminology and Keys&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Dynamic Analysis&lt;/strong&gt; is any examination performed during or after executing malware. It permits viewing of the malware’s true functionality.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Do static analysis first. Dynamic analysis is (obviously) much more dangerous.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Sandboxes&lt;/strong&gt; are ($$$$) security mechanisms for running untrusted programs in a safe environment without fear of harming “real” systems.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;They are automated, and often make use of the CVD to check for common vulnerabilities being exploited.&lt;/li&gt;
  &lt;li&gt;They do, however, tend to just run the executable without command line options, which may not mimic the environment in which the malware was designed to execute in.&lt;/li&gt;
  &lt;li&gt;Like virtual machines, sandboxes are detectable and may report an exectuable as not malicious if it senses its in a sandbox and reacts differently than in normal circumstances.&lt;/li&gt;
  &lt;li&gt;Sandboxes can tell you specifics behind what a malware sample does, but it cannot perform overall semantic analysis.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Service Entries key: &lt;code class=&quot;highlighter-rouge&quot;&gt;HKLM\SYSTEM\CurrentControlSet\Services&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Services ran at startup: &lt;code class=&quot;highlighter-rouge&quot;&gt;HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;page-to-page-notes&quot;&gt;Page-to-page notes&lt;/h2&gt;

&lt;h3 id=&quot;running-dlls&quot;&gt;Running DLLs&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;rundll32.exe&lt;/em&gt; is what we use to run functions or ordinals from DLL files. Syntax:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C:\rundll32.exe DLLname, export arguments
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So, imagine you open up a file &lt;em&gt;rip.dll&lt;/em&gt; and examine its exports with PEView or with PE Explorer, and you see it has two exports: Install, Uninstall. You can run of these as such:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C:\rundll32.exe rip.dll, Install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Or if there are functions exported by ordinal (i.e. as an exported function with only an ordinal number), you do this sort of thing:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C:\rundll32.exe someDll.exe, #5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The pound (#) is important.&lt;/p&gt;

&lt;p&gt;DLLMain() is executed whenever a DLL is loaded, so you can often get information dynamically by forcing the DLL to load using runndll32.exe. Alternatively, a DLL can be turned into an executable by modifying the PE header and changing its extension to force Windows to load the DLL as it would an executable.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Modifying the PE header: wipe the &lt;code class=&quot;highlighter-rouge&quot;&gt;IMAGE_FILE_DLL&lt;/code&gt; (0x2000) flag from teh characteristics field in the &lt;code class=&quot;highlighter-rouge&quot;&gt;IMAGE_FILE_HEADER&lt;/code&gt;. This won’t run imported functions, but it will run the DLLMain() method.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Malware may install itself as a service too, potentially using a legit utility such as the convenient export &lt;code class=&quot;highlighter-rouge&quot;&gt;InstallService&lt;/code&gt; from ipr32x.dll:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C:\&amp;gt; rundll32 ipr32x.dll,InstallService serviceNameHere
C:\&amp;gt; net start serviceNameHere
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;You can use &lt;code class=&quot;highlighter-rouge&quot;&gt;sc&lt;/code&gt; on cmd to play with services as well.&lt;/p&gt;

&lt;p&gt;(I presume there is a 64 bit version of rundll for Windows but I’ve not looked into what it is at time of writing.)&lt;/p&gt;

&lt;h3 id=&quot;faking-a-network&quot;&gt;Faking a Network&lt;/h3&gt;
&lt;p&gt;If the malware reaches out to an external domain, it’s helpful to fake being that external domain to further watch how the malware behaves. The book discusses using ApateDNS and Netcat on p51, but I’m going to use INetSim on a Remnux box and Wireshark to observe network behavior (see further down for more details on INetSim).&lt;/p&gt;

&lt;h2 id=&quot;tools-discussed-in-this-section&quot;&gt;Tools discussed in this section&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;procmon&lt;/strong&gt; is an advanced, extremely helpful monitoring tool for Windows that provides a way to monitor certain registry, file system, network, process, and thread activity.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;It can miss device driver activity of a user-mode component talking to a rootkit via device I/O controls, and can miss certain GUI calls such as &lt;code class=&quot;highlighter-rouge&quot;&gt;SetWindowsHookEx&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Generally, it shouldn’t be used for logging network activity, as it doesn’t work consistently across Microsoft Windows versions.&lt;/li&gt;
  &lt;li&gt;Using procmon: at and around pg44.&lt;/li&gt;
  &lt;li&gt;Filtering is super important with Procmon.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Process Explorer&lt;/strong&gt; is a free utility provided by Microsoft, probably as part of &lt;a href=&quot;https://docs.microsoft.com/en-us/sysinternals/downloads/sysinternals-suite&quot;&gt;sysinternals&lt;/a&gt;.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Use it for listing active processes, DLLs loaded by a process, various process properties, and overall system information. It can also be used to kill processes, log out users, and launch/validate processes.&lt;/li&gt;
  &lt;li&gt;It dynamically shows when new processes are created or modified, as well as what created them.&lt;/li&gt;
  &lt;li&gt;You can &lt;em&gt;verify&lt;/em&gt; binaries with it. There’s a verify button on the image tab, and the image tab is found when viewing a process’s properties. The verify button checks to see if the image on disk is the microsoft signed binary.
    &lt;ul&gt;
      &lt;li&gt;This can be used to identify process replacement/injection, since that involves modifying the executable, which’ll screw up the signature of the file.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;There is a strings window in the process properties collection of tabs as well. It can check for strings in the in-memory process as well as the on-disk image. If the strings vary greatly, you know that something fishy is going on.&lt;/li&gt;
  &lt;li&gt;You can use process explorer to launch depends.exe – Dependency Walker – on a running process. Right click a process name and select “Launch Depends.”&lt;/li&gt;
  &lt;li&gt;It can be used to analyze malicious documents by observing processes opened when clicking a malicious document. The image tab will tell you exactly where the malicious payload executed by the document is on disk.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Regshot&lt;/strong&gt; is used to take snapshots of the registry. Take the first shot before running the malware, and take the second shot after. It then tells you of all differences between the two snapshots.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Wireshark&lt;/strong&gt; is briefly discussed on page 53.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;INetSim&lt;/strong&gt; is free, Linux-based software for simulating common Internet servies. It’s widely accepted as the best tool for providing fake services, allowing you to analyze the network behavior by emulating servies such as HTTP(S), FTP, IRC, DNS, SMTP, and others. See page 55 of the book for a full list.&lt;/p&gt;

&lt;h2 id=&quot;malware-analysis-work-flow&quot;&gt;Malware Analysis Work Flow&lt;/h2&gt;
&lt;p&gt;Typically, you will use many of the tools simultaneously when executing and observing malware. My generic work flow sessions tend to go like this:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;If you’re observing network traffic, set up your virtual network (instructions to do this will be provided later).&lt;/li&gt;
  &lt;li&gt;Run procmon but don’t capture events yet.&lt;/li&gt;
  &lt;li&gt;Start process explorer.&lt;/li&gt;
  &lt;li&gt;Start regshot.&lt;/li&gt;
  &lt;li&gt;If you’re observing network business, start Wireshark and INetSim on the remnux box.&lt;/li&gt;
  &lt;li&gt;Take a VMWare Snapshot so you can return to this point multiple times for multiple detonations of the malware.&lt;/li&gt;
  &lt;li&gt;Take the first registry snapshot.&lt;/li&gt;
  &lt;li&gt;Begin capturing procmon events. (regshot is super noisy and doing it outside of the procmon analysis window makes it such that that noise is ignored).&lt;/li&gt;
  &lt;li&gt;Detonate the malware!&lt;/li&gt;
  &lt;li&gt;Stop the capture of events after malware finishes running (or you’re done running it or whatever)&lt;/li&gt;
  &lt;li&gt;Take the second registry snapshot.&lt;/li&gt;
  &lt;li&gt;Analyze.&lt;/li&gt;
  &lt;li&gt;Revert back to the previous VMWare snapshot and do it again making whatever changes you want to make.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The book also provides a solid sample analysis sesh starting on page 57.&lt;/p&gt;</content><author><name></name></author><summary type="html"></summary></entry></feed>